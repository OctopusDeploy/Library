{
  "Id": "ActionTemplates-60",
  "Name": "Deploy SSRS Reports from a package",
  "Description": "Uploads SSRS reports to an SSRS server from a NuGet package.",
  "ActionType": "Octopus.Script",
  "Version": 44,
  "Properties": {
    "Octopus.Action.Script.ScriptBody": "$DeployedPath = $OctopusParameters[\"Octopus.Action[$NugetPackageStepName].Output.Package.InstallationDirectoryPath\"]\r\n$ReleaseNumber = $OctopusParameters[\"Octopus.Release.Number\"]\r\n\r\n\r\n#region Upload-Item\r\nFunction Upload-Item\r\n{\r\n    # parameters\r\n    param ([string] $Item, [string]$ItemType, [string] $ItemFolder)\r\n\r\n    Write-Host \"Loading data from $Item\"\r\n    $ItemData = [System.IO.File]::ReadAllBytes($Item)\r\n\r\n    # Create local variables\r\n    $Warnings = $null\r\n    $ItemName = $Item.SubString($Item.LastIndexOf(\"\\\") + 1)\r\n    $ItemName = $ItemName.SubString(0, $ItemName.IndexOf(\".\"))\r\n   \r\n\t# upload item\r\n    if ($IsReportService2005) {\r\n        if($ItemType -eq \"Report\")\r\n        {\r\n\t        [void]$ReportServerProxy.CreateReport($ItemName, $ItemFolder, $true, $ItemData, $null)\r\n        }\r\n        else\r\n        {\r\n            # error\r\n            Write-Error \"$ItemType is not supported in ReportService2005\"\r\n        }\r\n\t}\r\n\telseif ($IsReportService2010) {\r\n\t\t[void]$ReportServerProxy.CreateCatalogItem($ItemType, $ItemName, $ItemFolder, $true, $ItemData, $null, [ref] $Warnings);\r\n\t}\r\n\telse { Write-Warning 'Report Service Unknown in Upload-Item method. Use ReportService2005 or ReportService2010.' }\r\n}\r\n#endregion\r\n\r\n#region Get-ItemDataSourceNames()\r\nFunction Get-ItemDataSourceNames\r\n{\r\n    # Parameters\r\n    Param ($ItemFile, $DataSourceName)\r\n\r\n    # declare working variables\r\n    $DataSourceNames = @()\r\n    \r\n    # load the xml\r\n    [xml]$Xml = Get-Content $ItemFile\r\n\r\n    # retrieve the datasource nodes\r\n    $DataSourceReferenceNodes = $Xml.GetElementsByTagName(\"DataSource\")\r\n\r\n    # loop through returned results\r\n    foreach($Node in $DataSourceReferenceNodes)\r\n    {\r\n        # check to see if we're looking for a specific one\r\n        if($DataSourceName -ne $null)\r\n        {\r\n            # check to see if it's the current node\r\n            if($DataSourceName -eq $Node.Name)\r\n            {\r\n                # add\r\n                $DataSourceNames += $Node.DataSourceReference\r\n            }\r\n        }\r\n        else\r\n        {\r\n            # store the name\r\n            $DataSourceNames += $Node.DataSourceReference\r\n        }\r\n    }\r\n\r\n    # return the results\r\n    return ,$DataSourceNames # Apparently using the , in front of the variable is how you return explicit arrays in PowerShell ... could you be more obsure?\r\n}\r\n#endregion\r\n\r\n#region Get-ItemDataSourceReferenceNames\r\nFunction Get-ItemDataSourceReferenceNames\r\n{\r\n    # Parameters\r\n    Param ($ItemFile)\r\n\r\n    # declare working variables\r\n    $DataSourceNames = @()\r\n    \r\n    # load the xml\r\n    [xml]$Xml = Get-Content $ItemFile\r\n\r\n    # retrieve the datasource nodes\r\n    $DataSourceReferenceNodes = $Xml.GetElementsByTagName(\"DataSourceReference\")\r\n\r\n    # loop through returned results\r\n    foreach($Node in $DataSourceReferenceNodes)\r\n    {\r\n        # get the data\r\n        $DataSourceNames += $Node.InnerText\r\n    }\r\n\r\n    # return the results\r\n    return ,$DataSourceNames # Apparently using the , in front of the variable is how you return explicit arrays in PowerShell ... could you be more obsure?\r\n}\r\n#endregion\r\n\r\n#region Get-DataSetSharedReferenceName\r\nFunction Get-DataSetSharedReferenceName\r\n{\r\n    # parameters\r\n    param($ReportFile, $DataSetName)\r\n\r\n    # load the xml\r\n    [xml]$ReportXml = Get-Content $ReportFile\r\n\r\n    # Get the DataSet nodes\r\n    $DataSetNode = $ReportXml.GetElementsByTagName(\"DataSet\") | Where-Object {$_.Name -eq $DataSetName}\r\n\r\n    # return the name\r\n    $DataSetNode.SharedDataSet.SharedDataSetReference\r\n}\r\n#endregion\r\n\r\n#region Item-Exists()\r\nFunction Item-Exists($ItemFolderPath, $ItemName)\r\n{\r\n    # declare search condition\r\n    $SearchCondition = New-Object \"$ReportServerProxyNamespace.SearchCondition\";\r\n\r\n    # fill in properties\r\n    $SearchCondition.Condition = Get-SpecificEnumValue -EnumNamespace \"$ReportServerProxyNamespace.ConditionEnum\" -EnumName \"Equals\"\r\n    $SearchCondition.ConditionSpecified = $true\r\n    $SearchCondition.Name = \"Name\"\r\n\r\n\tif ($IsReportService2005) {\r\n\t\t$SearchCondition.Value = $ItemName\r\n\t\t# search\r\n\t    $items = $ReportServerProxy.FindItems($ItemFolderPath, (Get-SpecificEnumValue -EnumNamespace \"$ReportServerProxyNamespace.BooleanOperatorEnum\" -EnumName \"And\"), $SearchCondition)\r\n\t}\r\n\telseif ($IsReportService2010) {\r\n\t\t$SearchCondition.Values = @($ItemName)\r\n\t\t# search\r\n\t    $items = $ReportServerProxy.FindItems($ItemFolderPath, (Get-SpecificEnumValue -EnumNamespace \"$ReportServerProxyNamespace.BooleanOperatorEnum\" -EnumName \"And\"), $null, $SearchCondition)\r\n\t}\r\n\telse { Write-Warning 'Report Service Unknown in Item-Exists method. Use ReportService2005 or ReportService2010.' }    \r\n\r\n    # check to see if anything was returned\r\n    if($items.Length -gt 0)\r\n    {\r\n        # loop through returned items\r\n        foreach($item in $items)\r\n        {\r\n            # check the path\r\n            if($item.Path -eq \"$ItemFolderPath/$ItemName\")\r\n            {\r\n                # return true\r\n                return $true\r\n            }\r\n            else\r\n            {\r\n                # warn\r\n                Write-Warning \"Unexpected path for $($item.Name); path is $($item.Path) exepected $ItemFolderPath/$ItemName\"\r\n            }\r\n        }\r\n\r\n        # items were found, but the path doesn't match\r\n        \r\n        return $false\r\n    }\r\n    else\r\n    {\r\n        return $false\r\n    }\r\n}\r\n#endregion\r\n\r\n#region Set-ItemDataSources()\r\nFunction Set-ItemDataSources\r\n{\r\n    # parameters\r\n    Param($ItemFile, $ItemFolder)\r\n\r\n    # declare local variables\r\n    $ItemName = $ItemFile.SubString($ItemFile.LastIndexOf(\"\\\") + 1)\r\n    $ItemName = $ItemName.SubString(0, $ItemName.IndexOf(\".\"))\r\n    $AllDataSourcesFound = $true\r\n    \r\n    # get the datasources\r\n    $DataSources = $ReportServerProxy.GetItemDataSources([string]::Format(\"{0}/{1}\", $ItemFolder, $ItemName))\r\n\r\n    #loop through retrieved datasources\r\n    foreach($DataSource in $DataSources)\r\n    {\r\n        # check to see if it's a dataset\r\n        if([System.IO.Path]::GetExtension($ItemFile).ToLower() -eq \".rsd\")\r\n        {\r\n            # datasets can have one and only one datasource\r\n            # The method GetItemDataSources does not return the name of the datasource for datasets like it does for reports\r\n            # instead, it alaways returns DataSetDataSource.  This made the call to Get-ItemDataSourceNames necessary,\r\n            # otherwise it would not link correctly\r\n            $DataSourceName = (Get-ItemDataSourceReferenceNames -ItemFile $ItemFile)[0]\r\n        }\r\n        else\r\n        {\r\n            # get the anme from teh source itself\r\n            $DataSourceName = (Get-ItemDataSourceNames -ItemFile $ItemFile -DataSourceName $DataSource.Name)[0]\r\n        }        \r\n        \r\n        # check to make sure the datasource exists in the location specified\r\n        if((Item-Exists -ItemFolderPath $ReportDatasourceFolder -ItemName $DataSourceName) -eq $true)\r\n        {\r\n            # create datasource reference variable\r\n            $DataSourceReference = New-Object \"$ReportServerProxyNamespace.DataSourceReference\";\r\n\r\n            # assign\r\n            $DataSourceReference.Reference = \"$ReportDatasourceFolder/\" + $DataSourceName\r\n            $DataSource.Item = $DataSourceReference            \r\n        }\r\n        else\r\n        {\r\n            # display warning\r\n            Write-Warning \"Unable to find datasource $($DataSourceName) in $ReportDataSourceFolder\"\r\n\r\n            # update to false\r\n            $AllDataSourcesFound = $false\r\n        }        \r\n    }\r\n\r\n    # check to see if found all datasources\r\n    if($AllDataSourcesFound -eq $true)\r\n    {\r\n        Write-Host \"Linking datasources to $ItemFolder/$ItemName\"\r\n        \r\n        # save the references\r\n        $ReportServerProxy.SetItemDataSources(\"$ItemFolder/$ItemName\", $DataSources)\r\n    }\r\n}\r\n#endregion\r\n\r\n#region Set-ReportDataSets()\r\nFunction Set-ReportDataSets\r\n{\r\n    # parameters\r\n    param($ReportFile)\r\n\r\n    # declare local variables\r\n    $ReportName = $ReportFile.SubString($ReportFile.LastIndexOf(\"\\\") + 1)\r\n    $ReportName = $ReportName.SubString(0, $ReportName.IndexOf(\".\"))\r\n    $AllDataSetsFound = $true\r\n\r\n    # get the datasources\r\n    $DataSets = $ReportServerProxy.GetItemReferences([string]::Format(\"{0}/{1}\", $ReportFolder, $ReportName), \"DataSet\")\r\n\r\n    # loop through returned values\r\n    foreach($DataSet in $DataSets)\r\n    {\r\n        # get the name of the shared data set reference\r\n        $SharedDataSetReferenceName = Get-DataSetSharedReferenceName -ReportFile $ReportFile -DataSetName $DataSet.Name\r\n        \r\n        # check to make sure the datasource exists in the location specified\r\n        if((Item-Exists -ItemFolderPath $ReportDataSetFolder -ItemName $SharedDataSetReferenceName) -eq $true)\r\n        {\r\n            # create datasource reference variable\r\n            $DataSetReference = New-Object \"$ReportServerProxyNamespace.ItemReference\";\r\n\r\n            # assign\r\n            $DataSetReference.Reference = \"$ReportDataSetFolder/\" + $SharedDataSetReferenceName\r\n            $DataSetReference.Name = $DataSet.Name\r\n\r\n            # log\r\n            Write-Host \"Linking Shared Data Set $($DataSet.Name) to $ReportName\"\r\n            \r\n            # update reference\r\n            $ReportServerProxy.SetItemReferences(\"$ReportFolder/$ReportName\", @($DataSetReference))\r\n        }\r\n        else\r\n        {\r\n            # get the datasource name to include in warning message -- I know there must be a way to use the property in a string literal, but I wasn't able to figure it out while trying\r\n            # to solve a reported bug so I took the easy way.\r\n            $DataSetName = $DataSet.Name\r\n            \r\n            # display warning\r\n            Write-Warning \"Unable to find dataset $DataSetName in $ReportDataSetFolder\"\r\n\r\n            # update to false\r\n            $AllDataSetsFound = $false\r\n        }            \r\n    }\r\n\r\n    # check to see if all datsets were found\r\n    if($AllDataSetsFound -eq $False)\r\n    {\r\n        Write-Warning \"Not all datasets found\"\r\n\r\n        # save the references\r\n        #$ReportServerProxy.SetItemReferences(\"$ReportFolder/$ReportName\", @($DataSets))\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Get-ObjectNamespace()\r\nFunction Get-ObjectNamespace($Object)\r\n{\r\n    # return the value\r\n    ($Object).GetType().ToString().SubString(0, ($Object).GetType().ToString().LastIndexOf(\".\"))\r\n}\r\n#endregion\r\n\r\n#region Get-SpecificEnumValue()\r\nFunction Get-SpecificEnumValue($EnumNamespace, $EnumName)\r\n{\r\n    # get the enum values\r\n    $EnumValues = [Enum]::GetValues($EnumNamespace)\r\n\r\n    # Loop through to find the specific value\r\n    foreach($EnumValue in $EnumValues)\r\n    {\r\n        # check current\r\n        if($EnumValue -eq $EnumName)\r\n        {\r\n            # return it\r\n            return $EnumValue\r\n        }\r\n    }\r\n\r\n    # nothing was found\r\n    return $null\r\n}\r\n#endregion\r\n\r\n#region Update-ReportParamters()\r\nFunction Update-ReportParameters($ReportFile)\r\n{\r\n    # declare local variables\r\n    $ReportParameters = @();\r\n\r\n    # necessary so that when attempting to use the report execution service, it doesn't puke on you when it can't find the data source\r\n    $ReportData = (Remove-SharedReferences -ReportFile $ReportFile)\r\n\r\n    # get just the report name\r\n    $ReportName = $ReportFile.SubString($ReportFile.LastIndexOf(\"\\\") + 1)\r\n    $ReportName = $ReportName.SubString(0, $ReportName.IndexOf(\".\"))\r\n    \r\n    # create warnings object\r\n    $ReportExecutionWarnings = $null\r\n\r\n    # load the report definition\r\n    $ExecutionInfo = $ReportExecutionProxy.LoadReportDefinition($ReportData, [ref] $ReportExecutionWarnings);\r\n\r\n    # loop through the report execution parameters\r\n    foreach($Parameter in $ExecutionInfo.Parameters)\r\n    {\r\n        # create new item parameter object\r\n        $ItemParameter = New-Object \"$ReportServerProxyNamespace.ItemParameter\";\r\n\r\n        # fill in the properties except valid values, that one needs special processing\r\n        Copy-ObjectProperties -SourceObject $Parameter -TargetObject $ItemParameter;\r\n\r\n        # fill in the valid values\r\n        $ItemParameter.ValidValues = Convert-ValidValues -SourceValidValues $Parameter.ValidValues;\r\n\r\n        # add to list\r\n        $ReportParameters += $ItemParameter;\r\n    }\r\n\r\n    # force the parameters to update\r\n    Write-Host \"Updating report parameters for $ReportFolder/$ReportName\"\r\n\tif ($IsReportService2005) {\r\n\t\t$ReportServerProxy.SetReportParameters(\"$ReportFolder/$ReportName\", $ReportParameters);\r\n\t}\r\n\telseif ($IsReportService2010) {\r\n\t\t$ReportServerProxy.SetItemParameters(\"$ReportFolder/$ReportName\", $ReportParameters);\r\n\t}\r\n\telse { Write-Warning 'Report Service Unknown in Update-ReportParameters method. Use ReportService2005 or ReportService2010.' }\r\n}\r\n#endregion\r\n\r\n#region Remove-ShareReferences()\r\nFunction Remove-SharedReferences($ReportFile)\r\n{\r\n    ######################################################################################################\r\n    #You'll notice that I've used the keywrod of [void] in front of some of these method calls, this is so\r\n    #that the operation isn't captured as output of the function\r\n    ######################################################################################################\r\n\r\n    # read xml\r\n    [xml]$ReportXml = Get-Content $ReportFile;\r\n    \r\n    # create new memory stream object\r\n    $MemoryStream = New-Object System.IO.MemoryStream\r\n\r\n    try\r\n    {\r\n\r\n        # declare array of nodes to remove\r\n        $NodesToRemove = @();\r\n\r\n        # get datasource names\r\n        $DataSourceNames = Get-ItemDataSourceNames -ItemFile $ReportFile\r\n\r\n        # check to see if report has datasourcenames\r\n        if($DataSourceNames.Count -eq 0)\r\n        {\r\n            # Get reference to reportnode\r\n            $ReportNode = $ReportXml.FirstChild.NextSibling # Kind of a funky way of getting it, but the SelectSingleNode(\"//Report\") wasn't working due to Namespaces in the node\r\n\r\n            # create new DataSources node\r\n            $DataSourcesNode = $ReportXml.CreateNode($ReportNode.NodeType, \"DataSources\", $null)\r\n\r\n            # create new datasource node\r\n            $DataSourceNode = $ReportXml.CreateNode($ReportNode.NodeType, \"DataSource\", $null)\r\n\r\n            # create new datasourcereference node\r\n            $DataSourceReferenceNode = $ReportXml.CreateNode($ReportNode.NodeType, \"DataSourceReference\", $null)\r\n\r\n            # create new attribute\r\n            $DataSourceNameAttribute = $ReportXml.CreateAttribute(\"Name\")\r\n            $DataSourceNameAttribute.Value = \"DataSource1\"\r\n            $dataSourceReferenceNode.InnerText = \"DataSource1\"\r\n\r\n            # add attribute to datasource node\r\n            [void]$DataSourceNode.Attributes.Append($DataSourceNameAttribute)\r\n            [void]$DataSourceNode.AppendChild($DataSourceReferenceNode)\r\n\r\n            # add nodes\r\n            [void]$ReportNode.AppendChild($DataSourcesNode)\r\n            [void]$DataSourcesNode.AppendChild($DataSourceNode)\r\n\r\n            # add fake datasource name to array\r\n            $DataSourceNames += \"DataSource1\"\r\n        }\r\n\r\n        # get all datasource nodes\r\n        $DatasourceNodes = $ReportXml.GetElementsByTagName(\"DataSourceReference\");\r\n\r\n        # loop through returned nodes\r\n        foreach($DataSourceNode in $DatasourceNodes)\r\n        {\r\n            # create a new connection properties node\r\n            $ConnectionProperties = $ReportXml.CreateNode($DataSourceNode.NodeType, \"ConnectionProperties\", $null);\r\n\r\n            # create a new dataprovider node\r\n            $DataProvider = $ReportXml.CreateNode($DataSourceNode.NodeType, \"DataProvider\", $null);\r\n            $DataProvider.InnerText = \"SQL\";\r\n\r\n            # create new connection string node\r\n            $ConnectString = $ReportXml.CreateNode($DataSourceNode.NodeType, \"ConnectString\", $null);\r\n            $ConnectString.InnerText = \"Data Source=Server Name Here;Initial Catalog=database name here\";\r\n\r\n            # add new node to parent node\r\n            [void] $DataSourceNode.ParentNode.AppendChild($ConnectionProperties);\r\n\r\n            # append childeren\r\n            [void] $ConnectionProperties.AppendChild($DataProvider);\r\n            [void] $ConnectionProperties.AppendChild($ConnectString);\r\n\r\n            # Add to remove list \r\n            $NodesToRemove += $DataSourceNode;\r\n        }\r\n\r\n        # get all shareddataset nodes\r\n        $SharedDataSetNodes = $ReportXml.GetElementsByTagName(\"SharedDataSet\")\r\n\r\n        #loop through the returned nodes\r\n        foreach($SharedDataSetNode in $SharedDataSetNodes)\r\n        {\r\n            # create holder nodes so it won't error\r\n            $QueryNode = $ReportXml.CreateNode($SharedDataSetNode.NodeType, \"Query\", $null);\r\n            $DataSourceNameNode = $ReportXml.CreateNode($QueryNode.NodeType, \"DataSourceName\", $null);\r\n            $CommandTextNode = $ReportXml.CreateNode($QueryNode.NodeType, \"CommandText\", $null);\r\n\r\n            # add valid datasource name, just get the first in the list\r\n            $DataSourceNameNode.InnerText = $DataSourceNames[0]\r\n            \r\n            # add node to parent\r\n            [void] $SharedDataSetNode.ParentNode.Appendchild($QueryNode)\r\n            \r\n            # add datasourcename and commandtext to query node\r\n            [void]$QueryNode.AppendChild($DataSourceNameNode)\r\n            [void]$QueryNode.AppendChild($CommandTextNode)\r\n\r\n            # add node to removelist\r\n            $NodesToRemove += $SharedDataSetNode\r\n        }\r\n\r\n\r\n        # loop through nodes to remove\r\n        foreach($Node in $NodesToRemove)\r\n        {\r\n            # remove from parent\r\n            [void] $Node.ParentNode.RemoveChild($Node);\r\n        }\r\n    \r\n        $ReportXml.InnerXml = $ReportXml.InnerXml.Replace(\"xmlns=`\"`\"\", \"\")\r\n\r\n        # save altered xml to memory stream\r\n        $ReportXml.Save($MemoryStream);\r\n\r\n        # return the altered xml as byte array\r\n        return $MemoryStream.ToArray();\r\n    }\r\n    finally\r\n    {\r\n        # close and dispose\r\n        $MemoryStream.Close();\r\n        $MemoryStream.Dispose();\r\n    }\r\n}\r\n#endregion\r\n\r\n#region Copy-ObjectProperties()\r\nFunction Copy-ObjectProperties($SourceObject, $TargetObject)\r\n{\r\n    # Get source object property array\r\n    $SourcePropertyCollection = $SourceObject.GetType().GetProperties();\r\n\r\n    # get the destination\r\n    $TargetPropertyCollection = $TargetObject.GetType().GetProperties();\r\n\r\n    # loop through source property collection\r\n    for($i = 0; $i -lt $SourcePropertyCollection.Length; $i++)\r\n    {\r\n        # get the target property\r\n        $TargetProperty = $TargetPropertyCollection | Where {$_.Name -eq $SourcePropertyCollection[$i].Name}\r\n        \r\n        # check to see if it's null\r\n        if($TargetProperty -ne $null)\r\n        {\r\n            # check to see if it's the valid values property\r\n            if($TargetProperty.Name -ne \"ValidValues\")\r\n            {\r\n                 # set the value\r\n                $TargetProperty.SetValue($TargetObject, $SourcePropertyCollection[$i].GetValue($SourceObject));\r\n            }\r\n        }\r\n    }\r\n}\r\n#endregion\r\n\r\n#region ConvertValidValues()\r\nFunction Convert-ValidValues($SourceValidValues)\r\n{\r\n    # declare local values\r\n    $TargetValidValues = @();\r\n    \r\n    # loop through source values\r\n    foreach($SourceValidValue in $SourceValidValues)\r\n    {\r\n        # create target valid value object\r\n        $TargetValidValue = New-Object \"$ReportServerProxyNamespace.ValidValue\";\r\n\r\n        # copy properties\r\n        Copy-ObjectProperties -SourceObject $SourceValidValue -TargetObject $TargetValidValue\r\n\r\n        # add to list\r\n        $TargetValidValues += $TargetValidValue\r\n    }\r\n\r\n    # return the values\r\n    return ,$TargetValidValues\r\n}\r\n#endregion\r\n\r\n#region Backup-ExistingItem()\r\nFunction Backup-ExistingItem\r\n{\r\n    # parameters\r\n    Param($ItemFile, $ItemFolder)\r\n\r\n    # declare local variables\r\n    $ItemName = $ItemFile.SubString($ItemFile.LastIndexOf(\"\\\") + 1)\r\n    $ItemName = $ItemName.SubString(0, $ItemName.IndexOf(\".\"))\r\n\r\n    # check to see if the item exists\r\n    if((Item-Exists -ItemFolderPath $ItemFolder -ItemName $ItemName) -eq $true)\r\n    {\r\n        # get file extension\r\n        $FileExtension = [System.IO.Path]::GetExtension($ItemFile)\r\n    \r\n        # check backuplocation\r\n        if($BackupLocation.EndsWith(\"\\\") -ne $true)\r\n        {\r\n            # append ending slash\r\n            $BackupLocation = $BackupLocation + \"\\\"\r\n        }\r\n\t\t\r\n\t\t# add the release number to the backup location\r\n\t\t$BackupLocation = $BackupLocation + $ReleaseNumber + \"\\\"\r\n\r\n        # ensure the backup location actually exists\r\n        if((Test-Path $BackupLocation) -ne $true)\r\n        {\r\n            # create it\r\n            New-Item -ItemType Directory -Path $BackupLocation\r\n        }\r\n\r\n        # download the item\r\n        $Item = $ReportServerProxy.GetItemDefinition(\"$ItemFolder/$ItemName\")\r\n\r\n        # form the backup path\r\n        $BackupPath = \"{0}{1}{2}\" -f $BackupLocation, $ItemName, $FileExtension;\r\n\r\n        # write to disk\r\n        [System.IO.File]::WriteAllBytes(\"$BackupPath\", $Item);\r\n\r\n        # write to screen\r\n        Write-Host \"Backed up $ItemFolder/$ItemName to $BackupPath\";\r\n    }\r\n}\r\n#endregion\r\n\r\n#region Normalize-SSRSFolder()\r\nfunction Normalize-SSRSFolder ([string]$Folder) {\r\n    if (-not $Folder.StartsWith('/')) {\r\n        $Folder = '/' + $Folder\r\n    }\r\n    \r\n    return $Folder\r\n}\r\n#endregion\r\n\r\n#region New-SSRSFolder()\r\nfunction New-SSRSFolder ([string] $Name) {\r\n    Write-Verbose \"New-SSRSFolder -Name $Name\"\r\n \r\n    $Name = Normalize-SSRSFolder -Folder $Name\r\n \r\n    if ($ReportServerProxy.GetItemType($Name) -ne 'Folder') {\r\n        $Parts = $Name -split '/'\r\n        $Leaf = $Parts[-1]\r\n        $Parent = $Parts[0..($Parts.Length-2)] -join '/'\r\n \r\n        if ($Parent) {\r\n            New-SSRSFolder -Name $Parent\r\n        } else {\r\n            $Parent = '/'\r\n        }\r\n        \r\n        $ReportServerProxy.CreateFolder($Leaf, $Parent, $null)\r\n    }\r\n}\r\n#endregion\r\n\r\n#region New-SSRSDataSource()\r\nfunction New-SSRSDataSource ([string]$RdsPath, [string]$Folder, [bool]$OverwriteDataSources) {\r\n    Write-Verbose \"New-SSRSDataSource -RdsPath $RdsPath -Folder $Folder\"\r\n\r\n    $Folder = Normalize-SSRSFolder -Folder $Folder\r\n    \r\n    [xml]$Rds = Get-Content -Path $RdsPath\r\n    $dsName = $Rds.RptDataSource.Name\r\n    $ConnProps = $Rds.RptDataSource.ConnectionProperties\r\n    \r\n\t$type = $ReportServerProxy.GetType().Namespace #Get proxy type\r\n\t$DSDdatatype = ($type + '.DataSourceDefinition')\r\n\t \r\n\t$Definition = new-object ($DSDdatatype)\r\n\tif($Definition -eq $null){\r\n\t Write-Error Failed to create data source definition object\r\n\t}\r\n\t\r\n\t$dsConnectionString = $($OctopusParameters[\"$($dsName).ConnectionString\"])\r\n\t\r\n\t# replace the connection string variable that is configured in the octopus project\r\n\tif ($dsConnectionString) {\r\n\t    $Definition.ConnectString = $dsConnectionString\r\n\t} else {\r\n\t    $Definition.ConnectString = $ConnProps.ConnectString\r\n\t}\r\n\t\r\n    $Definition.Extension = $ConnProps.Extension \r\n\r\n\tif ([Convert]::ToBoolean($ConnProps.IntegratedSecurity)) {\r\n\t\t$Definition.CredentialRetrieval = 'Integrated'\r\n\t}\r\n\telse {\r\n\t\t$Definition.CredentialRetrieval = 'Store'\r\n\t\t\r\n\t\t$dsUsername = $($OctopusParameters[\"$($dsName).Username\"])\r\n\t\tWrite-Host \"$($dsName).Username = '$dsUsername'\"\r\n\t\t\r\n\t\t$dsPassword = $($OctopusParameters[\"$($dsName).Password\"])\r\n\t\tWrite-Host \"$($dsName).Password = '$dsPassword'\"\r\n\t\t\r\n\t\t$Definition.UserName = $dsUsername;\r\n        $Definition.Password = $dsPassword;\r\n\t}\r\n\r\n    $DataSource = New-Object -TypeName PSObject -Property @{\r\n        Name = $Rds.RptDataSource.Name\r\n        Path =  $Folder + '/' + $Rds.RptDataSource.Name\r\n    }\r\n    \r\n    if ($OverwriteDataSources -or $ReportServerProxy.GetItemType($DataSource.Path) -eq 'Unknown') {\r\n        Write-Host \"Overwriting datasource $($DataSource.Name)\"\r\n        $ReportServerProxy.CreateDataSource($DataSource.Name, $Folder, $OverwriteDataSources, $Definition, $null)\r\n    }\r\n    \r\n    return $DataSource \r\n}\r\n#endregion\r\n\r\n#region Main\r\n\r\ntry\r\n{\r\n    # declare array for reports\r\n    $ReportFiles = @()\r\n\t$ReportDataSourceFiles = @()\r\n    $ReportDataSetFiles = @()\r\n\t\r\n\t$IsReportService2005 = $false\r\n\t$IsReportService2010 = $false\r\n\t\r\n\tif ($ReportServiceUrl.ToLower().Contains('reportservice2005.asmx')) {\r\n\t\t$IsReportService2005 = $true\r\n\t\tWrite-Host \"2005 Report Service found.\"\r\n\t}\r\n\telseif ($ReportServiceUrl.ToLower().Contains('reportservice2010.asmx')) {\r\n\t\t$IsReportService2010 = $true\r\n\t\tWrite-Host \"2010 Report Service found.\"\r\n\t}\r\n\t\r\n\tWrite-Host \"Deploy Path: $DeployedPath\"\r\n\t\r\n    # get all report files for deployment\r\n    Write-Host \"Getting all .rdl files\"\r\n    Get-ChildItem $DeployedPath -Recurse -Filter \"*.rdl\" | ForEach-Object { If(($ReportFiles -contains $_.FullName) -eq $false) {$ReportFiles += $_.FullName}}\r\n    Write-Host \"# of rdl files found: $($ReportFiles.Count)\"\r\n\r\n    # get all report datasource files for deployment\r\n    Write-Host \"Getting all .rds files\"\r\n    Get-ChildItem $DeployedPath -Recurse -Filter \"*.rds\" | ForEach-Object { If(($ReportDataSourceFiles -contains $_.FullName) -eq $false) {$ReportDataSourceFiles += $_.FullName}}\r\n    Write-Host \"# of rds files found: $($ReportDataSourceFiles.Count)\"\r\n\r\n    # get all report datset files for deployment\r\n    Write-Host \"Getting all .rsd files\"\r\n    Get-ChildItem $DeployedPath -Recurse -Filter \"*.rsd\" | ForEach-Object { If(($ReportDataSetFiles -contains $_.FullName) -eq $false) {$ReportDataSetFiles += $_.FullName}}\r\n    Write-Host \"# of rsd files found: $($ReportDataSetFiles.Count)\"\r\n\r\n\r\n    # set the report proxies\r\n    Write-Host \"Creating SSRS Web Service proxies\"\r\n\r\n    # check to see if credentials were supplied for the services\r\n    if(([string]::IsNullOrEmpty($ServiceUserDomain) -ne $true) -and ([string]::IsNullOrEmpty($ServiceUserName) -ne $true) -and ([string]::IsNullOrEmpty($ServicePassword) -ne $true))\r\n    {\r\n        # secure the password\r\n        $secpasswd = ConvertTo-SecureString \"$ServicePassword\" -AsPlainText -Force\r\n\r\n        # create credential object\r\n        $ServiceCredential = New-Object System.Management.Automation.PSCredential (\"$ServiceUserDomain\\$ServiceUserName\", $secpasswd)\r\n\r\n        # create proxies\r\n        $ReportServerProxy = New-WebServiceProxy -Uri $ReportServiceUrl -Credential $ServiceCredential\r\n        $ReportExecutionProxy = New-WebServiceProxy -Uri $ReportExecutionUrl -Credential $ServiceCredential\r\n    }\r\n    else\r\n    {\r\n        # create proxies using current identity\r\n        $ReportServerProxy = New-WebServiceProxy -Uri $ReportServiceUrl -UseDefaultCredential \r\n        $ReportExecutionProxy = New-WebServiceProxy -Uri $ReportExecutionUrl -UseDefaultCredential \r\n    }\r\n\r\n\r\n\r\n\t#Create folder information for DataSource and Report\r\n\tNew-SSRSFolder -Name $ReportFolder\r\n\tNew-SSRSFolder -Name $ReportDatasourceFolder\r\n    New-SSRSFolder -Name $ReportDataSetFolder\r\n\t \r\n\t#Create DataSource\r\n    foreach($RDSFile in $ReportDataSourceFiles) {\r\n        Write-Host \"New-SSRSDataSource $RdsFile\"\r\n        \r\n\t\t$DataSource = New-SSRSDataSource -RdsPath $RdsFile -Folder $ReportDatasourceFolder -Overwrite ([System.Convert]::ToBoolean(\"$OverwriteDataSources\"))\r\n\t}\r\n\r\n    # get the service proxy namespaces - this is necessary because of a bug documented here http://stackoverflow.com/questions/7921040/error-calling-reportingservice2005-finditems-specifically-concerning-the-bool and http://www.vistax64.com/powershell/273120-bug-when-using-namespace-parameter-new-webserviceproxy.html\r\n    $ReportServerProxyNamespace = Get-ObjectNamespace -Object $ReportServerProxy\r\n    $ReportExecutionProxyNamespace = Get-ObjectNamespace -Object $ReportExecutionProxy\r\n\r\n    # Create dat sets\r\n    foreach($DataSet in $ReportDataSetFiles)\r\n    {\r\n        # check to see if we need to back up\r\n        if($BackupLocation -ne $null -and $BackupLocation -ne \"\")\r\n        {\r\n            # backup the item\r\n            Backup-ExistingItem -ItemFile $DataSet -ItemFolder $ReportDataSetFolder\r\n        }\r\n\r\n        # upload the dataset\r\n        Upload-Item -Item $DataSet -ItemType \"DataSet\" -ItemFolder $ReportDataSetFolder\r\n\r\n        # update the dataset datasource\r\n        Set-ItemDataSources -ItemFile $DataSet -ItemFolder $ReportDataSetFolder\r\n    }\r\n\r\n    # get the proxy auto generated name spaces\r\n\r\n    # loop through array\r\n    foreach($ReportFile in $ReportFiles)\r\n    {\r\n        # check to see if we need to back up\r\n        if($BackupLocation -ne $null -and $BackupLocation -ne \"\")\r\n        {\r\n            # backup the item\r\n            Backup-ExistingItem -ItemFile $ReportFile -ItemFolder $ReportFolder\r\n        }\r\n        \r\n        # upload report\r\n        Upload-Item -Item $ReportFile -ItemType \"Report\" -ItemFolder $ReportFolder\r\n\r\n        # extract datasources\r\n        #Write-Host \"Extracting datasource names for $ReportFile\"\r\n        #$ReportDataSourceNames = Get-ReportDataSourceNames $ReportFile\r\n\r\n        # set the datasources\r\n        Set-ItemDataSources -ItemFile $ReportFile -ItemFolder $ReportFolder\r\n\r\n        # set the datasets\r\n        Set-ReportDataSets -ReportFile $ReportFile\r\n\r\n        # update the report parameters\r\n        Update-ReportParameters -ReportFile $ReportFile\r\n    }\r\n}\r\nfinally\r\n{\r\n    # check to see if the proxies are null\r\n    if($ReportServerProxy -ne $null)\r\n    {\r\n        # dispose\r\n        $ReportServerProxy.Dispose();\r\n    }\r\n\r\n    if($ReportExecutionProxy -ne $null)\r\n    {\r\n        # dispose\r\n        $ReportExecutionProxy.Dispose();\r\n    }\r\n}\r\n\r\n#endregion\r\n",
    "Octopus.Action.Script.Syntax": "PowerShell"
  },
  "SensitiveProperties": {},
  "Parameters": [
    {
      "Name": "NugetPackageStepName",
      "Label": "SSRS package step",
      "HelpText": "Select the step in this project which downloads the SSRS package.",
      "DefaultValue": null,
      "DisplaySettings": {
        "Octopus.ControlType": "StepName"
      }
    },
    {
      "Name": "ReportServiceUrl",
      "Label": "Url of SSRS Server service",
      "HelpText": "The complete Url to the SSRS server.\nExample: http://198.239.216.46/ReportServer_LOCALDEV/reportservice2010.asmx?wsdl",
      "DefaultValue": null,
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      }
    },
    {
      "Name": "ReportExecutionUrl",
      "Label": "Report Execution Url",
      "HelpText": "The complete Url to the Report Execution service.\nExample: http://198.239.216.46/ReportServer_LOCALDEV/ReportExecution2005.asmx?wsdl",
      "DefaultValue": null,
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      }
    },
    {
      "Name": "ReportFolder",
      "Label": "Report folder",
      "HelpText": "Relative Url to the folder in which the reports will be deployed.",
      "DefaultValue": null,
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      }
    },
    {
      "Name": "ReportDatasourceFolder",
      "Label": "Report data source folder",
      "HelpText": "Relative Url where the data sources for the reports are located, starting with '\\'",
      "DefaultValue": null,
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      }
    },
    {
      "Name": "OverwriteDataSources",
      "Label": "Overwrite datasource(s)",
      "HelpText": "Tick if the existing report data source file needs to e replaced.",
      "DefaultValue": "False",
      "DisplaySettings": {
        "Octopus.ControlType": "Checkbox"
      }
    },
    {
      "Name": "BackupLocation",
      "Label": "Backup Location",
      "HelpText": "Directory path to take a backup of existing reports (.rdl) and data source (.rds) files.",
      "DefaultValue": null,
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      }
    },
    {
      "Name": "ReportDataSetFolder",
      "Label": "DataSet folder",
      "HelpText": "Relative Url where Shared Data Sets are stored",
      "DefaultValue": null,
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      }
    },
    {
      "Name": "ServiceUserDomain",
      "Label": "Service Domain",
      "HelpText": "(Optional - leave blank to use Tentacle identity) Name of the domain for the user account to execute as",
      "DefaultValue": null,
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      }
    },
    {
      "Name": "ServiceUserName",
      "Label": "Service Username",
      "HelpText": "(Optional - leave blank to use Tentacle identity) Username of the user account to execute as",
      "DefaultValue": null,
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      }
    },
    {
      "Name": "ServicePassword",
      "Label": "Service Password",
      "HelpText": "(Optional - leave blank to use Tentacle identity) Password of the user account to execute as",
      "DefaultValue": null,
      "DisplaySettings": {
        "Octopus.ControlType": "Sensitive"
      }
    }
  ],
  "$Meta": {
    "ExportedAt": "2015-12-31T22:35:46.499Z",
    "OctopusVersion": "3.2.13",
    "Type": "ActionTemplate"
  }
}