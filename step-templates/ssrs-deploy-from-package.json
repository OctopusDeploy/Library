{
  "Id": "4e3a1163-e157-4675-a60c-4dc569d14348",
  "Name": "Deploy SSRS Reports from a package",
  "Description": "Uploads SSRS reports to an SSRS server from a NuGet package.",
  "ActionType": "Octopus.Script",
  "Version": 47,
  "CommunityActionTemplateId": null,
  "Properties": {
    "Octopus.Action.Script.ScriptBody": "$DeployedPath = $OctopusParameters[\"Octopus.Action[$NugetPackageStepName].Output.Package.InstallationDirectoryPath\"]\n$ReleaseNumber = $OctopusParameters[\"Octopus.Release.Number\"]\n\n\n#region Upload-Item\nFunction Upload-Item\n{\n    # parameters\n    param ([string] $Item, [string]$ItemType, [string] $ItemFolder)\n\n    Write-Host \"Loading data from $Item\"\n    $ItemData = [System.IO.File]::ReadAllBytes($Item)\n\n    # Create local variables\n    $Warnings = $null\n    $ItemName = $Item.SubString($Item.LastIndexOf(\"\\\") + 1)\n    $ItemName = $ItemName.SubString(0, $ItemName.IndexOf(\".\"))\n   \n\t# upload item\n    if ($IsReportService2005) {\n        if($ItemType -eq \"Report\")\n        {\n\t        [void]$ReportServerProxy.CreateReport($ItemName, $ItemFolder, $true, $ItemData, $null)\n        }\n        else\n        {\n            # error\n            Write-Error \"$ItemType is not supported in ReportService2005\"\n        }\n\t}\n\telseif ($IsReportService2010) {\n\t\t[void]$ReportServerProxy.CreateCatalogItem($ItemType, $ItemName, $ItemFolder, $true, $ItemData, $null, [ref] $Warnings);\n\t}\n\telse { Write-Warning 'Report Service Unknown in Upload-Item method. Use ReportService2005 or ReportService2010.' }\n}\n#endregion\n\n#region Get-ItemDataSourceNames()\nFunction Get-ItemDataSourceNames\n{\n    # Parameters\n    Param ($ItemFile, $DataSourceName)\n\n    # declare working variables\n    $DataSourceNames = @()\n    \n    # load the xml\n    [xml]$Xml = Get-Content $ItemFile\n\n    # retrieve the datasource nodes\n    $DataSourceReferenceNodes = $Xml.GetElementsByTagName(\"DataSource\")\n\n    # loop through returned results\n    foreach($Node in $DataSourceReferenceNodes)\n    {\n        # check to see if we're looking for a specific one\n        if($DataSourceName -ne $null)\n        {\n            # check to see if it's the current node\n            if($DataSourceName -eq $Node.Name)\n            {\n                # add\n                $DataSourceNames += $Node.DataSourceReference\n            }\n        }\n        else\n        {\n            # store the name\n            $DataSourceNames += $Node.DataSourceReference\n        }\n    }\n\n    # return the results\n    return ,$DataSourceNames # Apparently using the , in front of the variable is how you return explicit arrays in PowerShell ... could you be more obsure?\n}\n#endregion\n\n#region Get-ItemDataSources()\nFunction Get-ItemDataSources\n{\n    # Parameters\n    Param ($ItemFile)\n\n    # declare working variables\n    $DataSourceNames = @()\n    \n    # load the xml\n    [xml]$Xml = Get-Content $ItemFile\n\n    # retrieve the datasource nodes\n    $DataSourceReferenceNodes = $Xml.GetElementsByTagName(\"DataSource\")\n\n    # loop through returned results\n    foreach($Node in $DataSourceReferenceNodes)\n    {\n        # store the name\n        $DataSourceNames += $Node.Name\n    }\n\n    # return the results\n    return ,$DataSourceNames # Apparently using the , in front of the variable is how you return explicit arrays in PowerShell ... could you be more obsure?\n}\n#endregion\n\n#region Get-ItemDataSourceReferenceNames\nFunction Get-ItemDataSourceReferenceNames\n{\n    # Parameters\n    Param ($ItemFile)\n\n    # declare working variables\n    $DataSourceNames = @()\n    \n    # load the xml\n    [xml]$Xml = Get-Content $ItemFile\n\n    # retrieve the datasource nodes\n    $DataSourceReferenceNodes = $Xml.GetElementsByTagName(\"DataSourceReference\")\n\n    # loop through returned results\n    foreach($Node in $DataSourceReferenceNodes)\n    {\n        # get the data\n        $DataSourceNames += $Node.InnerText\n    }\n\n    # return the results\n    return ,$DataSourceNames # Apparently using the , in front of the variable is how you return explicit arrays in PowerShell ... could you be more obsure?\n}\n#endregion\n\n#region Get-DataSetSharedReferenceName\nFunction Get-DataSetSharedReferenceName\n{\n    # parameters\n    param($ReportFile, $DataSetName)\n\n    # load the xml\n    [xml]$ReportXml = Get-Content $ReportFile\n\n    # Get the DataSet nodes\n    $DataSetNode = $ReportXml.GetElementsByTagName(\"DataSet\") | Where-Object {$_.Name -eq $DataSetName}\n\n    # return the name\n    $DataSetNode.SharedDataSet.SharedDataSetReference\n}\n#endregion\n\n#region Item-Exists()\nFunction Item-Exists($ItemFolderPath, $ItemName)\n{\n    # declare search condition\n    $SearchCondition = New-Object \"$ReportServerProxyNamespace.SearchCondition\";\n\n    # fill in properties\n    $SearchCondition.Condition = Get-SpecificEnumValue -EnumNamespace \"$ReportServerProxyNamespace.ConditionEnum\" -EnumName \"Equals\"\n    $SearchCondition.ConditionSpecified = $true\n    $SearchCondition.Name = \"Name\"\n\n\tif ($IsReportService2005) {\n\t\t$SearchCondition.Value = $ItemName\n\t\t# search\n\t    $items = $ReportServerProxy.FindItems($ItemFolderPath, (Get-SpecificEnumValue -EnumNamespace \"$ReportServerProxyNamespace.BooleanOperatorEnum\" -EnumName \"And\"), $SearchCondition)\n\t}\n\telseif ($IsReportService2010) {\n\t\t$SearchCondition.Values = @($ItemName)\n\t\t# search\n\t    $items = $ReportServerProxy.FindItems($ItemFolderPath, (Get-SpecificEnumValue -EnumNamespace \"$ReportServerProxyNamespace.BooleanOperatorEnum\" -EnumName \"And\"), $null, $SearchCondition)\n\t}\n\telse { Write-Warning 'Report Service Unknown in Item-Exists method. Use ReportService2005 or ReportService2010.' }    \n\n    # check to see if anything was returned\n    if($items.Length -gt 0)\n    {\n        # loop through returned items\n        foreach($item in $items)\n        {\n            # check the path\n            if($item.Path -eq \"$ItemFolderPath/$ItemName\")\n            {\n                # return true\n                return $true\n            }\n            else\n            {\n                # warn\n                Write-Warning \"Unexpected path for $($item.Name); path is $($item.Path) exepected $ItemFolderPath/$ItemName\"\n            }\n        }\n\n        # items were found, but the path doesn't match\n        \n        return $false\n    }\n    else\n    {\n        return $false\n    }\n}\n#endregion\n\n#region Set-ItemDataSources()\nFunction Set-ItemDataSources\n{\n    # parameters\n    Param($ItemFile, $ItemFolder)\n\n    # declare local variables\n    $ItemName = $ItemFile.SubString($ItemFile.LastIndexOf(\"\\\") + 1)\n    $ItemName = $ItemName.SubString(0, $ItemName.IndexOf(\".\"))\n    $AllDataSourcesFound = $true\n    \n    # get the datasources\n    $DataSources = $ReportServerProxy.GetItemDataSources([string]::Format(\"{0}/{1}\", $ItemFolder, $ItemName))\n\n    #loop through retrieved datasources\n    foreach($DataSource in $DataSources)\n    {\n        # check to see if it's a dataset\n        if([System.IO.Path]::GetExtension($ItemFile).ToLower() -eq \".rsd\")\n        {\n            # datasets can have one and only one datasource\n            # The method GetItemDataSources does not return the name of the datasource for datasets like it does for reports\n            # instead, it alaways returns DataSetDataSource.  This made the call to Get-ItemDataSourceNames necessary,\n            # otherwise it would not link correctly\n            $DataSourceName = (Get-ItemDataSourceReferenceNames -ItemFile $ItemFile)[0]\n        }\n        else\n        {\n            # get the anme from teh source itself\n            $DataSourceName = (Get-ItemDataSourceNames -ItemFile $ItemFile -DataSourceName $DataSource.Name)[0]\n        }        \n        \n        # check to make sure the datasource exists in the location specified\n        if((Item-Exists -ItemFolderPath $ReportDatasourceFolder -ItemName $DataSourceName) -eq $true)\n        {\n            # create datasource reference variable\n            $DataSourceReference = New-Object \"$ReportServerProxyNamespace.DataSourceReference\";\n\n            # assign\n            $DataSourceReference.Reference = \"$ReportDatasourceFolder/\" + $DataSourceName\n            $DataSource.Item = $DataSourceReference            \n        }\n        else\n        {\n            # display warning\n            Write-Warning \"Unable to find datasource $($DataSourceName) in $ReportDataSourceFolder\"\n\n            # update to false\n            $AllDataSourcesFound = $false\n        }        \n    }\n\n    # check to see if found all datasources\n    if($AllDataSourcesFound -eq $true)\n    {\n        Write-Host \"Linking datasources to $ItemFolder/$ItemName\"\n        \n        # save the references\n        $ReportServerProxy.SetItemDataSources(\"$ItemFolder/$ItemName\", $DataSources)\n    }\n}\n#endregion\n\n#region Set-ReportDataSets()\nFunction Set-ReportDataSets\n{\n    # parameters\n    param($ReportFile)\n\n    # declare local variables\n    $ReportName = $ReportFile.SubString($ReportFile.LastIndexOf(\"\\\") + 1)\n    $ReportName = $ReportName.SubString(0, $ReportName.IndexOf(\".\"))\n    $AllDataSetsFound = $true\n\n    # get the datasources\n    $DataSets = $ReportServerProxy.GetItemReferences([string]::Format(\"{0}/{1}\", $ReportFolder, $ReportName), \"DataSet\")\n\n    # loop through returned values\n    foreach($DataSet in $DataSets)\n    {\n        # get the name of the shared data set reference\n        $SharedDataSetReferenceName = Get-DataSetSharedReferenceName -ReportFile $ReportFile -DataSetName $DataSet.Name\n        \n        # check to make sure the datasource exists in the location specified\n        if((Item-Exists -ItemFolderPath $ReportDataSetFolder -ItemName $SharedDataSetReferenceName) -eq $true)\n        {\n            # create datasource reference variable\n            $DataSetReference = New-Object \"$ReportServerProxyNamespace.ItemReference\";\n\n            # assign\n            $DataSetReference.Reference = \"$ReportDataSetFolder/\" + $SharedDataSetReferenceName\n            $DataSetReference.Name = $DataSet.Name\n\n            # log\n            Write-Host \"Linking Shared Data Set $($DataSet.Name) to $ReportName\"\n            \n            # update reference\n            $ReportServerProxy.SetItemReferences(\"$ReportFolder/$ReportName\", @($DataSetReference))\n        }\n        else\n        {\n            # get the datasource name to include in warning message -- I know there must be a way to use the property in a string literal, but I wasn't able to figure it out while trying\n            # to solve a reported bug so I took the easy way.\n            $DataSetName = $DataSet.Name\n            \n            # display warning\n            Write-Warning \"Unable to find dataset $DataSetName in $ReportDataSetFolder\"\n\n            # update to false\n            $AllDataSetsFound = $false\n        }            \n    }\n\n    # check to see if all datsets were found\n    if($AllDataSetsFound -eq $False)\n    {\n        Write-Warning \"Not all datasets found\"\n\n        # save the references\n        #$ReportServerProxy.SetItemReferences(\"$ReportFolder/$ReportName\", @($DataSets))\n    }\n}\n\n#endregion\n\n#region Get-ObjectNamespace()\nFunction Get-ObjectNamespace($Object)\n{\n    # return the value\n    ($Object).GetType().ToString().SubString(0, ($Object).GetType().ToString().LastIndexOf(\".\"))\n}\n#endregion\n\n#region Get-SpecificEnumValue()\nFunction Get-SpecificEnumValue($EnumNamespace, $EnumName)\n{\n    # get the enum values\n    $EnumValues = [Enum]::GetValues($EnumNamespace)\n\n    # Loop through to find the specific value\n    foreach($EnumValue in $EnumValues)\n    {\n        # check current\n        if($EnumValue -eq $EnumName)\n        {\n            # return it\n            return $EnumValue\n        }\n    }\n\n    # nothing was found\n    return $null\n}\n#endregion\n\n#region Update-ReportParamters()\nFunction Update-ReportParameters($ReportFile)\n{\n    # declare local variables\n    $ReportParameters = @();\n    \n    # necessary so that when attempting to use the report execution service, it doesn't puke on you when it can't find the data source\n    $ReportData = (Remove-SharedReferences -ReportFile $ReportFile)\n\n    # get just the report name\n    $ReportName = $ReportFile.SubString($ReportFile.LastIndexOf(\"\\\") + 1)\n    $ReportName = $ReportName.SubString(0, $ReportName.IndexOf(\".\"))\n    \n    # create warnings object\n    $ReportExecutionWarnings = $null\n\n    # set the report full path\n    $ReportPath = \"$ReportFolder/$ReportName\" \n\n    # load the report definition\n    $ExecutionInfo = $ReportExecutionProxy.LoadReportDefinition($ReportData, [ref] $ReportExecutionWarnings);\n\n    # loop through the report execution parameters\n    foreach($Parameter in $ExecutionInfo.Parameters)\n    {\n        # create new item parameter object\n        $ItemParameter = New-Object \"$ReportServerProxyNamespace.ItemParameter\";\n\n        # fill in the properties except valid values, that one needs special processing\n        Copy-ObjectProperties -SourceObject $Parameter -TargetObject $ItemParameter;\n\n        # fill in the valid values\n        $ItemParameter.ValidValues = Convert-ValidValues -SourceValidValues $Parameter.ValidValues;\n\n        # exclude if it's query based\n        if($Parameter.DefaultValuesQueryBased -ne $true)\n        {\n            # add to list\n            $ReportParameters += $ItemParameter;\n        }\n    }\n\n    # force the parameters to update\n    Write-Host \"Updating report parameters for $ReportFolder/$ReportName\"\n\tif ($IsReportService2005) {\n\t\t$ReportServerProxy.SetReportParameters(\"$ReportFolder/$ReportName\", $ReportParameters);\n\t}\n\telseif ($IsReportService2010) {\n\t\t$ReportServerProxy.SetItemParameters(\"$ReportFolder/$ReportName\", $ReportParameters);\n\t}\n\telse { Write-Warning 'Report Service Unknown in Update-ReportParameters method. Use ReportService2005 or ReportService2010.' }\n}\n#endregion\n\n#region Remove-ShareReferences()\nFunction Remove-SharedReferences($ReportFile)\n{\n    ######################################################################################################\n    #You'll notice that I've used the keywrod of [void] in front of some of these method calls, this is so\n    #that the operation isn't captured as output of the function\n    ######################################################################################################\n\n    # read xml\n    [xml]$ReportXml = Get-Content $ReportFile;\n    \n    # create new memory stream object\n    $MemoryStream = New-Object System.IO.MemoryStream\n\n    try\n    {\n\n        # declare array of nodes to remove\n        $NodesToRemove = @();\n\n        # get datasource names\n        $DataSourceNames = Get-ItemDataSources -ItemFile $ReportFile\n\n        # check to see if report has datasourcenames\n        if($DataSourceNames.Count -eq 0)\n        {\n            # Get reference to reportnode\n            $ReportNode = $ReportXml.FirstChild.NextSibling # Kind of a funky way of getting it, but the SelectSingleNode(\"//Report\") wasn't working due to Namespaces in the node\n\n            # create new DataSources node\n            $DataSourcesNode = $ReportXml.CreateNode($ReportNode.NodeType, \"DataSources\", $null)\n\n            # create new datasource node\n            $DataSourceNode = $ReportXml.CreateNode($ReportNode.NodeType, \"DataSource\", $null)\n\n            # create new datasourcereference node\n            $DataSourceReferenceNode = $ReportXml.CreateNode($ReportNode.NodeType, \"DataSourceReference\", $null)\n\n            # create new attribute\n            $DataSourceNameAttribute = $ReportXml.CreateAttribute(\"Name\")\n            $DataSourceNameAttribute.Value = \"DataSource1\"\n            $dataSourceReferenceNode.InnerText = \"DataSource1\"\n\n            # add attribute to datasource node\n            [void]$DataSourceNode.Attributes.Append($DataSourceNameAttribute)\n            [void]$DataSourceNode.AppendChild($DataSourceReferenceNode)\n\n            # add nodes\n            [void]$ReportNode.AppendChild($DataSourcesNode)\n            [void]$DataSourcesNode.AppendChild($DataSourceNode)\n\n            # add fake datasource name to array\n            $DataSourceNames += \"DataSource1\"\n        }\n\n        # get all datasource nodes\n        $DatasourceNodes = $ReportXml.GetElementsByTagName(\"DataSourceReference\");\n\n        # loop through returned nodes\n        foreach($DataSourceNode in $DatasourceNodes)\n        {\n            # create a new connection properties node\n            $ConnectionProperties = $ReportXml.CreateNode($DataSourceNode.NodeType, \"ConnectionProperties\", $null);\n\n            # create a new dataprovider node\n            $DataProvider = $ReportXml.CreateNode($DataSourceNode.NodeType, \"DataProvider\", $null);\n            $DataProvider.InnerText = \"SQL\";\n\n            # create new connection string node\n            $ConnectString = $ReportXml.CreateNode($DataSourceNode.NodeType, \"ConnectString\", $null);\n            $ConnectString.InnerText = \"Data Source=Server Name Here;Initial Catalog=database name here\";\n\n            # add new node to parent node\n            [void] $DataSourceNode.ParentNode.AppendChild($ConnectionProperties);\n\n            # append childeren\n            [void] $ConnectionProperties.AppendChild($DataProvider);\n            [void] $ConnectionProperties.AppendChild($ConnectString);\n\n            # Add to remove list \n            $NodesToRemove += $DataSourceNode;\n        }\n\n        # get all shareddataset nodes\n        $SharedDataSetNodes = $ReportXml.GetElementsByTagName(\"SharedDataSet\")\n\n        #loop through the returned nodes\n        foreach($SharedDataSetNode in $SharedDataSetNodes)\n        {\n            # create holder nodes so it won't error\n            $QueryNode = $ReportXml.CreateNode($SharedDataSetNode.NodeType, \"Query\", $null);\n            $DataSourceNameNode = $ReportXml.CreateNode($QueryNode.NodeType, \"DataSourceName\", $null);\n            $CommandTextNode = $ReportXml.CreateNode($QueryNode.NodeType, \"CommandText\", $null);\n\n            # add valid datasource name, just get the first in the list\n            $DataSourceNameNode.InnerText = $DataSourceNames[0]\n            \n            # add node to parent\n            [void] $SharedDataSetNode.ParentNode.Appendchild($QueryNode)\n            \n            # add datasourcename and commandtext to query node\n            [void]$QueryNode.AppendChild($DataSourceNameNode)\n            [void]$QueryNode.AppendChild($CommandTextNode)\n\n            # add node to removelist\n            $NodesToRemove += $SharedDataSetNode\n        }\n\n\n        # loop through nodes to remove\n        foreach($Node in $NodesToRemove)\n        {\n            # remove from parent\n            [void] $Node.ParentNode.RemoveChild($Node);\n        }\n    \n        $ReportXml.InnerXml = $ReportXml.InnerXml.Replace(\"xmlns=`\"`\"\", \"\")\n\n        # save altered xml to memory stream\n        $ReportXml.Save($MemoryStream);\n\n        # return the altered xml as byte array\n        return $MemoryStream.ToArray();\n    }\n    finally\n    {\n        # close and dispose\n        $MemoryStream.Close();\n        $MemoryStream.Dispose();\n    }\n}\n#endregion\n\n\n#region Copy-ObjectProperties()\nFunction Copy-ObjectProperties($SourceObject, $TargetObject)\n{\n    # Get source object property array\n    $SourcePropertyCollection = $SourceObject.GetType().GetProperties();\n\n    # get the destination\n    $TargetPropertyCollection = $TargetObject.GetType().GetProperties();\n\n    # loop through source property collection\n    for($i = 0; $i -lt $SourcePropertyCollection.Length; $i++)\n    {\n        # get the target property\n        $TargetProperty = $TargetPropertyCollection | Where {$_.Name -eq $SourcePropertyCollection[$i].Name}\n        \n        # check to see if it's null\n        if($TargetProperty -ne $null)\n        {\n            # check to see if it's the valid values property\n            if($TargetProperty.Name -ne \"ValidValues\")\n            {\n                 # set the value\n                $TargetProperty.SetValue($TargetObject, $SourcePropertyCollection[$i].GetValue($SourceObject));\n            }\n        }\n    }\n}\n#endregion\n\n#region ConvertValidValues()\nFunction Convert-ValidValues($SourceValidValues)\n{\n    # declare local values\n    $TargetValidValues = @();\n    \n    # loop through source values\n    foreach($SourceValidValue in $SourceValidValues)\n    {\n        # create target valid value object\n        $TargetValidValue = New-Object \"$ReportServerProxyNamespace.ValidValue\";\n\n        # copy properties\n        Copy-ObjectProperties -SourceObject $SourceValidValue -TargetObject $TargetValidValue\n\n        # add to list\n        $TargetValidValues += $TargetValidValue\n    }\n\n    # return the values\n    return ,$TargetValidValues\n}\n#endregion\n\n#region Backup-ExistingItem()\nFunction Backup-ExistingItem\n{\n    # parameters\n    Param($ItemFile, $ItemFolder)\n\n    # declare local variables\n    $ItemName = $ItemFile.SubString($ItemFile.LastIndexOf(\"\\\") + 1)\n    $ItemName = $ItemName.SubString(0, $ItemName.IndexOf(\".\"))\n\n    # check to see if the item exists\n    if((Item-Exists -ItemFolderPath $ItemFolder -ItemName $ItemName) -eq $true)\n    {\n        # get file extension\n        $FileExtension = [System.IO.Path]::GetExtension($ItemFile)\n    \n        # check backuplocation\n        if($BackupLocation.EndsWith(\"\\\") -ne $true)\n        {\n            # append ending slash\n            $BackupLocation = $BackupLocation + \"\\\"\n        }\n\t\t\n\t\t# add the release number to the backup location\n\t\t$BackupLocation = $BackupLocation + $ReleaseNumber + \"\\\"\n\n        # ensure the backup location actually exists\n        if((Test-Path $BackupLocation) -ne $true)\n        {\n            # create it\n            New-Item -ItemType Directory -Path $BackupLocation\n        }\n\n        # download the item\n        $Item = $ReportServerProxy.GetItemDefinition(\"$ItemFolder/$ItemName\")\n\n        # form the backup path\n        $BackupPath = \"{0}{1}{2}\" -f $BackupLocation, $ItemName, $FileExtension;\n\n        # write to disk\n        [System.IO.File]::WriteAllBytes(\"$BackupPath\", $Item);\n\n        # write to screen\n        Write-Host \"Backed up $ItemFolder/$ItemName to $BackupPath\";\n    }\n}\n#endregion\n\n#region Normalize-SSRSFolder()\nfunction Normalize-SSRSFolder ([string]$Folder) {\n    if (-not $Folder.StartsWith('/')) {\n        $Folder = '/' + $Folder\n    }\n    \n    return $Folder\n}\n#endregion\n\n#region New-SSRSFolder()\nfunction New-SSRSFolder ([string] $Name) {\n    Write-Verbose \"New-SSRSFolder -Name $Name\"\n \n    $Name = Normalize-SSRSFolder -Folder $Name\n \n    if ($ReportServerProxy.GetItemType($Name) -ne 'Folder') {\n        $Parts = $Name -split '/'\n        $Leaf = $Parts[-1]\n        $Parent = $Parts[0..($Parts.Length-2)] -join '/'\n \n        if ($Parent) {\n            New-SSRSFolder -Name $Parent\n        } else {\n            $Parent = '/'\n        }\n        \n        $ReportServerProxy.CreateFolder($Leaf, $Parent, $null)\n    }\n}\n#endregion\n\n#region New-SSRSDataSource()\nfunction New-SSRSDataSource ([string]$RdsPath, [string]$Folder, [bool]$OverwriteDataSources) {\n    Write-Verbose \"New-SSRSDataSource -RdsPath $RdsPath -Folder $Folder\"\n\n    $Folder = Normalize-SSRSFolder -Folder $Folder\n    \n    [xml]$Rds = Get-Content -Path $RdsPath\n    $dsName = $Rds.RptDataSource.Name\n    $ConnProps = $Rds.RptDataSource.ConnectionProperties\n    \n\t$type = $ReportServerProxy.GetType().Namespace #Get proxy type\n\t$DSDdatatype = ($type + '.DataSourceDefinition')\n\t \n\t$Definition = new-object ($DSDdatatype)\n\tif($Definition -eq $null){\n\t Write-Error Failed to create data source definition object\n\t}\n\t\n\t$dsConnectionString = $($OctopusParameters[\"$($dsName).ConnectionString\"])\n\t\n\t# replace the connection string variable that is configured in the octopus project\n\tif ($dsConnectionString) {\n\t    $Definition.ConnectString = $dsConnectionString\n\t} else {\n\t    $Definition.ConnectString = $ConnProps.ConnectString\n\t}\n\t\n    $Definition.Extension = $ConnProps.Extension \n\n\tif ([Convert]::ToBoolean($ConnProps.IntegratedSecurity)) {\n\t\t$Definition.CredentialRetrieval = 'Integrated'\n\t}\n\telse {\n\t\t$Definition.CredentialRetrieval = 'Store'\n\t\t\n\t\t$dsUsername = $($OctopusParameters[\"$($dsName).Username\"])\n\t\tWrite-Host \"$($dsName).Username = '$dsUsername'\"\n\t\t\n\t\t$dsPassword = $($OctopusParameters[\"$($dsName).Password\"])\n\t\tWrite-Host \"$($dsName).Password = '$dsPassword'\"\n\t\t\n\t\t$Definition.UserName = $dsUsername;\n        $Definition.Password = $dsPassword;\n\t}\n\n    $DataSource = New-Object -TypeName PSObject -Property @{\n        Name = $Rds.RptDataSource.Name\n        Path =  $Folder + '/' + $Rds.RptDataSource.Name\n    }\n    \n    if ($OverwriteDataSources -or $ReportServerProxy.GetItemType($DataSource.Path) -eq 'Unknown') {\n        Write-Host \"Overwriting datasource $($DataSource.Name)\"\n        $ReportServerProxy.CreateDataSource($DataSource.Name, $Folder, $OverwriteDataSources, $Definition, $null)\n    }\n    \n    return $DataSource \n}\n#endregion\n\n#region Main\n\ntry\n{\n    # declare array for reports\n    $ReportFiles = @()\n\t$ReportDataSourceFiles = @()\n    $ReportDataSetFiles = @()\n\t\n\t$IsReportService2005 = $false\n\t$IsReportService2010 = $false\n\t\n\tif ($ReportServiceUrl.ToLower().Contains('reportservice2005.asmx')) {\n\t\t$IsReportService2005 = $true\n\t\tWrite-Host \"2005 Report Service found.\"\n\t}\n\telseif ($ReportServiceUrl.ToLower().Contains('reportservice2010.asmx')) {\n\t\t$IsReportService2010 = $true\n\t\tWrite-Host \"2010 Report Service found.\"\n\t}\n\t\n\tWrite-Host \"Deploy Path: $DeployedPath\"\n\t\n    # get all report files for deployment\n    Write-Host \"Getting all .rdl files\"\n    Get-ChildItem $DeployedPath -Recurse -Filter \"*.rdl\" | ForEach-Object { If(($ReportFiles -contains $_.FullName) -eq $false) {$ReportFiles += $_.FullName}}\n    Write-Host \"# of rdl files found: $($ReportFiles.Count)\"\n\n    # get all report datasource files for deployment\n    Write-Host \"Getting all .rds files\"\n    Get-ChildItem $DeployedPath -Recurse -Filter \"*.rds\" | ForEach-Object { If(($ReportDataSourceFiles -contains $_.FullName) -eq $false) {$ReportDataSourceFiles += $_.FullName}}\n    Write-Host \"# of rds files found: $($ReportDataSourceFiles.Count)\"\n\n    # get all report datset files for deployment\n    Write-Host \"Getting all .rsd files\"\n    Get-ChildItem $DeployedPath -Recurse -Filter \"*.rsd\" | ForEach-Object { If(($ReportDataSetFiles -contains $_.FullName) -eq $false) {$ReportDataSetFiles += $_.FullName}}\n    Write-Host \"# of rsd files found: $($ReportDataSetFiles.Count)\"\n\n\n    # set the report proxies\n    Write-Host \"Creating SSRS Web Service proxies\"\n\n    # check to see if credentials were supplied for the services\n    if(([string]::IsNullOrEmpty($ServiceUserDomain) -ne $true) -and ([string]::IsNullOrEmpty($ServiceUserName) -ne $true) -and ([string]::IsNullOrEmpty($ServicePassword) -ne $true))\n    {\n        # secure the password\n        $secpasswd = ConvertTo-SecureString \"$ServicePassword\" -AsPlainText -Force\n\n        # create credential object\n        $ServiceCredential = New-Object System.Management.Automation.PSCredential (\"$ServiceUserDomain\\$ServiceUserName\", $secpasswd)\n\n        # create proxies\n        $ReportServerProxy = New-WebServiceProxy -Uri $ReportServiceUrl -Credential $ServiceCredential\n        $ReportExecutionProxy = New-WebServiceProxy -Uri $ReportExecutionUrl -Credential $ServiceCredential\n    }\n    else\n    {\n        # create proxies using current identity\n        $ReportServerProxy = New-WebServiceProxy -Uri $ReportServiceUrl -UseDefaultCredential \n        $ReportExecutionProxy = New-WebServiceProxy -Uri $ReportExecutionUrl -UseDefaultCredential \n    }\n\n\n\n\t#Create folder information for DataSource and Report\n\tNew-SSRSFolder -Name $ReportFolder\n\tNew-SSRSFolder -Name $ReportDatasourceFolder\n    New-SSRSFolder -Name $ReportDataSetFolder\n\t \n\t#Create DataSource\n    foreach($RDSFile in $ReportDataSourceFiles) {\n        Write-Host \"New-SSRSDataSource $RdsFile\"\n        \n\t\t$DataSource = New-SSRSDataSource -RdsPath $RdsFile -Folder $ReportDatasourceFolder -Overwrite ([System.Convert]::ToBoolean(\"$OverwriteDataSources\"))\n\t}\n\n    # get the service proxy namespaces - this is necessary because of a bug documented here http://stackoverflow.com/questions/7921040/error-calling-reportingservice2005-finditems-specifically-concerning-the-bool and http://www.vistax64.com/powershell/273120-bug-when-using-namespace-parameter-new-webserviceproxy.html\n    $ReportServerProxyNamespace = Get-ObjectNamespace -Object $ReportServerProxy\n    $ReportExecutionProxyNamespace = Get-ObjectNamespace -Object $ReportExecutionProxy\n\n    # Create dat sets\n    foreach($DataSet in $ReportDataSetFiles)\n    {\n        # check to see if we need to back up\n        if($BackupLocation -ne $null -and $BackupLocation -ne \"\")\n        {\n            # backup the item\n            Backup-ExistingItem -ItemFile $DataSet -ItemFolder $ReportDataSetFolder\n        }\n\n        # upload the dataset\n        Upload-Item -Item $DataSet -ItemType \"DataSet\" -ItemFolder $ReportDataSetFolder\n\n        # update the dataset datasource\n        Set-ItemDataSources -ItemFile $DataSet -ItemFolder $ReportDataSetFolder\n    }\n\n    # get the proxy auto generated name spaces\n\n    # loop through array\n    foreach($ReportFile in $ReportFiles)\n    {\n        # check to see if we need to back up\n        if($BackupLocation -ne $null -and $BackupLocation -ne \"\")\n        {\n            # backup the item\n            Backup-ExistingItem -ItemFile $ReportFile -ItemFolder $ReportFolder\n        }\n        \n        # upload report\n        Upload-Item -Item $ReportFile -ItemType \"Report\" -ItemFolder $ReportFolder\n\n        # extract datasources\n        #Write-Host \"Extracting datasource names for $ReportFile\"\n        #$ReportDataSourceNames = Get-ReportDataSourceNames $ReportFile\n\n        # set the datasources\n        Set-ItemDataSources -ItemFile $ReportFile -ItemFolder $ReportFolder\n\n        # set the datasets\n        Set-ReportDataSets -ReportFile $ReportFile\n\n        # update the report parameters\n        Update-ReportParameters -ReportFile $ReportFile\n    }\n}\nfinally\n{\n    # check to see if the proxies are null\n    if($ReportServerProxy -ne $null)\n    {\n        # dispose\n        $ReportServerProxy.Dispose();\n    }\n\n    if($ReportExecutionProxy -ne $null)\n    {\n        # dispose\n        $ReportExecutionProxy.Dispose();\n    }\n}\n\n#endregion\n",
    "Octopus.Action.Script.Syntax": "PowerShell",
    "Octopus.Action.Script.ScriptSource": "Inline",
    "Octopus.Action.RunOnServer": "false",
    "Octopus.Action.Script.ScriptFileName": null,
    "Octopus.Action.Package.FeedId": null,
    "Octopus.Action.Package.PackageId": null
  },
  "Parameters": [
    {
      "Id": "92daa94e-73f3-466e-a8db-35149646df2b",
      "Name": "NugetPackageStepName",
      "Label": "SSRS package step",
      "HelpText": "Select the step in this project which downloads the SSRS package.",
      "DefaultValue": null,
      "DisplaySettings": {
        "Octopus.ControlType": "StepName"
      },
      "Links": { }
    },
    {
      "Id": "0bb2f003-fda9-4571-86aa-3bad13775874",
      "Name": "ReportServiceUrl",
      "Label": "Url of SSRS Server service",
      "HelpText": "The complete Url to the SSRS server.\nExample: http://198.239.216.46/ReportServer_LOCALDEV/reportservice2010.asmx?wsdl",
      "DefaultValue": null,
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      },
      "Links": { }
    },
    {
      "Id": "feca8cfe-fe9e-4e8f-ac7e-b370b5ef3ef6",
      "Name": "ReportExecutionUrl",
      "Label": "Report Execution Url",
      "HelpText": "The complete Url to the Report Execution service.\nExample: http://198.239.216.46/ReportServer_LOCALDEV/ReportExecution2005.asmx?wsdl",
      "DefaultValue": null,
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      },
      "Links": { }
    },
    {
      "Id": "1924b3a6-d5bf-4713-8bc7-6b77422a7944",
      "Name": "ReportFolder",
      "Label": "Report folder",
      "HelpText": "Relative Url to the folder in which the reports will be deployed.",
      "DefaultValue": null,
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      },
      "Links": { }
    },
    {
      "Id": "28cc63a0-5a3e-4d22-8406-574bdb332fe1",
      "Name": "ReportDatasourceFolder",
      "Label": "Report data source folder",
      "HelpText": "Relative Url where the data sources for the reports are located, starting with '/'",
      "DefaultValue": null,
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      },
      "Links": { }
    },
    {
      "Id": "b1cdc16e-c2db-41eb-9ae8-8df02b05f03d",
      "Name": "OverwriteDataSources",
      "Label": "Overwrite datasource(s)",
      "HelpText": "Tick if the existing report data source file needs to e replaced.",
      "DefaultValue": "False",
      "DisplaySettings": {
        "Octopus.ControlType": "Checkbox"
      },
      "Links": { }
    },
    {
      "Id": "b0e69f02-1f99-431a-852e-b0084ed23fd4",
      "Name": "BackupLocation",
      "Label": "Backup Location",
      "HelpText": "Directory path to take a backup of existing reports (.rdl) and data source (.rds) files.",
      "DefaultValue": null,
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      },
      "Links": { }
    },
    {
      "Id": "a736f0b8-aa27-45ae-b6a0-43a76e44d85a",
      "Name": "ReportDataSetFolder",
      "Label": "DataSet folder",
      "HelpText": "Relative Url where Shared Data Sets are stored",
      "DefaultValue": null,
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      },
      "Links": { }
    },
    {
      "Id": "47575f66-9b1b-4cbb-a062-30d811e6159d",
      "Name": "ServiceUserDomain",
      "Label": "Service Domain",
      "HelpText": "(Optional - leave blank to use Tentacle identity) Name of the domain for the user account to execute as",
      "DefaultValue": null,
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      },
      "Links": { }
    },
    {
      "Id": "98b43d45-5a5a-456a-aac7-1f4cc6fe8e55",
      "Name": "ServiceUserName",
      "Label": "Service Username",
      "HelpText": "(Optional - leave blank to use Tentacle identity) Username of the user account to execute as",
      "DefaultValue": null,
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      },
      "Links": { }
    },
    {
      "Id": "fd48bde1-3874-45ea-ab99-b40c13b91d5a",
      "Name": "ServicePassword",
      "Label": "Service Password",
      "HelpText": "(Optional - leave blank to use Tentacle identity) Password of the user account to execute as",
      "DefaultValue": null,
      "DisplaySettings": {
        "Octopus.ControlType": "Sensitive"
      },
      "Links": { }
    }
  ],
  "LastModifiedBy" :  "twerthi",
  "$Meta": {
    "ExportedAt": "2017-02-03T17:50:09.222Z",
    "OctopusVersion": "3.8.2",
    "Type": "ActionTemplate"
  },
  "Category" :  "sql"
}