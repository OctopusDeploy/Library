{
    "Id": "522c7010-7189-4b2e-a3c8-36cb1759422a",
    "Name": "CyberArk Conjur - Retrieve Secrets",
    "Description": "This step retrieves one or more secrets from [CyberArk Conjur](https://www.conjur.org/) and creates [sensitive output variables](https://octopus.com/docs/projects/variables/output-variables#sensitive-output-variables) for each value retrieved. These values can be used in other steps in your deployment or runbook process.

This step differs from the [CyberArk Conjur - Retrieve a Secret](https://library.octopus.com/step-templates/eafe9740-1008-4375-9e82-0d193109b669/actiontemplate-cyberark-conjur-retrieve-a-secret) step template as it offers the ability to retrieve multiple secrets (with optional version) and performs a batched call where possible - see below for further details.

---

**Retrieval Behavior:**

- If any of the Conjur Variables have a version specified to retrieve, then the step template will retrieve **all** of the secrets individually using the [Conjur REST API - Secret Retrieve](https://docs.conjur.org/Latest/en/Content/Developer/Conjur_API_Retrieve_Secret.htm) endpoint.
- If none of the Conjur Variables have a version specified (i.e. retrieve the latest version) then the step template will retrieve the secrets using the [Conjur REST API - Batch Retrieval](https://docs.conjur.org/Latest/en/Content/Developer/Conjur_API_Batch_Retrieve.htm) endpoint.

*Hint:* If performance is important to you, don't include specific versions of Conjur Variables. Itâ€™s faster to fetch secrets in a batch than to fetch them one at a time.

---

**Required:** 
- PowerShell **5.1** or higher.
- A set of credentials with permissions to retrieve secrets from CyberArk Conjur.
- Access to the Conjur instance from the Worker or target where this step executes.

Notes:

- Tested on Conjur **v1.13.2** / API **v5.2.0**.
- Tested on Octopus **2021.2**.
- Tested on both Windows Server 2019 and Ubuntu 20.04.",
    "ActionType": "Octopus.Script",
    "Version": 1,
    "CommunityActionTemplateId": null,
    "Packages": [],
    "Properties": {
      "Octopus.Action.Script.ScriptSource": "Inline",
      "Octopus.Action.Script.Syntax": "PowerShell",
      "Octopus.Action.Script.ScriptBody": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$ErrorActionPreference = 'Stop'

# Variables
$ConjurUrl = $OctopusParameters[\"CyberArk.Conjur.RetrieveSecrets.Url\"]
$ConjurAccount = $OctopusParameters[\"CyberArk.Conjur.RetrieveSecrets.Account\"]
$ConjurLogin = $OctopusParameters[\"CyberArk.Conjur.RetrieveSecrets.Login\"]
$ConjurApiKey = $OctopusParameters[\"CyberArk.Conjur.RetrieveSecrets.ApiKey\"]
$ConjurSecretVariables = $OctopusParameters[\"CyberArk.Conjur.RetrieveSecrets.SecretVariables\"]
$PrintVariableNames = $OctopusParameters[\"CyberArk.Conjur.RetrieveSecrets.PrintVariableNames\"]

# Validation
if ([string]::IsNullOrWhiteSpace($ConjurUrl)) {
    throw \"Required parameter CyberArk.Conjur.RetrieveSecrets.Url not specified\"
}
if ([string]::IsNullOrWhiteSpace($ConjurAccount)) {
    throw \"Required parameter CyberArk.Conjur.RetrieveSecrets.Account not specified\"
}
if ([string]::IsNullOrWhiteSpace($ConjurLogin)) {
    throw \"Required parameter CyberArk.Conjur.RetrieveSecrets.Login not specified\"
}
if ([string]::IsNullOrWhiteSpace($ConjurApiKey)) {
    throw \"Required parameter CyberArk.Conjur.RetrieveSecrets.ApiKey not specified\"
}
if ([string]::IsNullOrWhiteSpace($ConjurSecretVariables)) {
    throw \"Required parameter CyberArk.Conjur.RetrieveSecrets.SecretVariables not specified\"
}

### Helper functions

# This function creates a URI and prevents Urls that have been Url encoded from being re-encoded.
# Typically this happens on Windows (dynamic) workers in Octopus, and not PS Core.
# Helpful background - https://stackoverflow.com/questions/25596564/percent-encoded-slash-is-decoded-before-the-request-dispatch
# Function based from https://github.com/IISResetMe/PSdotNETRuntimeHacks/blob/trunk/Set-DontUnescapePathDotsAndSlashes.ps1
function New-DontUnescapePathDotsAndSlashes-Uri {
    param(
        [Parameter(Mandatory = $true)]
        [ValidateNotNull()]
        [string]$SourceUri
    )

    $uri = New-Object System.Uri $SourceUri

    # If running PS Core, not affected
    if ($PSEdition -eq \"Core\") {
        return $uri
    }

    # Retrieve the private Syntax field from the uri class,
    # this is our indirect reference to the attached parser
    $syntaxFieldInfo = $uri.GetType().GetField('m_Syntax', 'NonPublic,Instance')
    if (-not $syntaxFieldInfo) {
        throw [System.MissingFieldException]\"'m_Syntax' field not found\"
    }

    # Retrieve the private Flags field from the parser class,
    # this is the value we're looking to update at runtime
    $flagsFieldInfo = [System.UriParser].GetField('m_Flags', 'NonPublic,Instance')
    if (-not $flagsFieldInfo) {
        throw [System.MissingFieldException]\"'m_Flags' field not found\"
    }

    # Retrieve the actual instances
    $uriParser = $syntaxFieldInfo.GetValue($uri)
    $uriSyntaxFlags = $flagsFieldInfo.GetValue($uriParser)

    # Define the bit flags we want to remove
    $UnEscapeDotsAndSlashes = 0x2000000
    $SimpleUserSyntax = 0x20000

    # Clear the flags that we don't want
    $uriSyntaxFlags = [int]$uriSyntaxFlags -band -bnot($UnEscapeDotsAndSlashes)
    $uriSyntaxFlags = [int]$uriSyntaxFlags -band -bnot($SimpleUserSyntax)

    # Overwrite the existing Flags field
    $flagsFieldInfo.SetValue($uriParser, $uriSyntaxFlags)

    return $uri
}

function Get-WebRequestErrorBody {
    param (
        $RequestError
    )
    $rawResponse = \"\"
    # Powershell < 6 you can read the Exception
    if ($PSVersionTable.PSVersion.Major -lt 6) {
        if ($RequestError.Exception.Response) {
            $reader = New-Object System.IO.StreamReader($RequestError.Exception.Response.GetResponseStream())
            $reader.BaseStream.Position = 0
            $reader.DiscardBufferedData()
            $rawResponse = $reader.ReadToEnd()
        }
    }
    else {
        $rawResponse = $RequestError.ErrorDetails.Message
    }

    try { $response = $rawResponse | ConvertFrom-Json } catch { $response = $rawResponse }
    return $response
}

function Format-SecretName {
    [CmdletBinding()]
    Param(
        [string] $Name,
        [string] $Version
    )
    $displayName = \"'$Name'\"
    if (![string]::IsNullOrWhiteSpace($Version)) {
        $displayName += \" (v:$($Version))\"
    }
    return $displayName
}

### End Helper function

$Secrets = @()
$VariablesCreated = 0
$StepName = $OctopusParameters[\"Octopus.Step.Name\"]
$ConjurUrl = $ConjurUrl.TrimEnd(\"/\")

# Extract secret names
@(($ConjurSecretVariables -Split \"`n\").Trim()) | ForEach-Object {
    if (![string]::IsNullOrWhiteSpace($_)) {
        Write-Verbose \"Working on: '$_'\"
        $secretDefinition = ($_ -Split \"\\|\")
        $secretName = $secretDefinition[0].Trim()
        $secretNameAndVersion = ($secretName -Split \" \")
        $secretVersion = \"\"
        if ($secretNameAndVersion.Count -gt 1) {
            $secretName = $secretNameAndVersion[0].Trim()
            $secretVersion = $secretNameAndVersion[1].Trim()
        }
        if ([string]::IsNullOrWhiteSpace($secretName)) {
            throw \"Unable to establish secret name from: '$($_)'\"
        }

        $UriEscapedName = [uri]::EscapeDataString($secretName)
        $VariableIdPrefix = \"$($ConjurAccount):variable\"

        $secret = [PsCustomObject]@{
            Name                 = $secretName
            UriEscapedName       = $uriEscapedName
            Version              = $secretVersion
            VariableName         = if (![string]::IsNullOrWhiteSpace($secretDefinition[1])) { $secretDefinition[1].Trim() } else { \"\" }
            VariableId           = \"$($VariableIdPrefix):$($secretName)\"
            UriEscapedVariableId = \"$($VariableIdPrefix):$($UriEscapedName)\"
        }
        $Secrets += $secret
    }
}
$SecretsWithVersionSpecified = @($Secrets | Where-Object { ![string]::IsNullOrWhiteSpace($_.Version) })

Write-Verbose \"Conjur Url: $ConjurUrl\"
Write-Verbose \"Conjur Account: $ConjurAccount\"
Write-Verbose \"Conjur Login: $ConjurLogin\"
Write-Verbose \"Conjur API Key: ********\"
Write-Verbose \"Secrets to retrieve: $($Secrets.Count)\"
Write-Verbose \"Secrets with Version specified: $($SecretsWithVersionSpecified.Count)\"
Write-Verbose \"Print variables: $PrintVariableNames\"

try {

    $headers = @{
        \"Content-Type\"    = \"application/json\"; 
        \"Accept-Encoding\" = \"base64\"
    }

    $body = $ConjurApiKey
    $loginUriSegment = [uri]::EscapeDataString($ConjurLogin)
    $authnUri = New-DontUnescapePathDotsAndSlashes-Uri -SourceUri \"$ConjurUrl/authn/$ConjurAccount/$loginUriSegment/authenticate\"
    $authToken = Invoke-RestMethod -Uri $authnUri -Method Post -Headers $headers -Body $body
}
catch {
    $ExceptionMessage = $_.Exception.Message
    $ErrorBody = Get-WebRequestErrorBody -RequestError $_
    $Message = \"An error occurred logging in to Conjur: $ExceptionMessage\"
    $AdditionalDetail = \"\"
    if (![string]::IsNullOrWhiteSpace($ErrorBody)) {
        if ($null -ne $ErrorBody.error) {
            $AdditionalDetail = \"$($ErrorBody.error.code) - $($ErrorBody.error.message)\"
        }
        else {
            $AdditionalDetail += $ErrorBody
        }
    }
    if (![string]::IsNullOrWhiteSpace($AdditionalDetail)) {
        $Message += \"`nDetail: $AdditionalDetail\"
    }
    
    Write-Error $Message -Category AuthenticationError
}

if ([string]::IsNullOrWhiteSpace($authToken)) {
    Write-Error \"Null or Empty token!\"
    return
}

# Set token auth header
$headers = @{
    \"Authorization\" = \"Token token=`\"$($authToken)`\"\"; 
}

if ($SecretsWithVersionSpecified.Count -gt 0) {
    Write-Verbose \"Retrieving secrets individually as at least one has a version specified.\"
    foreach ($secret in $Secrets) {
        try {
            $name = $secret.Name
            $uriEscapedName = $secret.UriEscapedName
            $secretVersion = $secret.Version
            $variableName = $secret.VariableName
            $displayName = Format-SecretName -Name $name -Version $secretVersion

            if ([string]::IsNullOrWhiteSpace($variableName)) {
                $variableName = \"$($name.Trim().Replace(\"/\",\".\"))\"
            }
            $secretUri = \"$ConjurUrl/secrets/$ConjurAccount/variable/$uriEscapedName\"
            if (![string]::IsNullOrWhiteSpace($secretVersion)) {
                $secretUri += \"?version=$($secretVersion)\"
            }
            $secretUri = New-DontUnescapePathDotsAndSlashes-Uri -SourceUri \"$secretUri\"
            Write-Verbose \"Retrieving Secret $displayName\"
            $secretValue = Invoke-RestMethod -Uri $secretUri -Method Get -Headers $headers 

            if ([string]::IsNullOrWhiteSpace($secretValue)) {
                Write-Error \"Error: Secret $displayName not found or has no versions.\"
                break;
            }
    
            Set-OctopusVariable -Name $variableName -Value $secretValue -Sensitive
    
            if ($PrintVariableNames -eq $True) {
                Write-Output \"Created output variable: ##{Octopus.Action[$StepName].Output.$variableName}\"
            }
            $VariablesCreated += 1
        }
        catch {
            $ExceptionMessage = $_.Exception.Message
            $ErrorBody = Get-WebRequestErrorBody -RequestError $_
            $Message = \"An error occurred retrieving secret $($displayName) from Conjur: $ExceptionMessage\"
            $AdditionalDetail = \"\"
            if (![string]::IsNullOrWhiteSpace($ErrorBody)) {
                if ($null -ne $ErrorBody.error) {
                    $AdditionalDetail = \"$($ErrorBody.error.code) - $($ErrorBody.error.message)\"
                }
                else {
                    $AdditionalDetail += $ErrorBody
                }
            }
        
            if (![string]::IsNullOrWhiteSpace($AdditionalDetail)) {
                $Message += \"`nDetail: $AdditionalDetail\"
            }
    
            Write-Error $Message -Category ReadError
            break;
        }
    }
}
else {
    Write-Verbose \"Retrieving secrets by batch as no versions specified.\"
    $uriEscapedVariableIds = @($Secrets | ForEach-Object { \"$($_.UriEscapedVariableId)\" }) -Join \",\"

    try {    
        $secretsUri = New-DontUnescapePathDotsAndSlashes-Uri -SourceUri \"$ConjurUrl/secrets?variable_ids=$($uriEscapedVariableIds)\"
        $secretValues = Invoke-RestMethod -Uri $secretsUri -Method Get -Headers $headers
        $secretKeyValues = $secretValues | Get-Member | Where-Object { $_.MemberType -eq \"NoteProperty\" } | Select-Object -ExpandProperty \"Name\"
        foreach ($secret in $Secrets) {
            $name = $secret.Name
            $variableId = $secret.VariableId
            $variableName = $secret.VariableName

            Write-Verbose \"Extracting Secret '$($name)' from Conjur batched response\"

            if ([string]::IsNullOrWhiteSpace($variableName)) {
                $variableName = \"$($name.Trim().Replace(\"/\",\".\"))\"
            }
            if ($secretKeyValues -inotcontains $variableId) {
                Write-Error \"Secret '$name' not found in Conjur response.\"
                return
            }
            
            $variableValue = $secretValues.$variableId
            Set-OctopusVariable -Name $variableName -Value $variableValue -Sensitive

            if ($PrintVariableNames -eq $True) {
                Write-Host \"Created output variable: ##{Octopus.Action[$StepName].Output.$variableName}\"
            }
            $VariablesCreated += 1
        }
    }
    catch {
        $ExceptionMessage = $_.Exception.Message
        $ErrorBody = Get-WebRequestErrorBody -RequestError $_
        $Message = \"An error occurred retrieving batched secrets from Conjur: $ExceptionMessage\"
        $AdditionalDetail = \"\"
        if (![string]::IsNullOrWhiteSpace($ErrorBody)) {
            if ($null -ne $ErrorBody.error) {
                $AdditionalDetail = \"$($ErrorBody.error.code) - $($ErrorBody.error.message)\"
            }
            else {
                $AdditionalDetail += $ErrorBody
            }
        }
        if (![string]::IsNullOrWhiteSpace($AdditionalDetail)) {
            $Message += \"`nDetail: $AdditionalDetail\"
        }
        
        Write-Error $Message -Category AuthenticationError
    }
}

Write-Host \"Created $variablesCreated output variables\""
    },
    "Parameters": [
      {
        "Id": "66a70ea0-8d3a-4682-9575-c1dae8ad75e6",
        "Name": "CyberArk.Conjur.RetrieveSecrets.Url",
        "Label": "Conjur URL",
        "HelpText": "The URL of the Conjur instance you are connecting to.",
        "DefaultValue": "",
        "DisplaySettings": {
          "Octopus.ControlType": "SingleLineText"
        }
      },
      {
        "Id": "ceae6659-4643-490d-9d8d-f642c1c1b4a0",
        "Name": "CyberArk.Conjur.RetrieveSecrets.Account",
        "Label": "Conjur Account",
        "HelpText": "The Conjur account. This is the Conjur appliance identifier provided during Conjur configuration.",
        "DefaultValue": "",
        "DisplaySettings": {
          "Octopus.ControlType": "SingleLineText"
        }
      },
      {
        "Id": "0f501e04-207f-4a05-9d21-1e2462bf5b73",
        "Name": "CyberArk.Conjur.RetrieveSecrets.Login",
        "Label": "Conjur Login",
        "HelpText": "The username (from the point of view of the authenticator) of the user or machine (host) requesting authentication. For a host, the id assigned when the host was created should be used, prepended with the literal `host/`.",
        "DefaultValue": "",
        "DisplaySettings": {
          "Octopus.ControlType": "SingleLineText"
        }
      },
      {
        "Id": "3985b74e-1ea8-4bda-affa-9e7b22056c58",
        "Name": "CyberArk.Conjur.RetrieveSecrets.ApiKey",
        "Label": "Conjur Api Key",
        "HelpText": "The API Key corresponding to the user/host provided.",
        "DefaultValue": "",
        "DisplaySettings": {
          "Octopus.ControlType": "Sensitive"
        }
      },
      {
        "Id": "eefe9594-7dd1-4fa4-9bb1-65ced026fdda",
        "Name": "CyberArk.Conjur.RetrieveSecrets.SecretVariables",
        "Label": "Conjur Secret Variable IDs",
        "HelpText": "Specify the names of the secrets to be returned from Conjur, in the format:

`VariableID Version | OutputVariableName` where:

- `VariableID` is the Variable ID of the Conjur secret.
- `Version` is the version of the secret to retrieve. *If this value isn't specified, the latest version will be retrieved*.
- `OutputVariableName` is the _optional_ Octopus [output variable](https://octopus.com/docs/projects/variables/output-variables) name to store the secret's value in. *If this value isn't specified, an output name will be generated dynamically*.

**Note:** Multiple Variable IDs can be retrieved by entering each one on a new line.",
        "DefaultValue": "",
        "DisplaySettings": {
          "Octopus.ControlType": "MultiLineText"
        }
      },
      {
        "Id": "462f3385-dccd-4ac1-a30b-b06029fbfc18",
        "Name": "CyberArk.Conjur.RetrieveSecrets.PrintVariableNames",
        "Label": "Print output variable names",
        "HelpText": "Write out the Octopus [output variable](https://octopus.com/docs/projects/variables/output-variables) names to the task log. Default: `False`.",
        "DefaultValue": "False",
        "DisplaySettings": {
          "Octopus.ControlType": "Checkbox"
        }
      }
    ],
    "StepPackageId": "Octopus.Script",
    "$Meta": {
      "ExportedAt": "2021-10-19T10:19:57.315Z",
      "OctopusVersion": "2021.2.7697",
      "Type": "ActionTemplate"
    },
    "LastModifiedBy": "harrisonmeister",
    "Category": "cyberark"
  }
