{
  "Id": "87b2154a-5c8d-4c31-9680-575bb6df9789",
  "Name": "Octopus - EKS Reference Architecture",
  "Description": "This step populates an Octopus space with the environments, feeds, accounts, lifecycles, projects, and runbooks required to deploy a sample application to an AWS EKS Kubernetes cluster. These resources combine to form a reference architecture teams can use to bootstrap an Octopus space with best practices and example projects. It is recommended that you run this step with the `octopuslabs/terraform-workertools` [container image](https://octopus.com/docs/projects/steps/execution-containers-for-workers). 

That this step assumes it is run on a cloud Octopus instance, or the default worker runs Linux, has Docker installed, and has PowerShell Core installed.

The step will not update existing projects, environments etc. If you wish to recreate these resource with the latest configuration, for example if this step is updated and you wish to see the latest settings, you must manually delete or rename the resources to be recreated.",
  "ActionType": "Octopus.TerraformApply",
  "Version": 16,
  "CommunityActionTemplateId": null,
  "Packages": [],
  "Properties": {
    "Octopus.Action.GoogleCloud.UseVMServiceAccount": "True",
    "Octopus.Action.GoogleCloud.ImpersonateServiceAccount": "False",
    "Octopus.Action.Terraform.GoogleCloudAccount": "False",
    "Octopus.Action.Terraform.AzureAccount": "False",
    "Octopus.Action.Terraform.ManagedAccount": "None",
    "Octopus.Action.Terraform.AllowPluginDownloads": "True",
    "Octopus.Action.Script.ScriptSource": "Inline",
    "Octopus.Action.Terraform.RunAutomaticFileSubstitution": "True",
    "Octopus.Action.Terraform.PlanJsonOutput": "False",
    "Octopus.Action.Terraform.Template": "terraform {
  required_providers {
    octopusdeploy = { source = \"OctopusDeployLabs/octopusdeploy\", version = \"0.21.1\" }
  }
}

#region Locals
locals {
  # These local variables define the name of the projects created by this module.
  infrastructure_project_name   = \"_ AWS EKS Infrastructure\"
  project_template_project_name = \"Docker Project Templates\"
  frontend_project_name         = \"EKS Octopub Frontend\"
  products_project_name         = \"EKS Octopub Products\"
  audits_project_name           = \"EKS Octopub Audits\"

  development_environment_id         = length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id
  test_environment_id                = length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id
  production_environment_id          = length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id
  sync_environment_id                = length(data.octopusdeploy_environments.environment_sync.environments) == 0 ? octopusdeploy_environment.environment_sync[0].id : data.octopusdeploy_environments.environment_sync.environments[0].id
  security_environment_id            = length(data.octopusdeploy_environments.environment_security.environments) == 0 ? octopusdeploy_environment.environment_security[0].id : data.octopusdeploy_environments.environment_security.environments[0].id
  featurebranch_environment_id       = length(data.octopusdeploy_environments.environment_featurebranch.environments) == 0 ? octopusdeploy_environment.environment_featurebranch[0].id : data.octopusdeploy_environments.environment_featurebranch.environments[0].id
  this_instance_library_variable_set = length(data.octopusdeploy_library_variable_sets.this_instance.library_variable_sets) == 0 ? octopusdeploy_library_variable_set.this_instance[0].id : data.octopusdeploy_library_variable_sets.this_instance.library_variable_sets[0].id
  github_library_variable_set        = length(data.octopusdeploy_library_variable_sets.github.library_variable_sets) == 0 ? octopusdeploy_library_variable_set.github[0].id : data.octopusdeploy_library_variable_sets.github.library_variable_sets[0].id
  docker_library_variable_set        = length(data.octopusdeploy_library_variable_sets.docker.library_variable_sets) == 0 ? octopusdeploy_library_variable_set.docker[0].id : data.octopusdeploy_library_variable_sets.docker.library_variable_sets[0].id
  docker_hub_feed_id                 = length(data.octopusdeploy_feeds.dockerhub.feeds) == 0 ? octopusdeploy_docker_container_registry.docker_hub[0].id : data.octopusdeploy_feeds.dockerhub.feeds[0].id
  github_feed_id                     = length(data.octopusdeploy_feeds.github_feed.feeds) == 0 ? octopusdeploy_github_repository_feed.github_feed[0].id : data.octopusdeploy_feeds.github_feed.feeds[0].id
  worker_pool_id                     = length(data.octopusdeploy_worker_pools.workerpool_hosted_ubuntu.worker_pools) == 0 ? \"\" : data.octopusdeploy_worker_pools.workerpool_hosted_ubuntu.worker_pools[0].id
  aws_account                        = length(data.octopusdeploy_accounts.aws_account.accounts) == 0 ? octopusdeploy_aws_account.aws_account[0].id : data.octopusdeploy_accounts.aws_account.accounts[0].id
  devops_lifecycle_id                = length(data.octopusdeploy_lifecycles.devsecops.lifecycles) == 0 ? octopusdeploy_lifecycle.lifecycle_devsecops[0].id : data.octopusdeploy_lifecycles.devsecops.lifecycles[0].id
  featurebranch_lifecycle_id         = length(data.octopusdeploy_lifecycles.featurebranch.lifecycles) == 0 ? octopusdeploy_lifecycle.lifecycle_featurebranch[0].id : data.octopusdeploy_lifecycles.featurebranch.lifecycles[0].id
  eks_project_group_id               = length(data.octopusdeploy_project_groups.eks.project_groups) == 0 ? octopusdeploy_project_group.project_group_eks[0].id : data.octopusdeploy_project_groups.eks.project_groups[0].id
  project_templates_project_group_id = length(data.octopusdeploy_project_groups.project_templates.project_groups) == 0 ? octopusdeploy_project_group.project_group_project_templates[0].id : data.octopusdeploy_project_groups.project_templates.project_groups[0].id
  application_lifecycle_id           = length(data.octopusdeploy_lifecycles.application.lifecycles) == 0 ? octopusdeploy_lifecycle.lifecycle_application[0].id : data.octopusdeploy_lifecycles.application.lifecycles[0].id
  create_cluster_script              = <<-EOT
  # Check to see if $IsWindows is available
  if ($null -eq $IsWindows)
  {
      Write-Host \"Determining Operating System...\"
      $IsWindows = ([System.Environment]::OSVersion.Platform -eq \"Win32NT\")
      $IsLinux = ([System.Environment]::OSVersion.Platform -eq \"Unix\")
  }

  Function Invoke-CustomCommand
  {
      Param (
          $commandPath,
          $commandArguments,
          $workingDir = (Get-Location),
          $path = @()
      )

      $path += $env:PATH
      $newPath = $path -join [IO.Path]::PathSeparator

      $pinfo = New-Object System.Diagnostics.ProcessStartInfo
      $pinfo.FileName = $commandPath
      $pinfo.WorkingDirectory = $workingDir
      $pinfo.RedirectStandardError = $true
      $pinfo.RedirectStandardOutput = $true
      $pinfo.UseShellExecute = $false
      $pinfo.Arguments = $commandArguments
      $pinfo.EnvironmentVariables[\"PATH\"] = $newPath
      $p = New-Object System.Diagnostics.Process
      $p.StartInfo = $pinfo
      $p.Start() | Out-Null
      $p.WaitForExit()
      $executionResults = [pscustomobject]@{
          StdOut = $p.StandardOutput.ReadToEnd()
          StdErr = $p.StandardError.ReadToEnd()
          ExitCode = $p.ExitCode
      }

      return $executionResults

  }

  function Write-Results
  {
      param (
          $results
      )

      if (![String]::IsNullOrWhiteSpace($results.StdOut))
      {
          Write-Verbose $results.StdOut
      }
      if (![String]::IsNullOrWhiteSpace($results.StdErr))
      {
          Write-Verbose $results.StdErr
      }
  }

  function Install-App
  {
      param (
          $app,
          $versionArgument,
          $download,
          $downloadFileName,
          $downloadBinary
      )

      Try
      {
          if ($versionArgument -is [array])
          {
              $results = Invoke-CustomCommand $app $versionArgument
          } else {
              $results = Invoke-CustomCommand $app @($versionArgument)
          }
          if ($results.ExitCode -ne 0)
          {
              throw \"Exit code was \" + $results.ExitCode
          }
          return $app
      }
      Catch
      {
          # Ignore the error, we assume the app does not exist
      }

      $fileWithoutExtenion = [System.IO.Path]::GetFileNameWithoutExtension($downloadFileName)
      $extension = [System.IO.Path]::GetExtension($downloadFileName)

      Write-Host \"Downloading $download\"
      Invoke-WebRequest -Uri $download -OutFile $downloadFileName

      if ($extension -eq \".zip\")
      {
          Write-Host \"Extracting $downloadFileName\"
          New-Item -ItemType Directory -Path $fileWithoutExtenion | Out-Null
          Expand-Archive -Path $downloadFileName -DestinationPath $fileWithoutExtenion

          $binary = Join-Path -Path $fileWithoutExtenion -ChildPath $downloadBinary
          $results = Invoke-CustomCommand $binary @($versionArgument)
          Write-Results $results
          if ($results.ExitCode -ne 0)
          {
              throw \"Installed app failed to execute \" + $binary + \". Returned \" + $results.ExitCode
          }
          return $binary
      }
      elseif ($extension -eq \".gz\")
      {
          Write-Host \"Extracting $downloadFileName\"
          $extractedFile = [System.IO.Path]::GetFileNameWithoutExtension($downloadFileName)
          $extractedDir = [System.IO.Path]::GetFileNameWithoutExtension($extractedFile)
          New-Item -ItemType Directory -Path $extractedDir | Out-Null

          $results = Invoke-CustomCommand \"tar\" @(\"xzf\", $downloadFileName, \"-C\", $extractedDir)
          Write-Results $results
          if ($results.ExitCode -ne 0)
          {
              throw \"Failed to extract file \" + $results.ExitCode
          }

          $binary = Join-Path -Path $extractedDir -ChildPath $downloadBinary
          $results = Invoke-CustomCommand $binary @($versionArgument)
          Write-Results $results
          if ($results.ExitCode -ne 0)
          {
              throw \"Installed app failed to execute \" + $binary + \". Returned \" + $results.ExitCode
          }
          return $binary
      }
      else
      {
          # We likely have to make a downloaded binary executable
          if ($IsLinux)
          {
              $results = Invoke-CustomCommand \"chmod\" @(\"+x\", $downloadFileName)
              Write-Results $results
              if ($results.ExitCode -ne 0)
              {
                  throw \"Failed to make download executable\"
              }
          }

          $results = Invoke-CustomCommand $downloadFileName @($versionArgument)
          Write-Results $results
          if ($results.ExitCode -ne 0)
          {
              throw \"Installed app failed to execute \" + $downloadFileName + \". Returned \" + $results.ExitCode
          }
          return $downloadFileName
      }
  }

  function Install-CustomModule
  {
      param (
          $module
      )

      if (!(Get-Module -ListAvailable -Name $module))
      {
          Install-Module -Scope CurrentUser -Force $module
      }
  }

  function Install-Eksctl
  {
      if ($IsWindows)
      {
          return Install-App \"eksctl.exe\" \"version\" \"https://github.com/eksctl-io/eksctl/releases/latest/download/eksctl_Windows_amd64.zip\" \"eksctl.zip\" \"eksctl.exe\"
      }
      elseif ($IsLinux)
      {
          return Install-App \"eksctl\" \"version\" \"https://github.com/eksctl-io/eksctl/releases/latest/download/eksctl_Linux_amd64.tar.gz\" \"eksctl.tar.gz\" \"eksctl\"
      }

      throw \"Unexpected operation system\"
  }

  function Install-IamAuthenticator
  {
      if ($IsWindows)
      {
          return Install-App \"aws-iam-authenticator.exe\" \"version\" \"https://github.com/kubernetes-sigs/aws-iam-authenticator/releases/download/v0.5.9/aws-iam-authenticator_0.5.9_windows_amd64.exe\" \"aws-iam-authenticator.exe\" \"aws-iam-authenticator.exe\"
      }
      elseif ($IsLinux)
      {
          return Install-App \"aws-iam-authenticator\" \"version\" \"https://github.com/kubernetes-sigs/aws-iam-authenticator/releases/download/v0.5.9/aws-iam-authenticator_0.5.9_linux_amd64\" \"aws-iam-authenticator\" \"aws-iam-authenticator\"
      }

      throw \"Unexpected operation system\"
  }

  function Install-Helm
  {
      if ($IsWindows)
      {
          return Install-App \"helm\" \"version\" \"https://get.helm.sh/helm-v3.12.3-windows-amd64.zip\" \"helm.zip\" \"windows-amd64/helm.exe\"
      }
      elseif ($IsLinux)
      {
          return Install-App \"helm\" \"version\" \"https://get.helm.sh/helm-v3.12.3-linux-amd64.tar.gz\" \"helm.tar.gz\" \"linux-amd64/helm\"
      }

      throw \"Unexpected operation system\"
  }

  function Install-Kubectl
  {
      if ($IsWindows)
      {
          return Install-App \"kubectl\" @(\"version\", \"--client=true\") \"https://dl.k8s.io/release/v1.28.2/bin/windows/amd64/kubectl.exe\" \"kubectl.exe\" \"kubectl.exe\"
      }
      elseif ($IsLinux)
      {
          return Install-App \"kubectl\" @(\"version\", \"--client=true\") \"https://dl.k8s.io/release/v1.28.2/bin/linux/amd64/kubectl\" \"kubectl\" \"kubectl\"
      }

      throw \"Unexpected operation system\"
  }

  function Write-EksConfig
  {
      param (
          $clusterName,
          $clusterRegion
      )

      Set-Content -Path \"cluster.yaml\" -Value @\"
  apiVersion: eksctl.io/v1alpha5
  kind: ClusterConfig

  metadata:
    name: $clusterName
    region: $clusterRegion

  # A regular node group is required for NGINX
  nodeGroups:
    - name: ng-1
      instanceType: t3a.small
      desiredCapacity: 1
      volumeSize: 80

  fargateProfiles:
    - name: fp-default
      selectors:
        # All workloads in the \"default\" Kubernetes namespace will be
        # scheduled onto Fargate:
        - namespace: default
        # All workloads in the \"kube-system\" Kubernetes namespace will be
        # scheduled onto Fargate:
        - namespace: kube-system
    - name: fp-development
      selectors:
        - namespace: development
    - name: fp-test
      selectors:
        - namespace: test
    - name: fp-production
      selectors:
        - namespace: production
  \"@
  }

  Install-CustomModule powershell-yaml

  $clusterName = $OctopusParameters[\"AWS.EKS.Name\"]
  $clusterRegion = $OctopusParameters[\"AWS.EKS.Region\"]
  $awsAccountVariable = $OctopusParameters[\"Octopus.Action.AwsAccount.Variable\"]
  $awsAccount = $OctopusParameters[$awsAccountVariable]
  $environment = $OctopusParameters[\"Octopus.Environment.Name\"]
  $sortOrder = $OctopusParameters[\"Octopus.Environment.SortOrder\"]

  # When multiple environments share a cluster, we want to make sure eksctl doesn't attempt to
  # create the same cluster at the same time.
  $sleep = ([int]$sortOrder - 10) * 5

  # Sanity check in the case of existing environments
  if ($sleep -lt 0) {
      $sleep = 0
  }
  Write-Host \"Sleeping for $sleep seconds\"
  Start-Sleep -Seconds $sleep

  Install-IamAuthenticator | Out-Null
  $helm = Install-Helm
  $kubectl = Install-Kubectl
  $eksctl = Install-Eksctl
  Write-EksConfig $clusterName $clusterRegion
  $results = Invoke-CustomCommand $eksctl @(\"get\", \"cluster\", \"--name\", $clusterName, \"--region\", $clusterRegion) -Path @((Get-Location))
  if ($results.ExitCode -eq 0)
  {
      Write-Host \"Getting cluster details\"
      $result = Invoke-CustomCommand $eksctl @(\"utils\", \"write-kubeconfig\", \"--cluster\", $clusterName, \"--region\", $clusterRegion, \"--kubeconfig\", \"eks-config.yaml\") -Path @((Get-Location))
      Write-Results $result
  }
  else
  {
      Write-Host \"Creating cluster - this can take a while\"
      $result = Invoke-CustomCommand $eksctl @(\"create\", \"cluster\", \"-f\", \"cluster.yaml\", \"--kubeconfig\", 'eks-config.yaml') -Path @((Get-Location))
      Write-Results $result
  }

  # https://kubernetes.github.io/ingress-nginx/deploy/#aws
  $result = Invoke-CustomCommand $kubectl @(\"apply\", \"-f\", \"https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.8.2/deploy/static/provider/aws/deploy.yaml\", \"--kubeconfig\", \"eks-config.yaml\") -Path @((Get-Location))

  Write-Results $result

  $kubeConfig = ConvertFrom-Yaml (Get-Content eks-config.yaml -Raw)

  New-OctopusKubernetesTarget `
      -name \"$clusterName $($environment.ToLower())\" `
      -octopusRoles \"EKS_Reference_Cluster,Kubernetes\" `
      -clusterUrl $kubeConfig.clusters[0].cluster.server `
      -octopusAccountIdOrName $awsAccount `
      -clusterName $clusterName `
      -namespace $($environment -replace '[^A-Za-z0-9]', '_').ToLower() `
      -updateIfExisting `
      -skipTlsVerification True
  EOT
  variable_script                    = <<-EOT
  Set-OctopusVariable -name \"OctopusEnvironmentName\" -value $OctopusParameters[\"Octopus.Environment.Name\"]
  EOT
  orchestration_project_script       = <<-EOT
  # If we are deploying to the feature branch environment, the \"Kubernetes.Namespace\" variable is defined,
  # and it is passed down as a prompted variable. Otherwise, pass down a placeholder that is not used.
  $value = if ([string]::IsNullOrWhitespace($OctopusParameters[\"Kubernetes.Namespace\"])) {$($OctopusParameters[\"Octopus.Environment.Name\"] -replace '[^A-Za-z0-9]', '_').ToLower()} else {$OctopusParameters[\"Kubernetes.Namespace\"]}
  Set-OctopusVariable -name \"KubernetesNamespaceValue\" -value $value

  # Define the deployment condition used by the \"Deploy a release\" steps.
  # Mainline deployments ignore existing deployments. Feature branch deployments are always redeployed.
  $deploymentCondition = if ([string]::IsNullOrWhitespace($OctopusParameters[\"Kubernetes.Namespace\"])) {\"IfNotCurrentVersion\"} else {\"Always\"}
  Set-OctopusVariable -name \"DeploymentCondition\" -value $deploymentCondition
  EOT
  smoke_test                         = <<-EOT
  for i in {1..30}
  do
      HOSTNAME=$(kubectl get ingress #{Kubernetes.Ingress.Name} -o json -n #{Kubernetes.Namespace} | jq -r '.status.loadBalancer.ingress[0].hostname')
      if [[ -n \"$${HOSTNAME}\" && \"$${HOSTNAME}\" != \"null\" ]]
      then
          break
      fi
      echo \"Waiting for ingress hostname\"
      sleep 10
  done

  # Load balancers can take a minute or so before their DNS is propagated.
  # A status code of 000 means curl could not resolve the DNS name, so we wait for a bit until DNS is updated.
  write_highlight \"Testing [http://$${HOSTNAME}#{Kubernetes.App.HealthCheck}](http://$${HOSTNAME}#{Kubernetes.App.HealthCheck})\"
  echo \"Waiting for DNS to propagate. This can take a while for a new load balancer.\"
  for i in {1..30}
  do
    CODE=$(curl -o /dev/null -s -w \"%%{http_code}\
\" http://$${HOSTNAME}#{Kubernetes.App.HealthCheck})
    if [[ \"$${CODE}\" == \"200\" ]]
    then
      break
    fi
    echo \"Waiting for DNS name to be resolvable and for service to respond\"
    sleep 10
  done

  echo \"response code: $${CODE}\"
  if [[ \"$${CODE}\" == \"200\" ]]
  then
      echo \"success\"
      exit 0
  else
      echo \"error\"
      exit 1
  fi
  EOT
  security_scan_script               = <<-EOT
  echo \"Pulling Trivy Docker Image\"
  echo \"##octopus[stdout-verbose]\"
  docker pull aquasec/trivy
  echo \"##octopus[stdout-default]\"

  echo \"Installing umoci\"
  echo \"##octopus[stdout-verbose]\"
  # Install umoci
  if ! which umoci
  then
    curl -o umoci -L https://github.com/opencontainers/umoci/releases/latest/download/umoci.amd64 2>&1
    chmod +x umoci
  fi
  echo \"##octopus[stdout-default]\"

  echo \"Extracting Application Docker Image\"
  echo \"##octopus[stdout-verbose]\"
  # Download and extract the docker image
  # https://manpages.ubuntu.com/manpages/jammy/man1/umoci-raw-unpack.1.html
  docker pull quay.io/skopeo/stable:latest 2>&1
  docker run -v $(pwd):/output quay.io/skopeo/stable:latest copy docker://#{Octopus.Action[Deploy Container].Package[web].PackageId}:#{Octopus.Action[Deploy Container].Package[web].PackageVersion} oci:/output/image:latest 2>&1
  ./umoci unpack --image image --rootless bundle 2>&1
  echo \"##octopus[stdout-default]\"

  TIMESTAMP=$(date +%s%3N)
  SUCCESS=0
  for x in $(find . -name bom.json -type f -print); do
      echo \"Scanning $${x}\"

      # Delete any existing report file
      if [[ -f \"$PWD/depscan-bom.json\" ]]; then
        rm \"$PWD/depscan-bom.json\"
      fi

      # Generate the report, capturing the output, and ensuring $? is set to the exit code
      OUTPUT=$(bash -c \"docker run --rm -v \\\"$PWD/$${x}:/app/$${x}\\\" aquasec/trivy sbom \\\"/app/$${x}\\\"; exit \\$?\" 2>&1)

      # Success is set to 1 if the exit code is not zero
      if [[ $? -ne 0 ]]; then
          SUCCESS=1
      fi

      # Print the output stripped of ANSI colour codes
      echo -e \"$${OUTPUT}\" | sed 's/\\x1b\\[[0-9;]*m//g'
  done

  # Cleanup
  for i in {1..10}
  do
      chmod -R +rw bundle &> /dev/null
      rm -rf bundle &> /dev/null
      if [[ $? == 0 ]]; then break; fi
      echo \"Attempting to clean up files\"
      sleep 1
  done

  set_octopusvariable \"VerificationResult\" $SUCCESS

  if [[ $SUCCESS -ne 0 ]]; then
    >&2 echo \"Critical vulnerabilities were detected\"
  fi

  exit 0
  EOT
}
#endregion

#region Provider
variable \"octopus_server\" {
  type        = string
  nullable    = false
  sensitive   = false
  description = \"The URL of the Octopus server e.g. https://myinstance.octopus.app.\"
  default     = \"#{Octopus.Web.ServerUri}\"
}

variable \"octopus_apikey\" {
  type        = string
  nullable    = false
  sensitive   = true
  description = \"The API key used to access the Octopus server. See https://octopus.com/docs/octopus-rest-api/how-to-create-an-api-key for details on creating an API key.\"
}

variable \"octopus_space_id\" {
  type        = string
  nullable    = false
  sensitive   = false
  description = \"The ID of the Octopus space to populate.\"
  default     = \"#{Octopus.Space.Id}\"
}

provider \"octopusdeploy\" {
  address  = var.octopus_server
  api_key  = var.octopus_apikey
  space_id = var.octopus_space_id
}
#endregion

#region Environments
data \"octopusdeploy_environments\" \"environment_development\" {
  ids          = null
  partial_name = \"Development\"
  skip         = 0
  take         = 1
}

resource \"octopusdeploy_environment\" \"environment_development\" {
  count                        = length(data.octopusdeploy_environments.environment_development.environments) == 0 ? 1 : 0
  name                         = \"Development\"
  description                  = \"\"
  allow_dynamic_infrastructure = true
  use_guided_failure           = true
  sort_order                   = 10

  jira_extension_settings {
    environment_type = \"development\"
  }

  jira_service_management_extension_settings {
    is_enabled = false
  }

  servicenow_extension_settings {
    is_enabled = false
  }
}

data \"octopusdeploy_environments\" \"environment_test\" {
  ids          = null
  partial_name = \"Test\"
  skip         = 0
  take         = 1
}

resource \"octopusdeploy_environment\" \"environment_test\" {
  count                        = length(data.octopusdeploy_environments.environment_test.environments) == 0 ? 1 : 0
  name                         = \"Test\"
  description                  = \"\"
  allow_dynamic_infrastructure = true
  use_guided_failure           = true
  sort_order                   = 12

  jira_extension_settings {
    environment_type = \"testing\"
  }

  jira_service_management_extension_settings {
    is_enabled = false
  }

  servicenow_extension_settings {
    is_enabled = false
  }
}

data \"octopusdeploy_environments\" \"environment_production\" {
  ids          = null
  partial_name = \"Production\"
  skip         = 0
  take         = 1
}

resource \"octopusdeploy_environment\" \"environment_production\" {
  count                        = length(data.octopusdeploy_environments.environment_production.environments) == 0 ? 1 : 0
  name                         = \"Production\"
  description                  = \"\"
  allow_dynamic_infrastructure = true
  use_guided_failure           = true
  sort_order                   = 13

  jira_extension_settings {
    environment_type = \"production\"
  }

  jira_service_management_extension_settings {
    is_enabled = false
  }

  servicenow_extension_settings {
    is_enabled = false
  }
}

data \"octopusdeploy_environments\" \"environment_security\" {
  ids          = null
  partial_name = \"Security\"
  skip         = 0
  take         = 1
}

resource \"octopusdeploy_environment\" \"environment_security\" {
  count                        = length(data.octopusdeploy_environments.environment_security.environments) == 0 ? 1 : 0
  name                         = \"Security\"
  description                  = \"\"
  allow_dynamic_infrastructure = true
  use_guided_failure           = false
  sort_order                   = 14

  jira_extension_settings {
    environment_type = \"production\"
  }

  jira_service_management_extension_settings {
    is_enabled = false
  }

  servicenow_extension_settings {
    is_enabled = false
  }
}

data \"octopusdeploy_environments\" \"environment_sync\" {
  ids          = null
  partial_name = \"Sync\"
  skip         = 0
  take         = 1
}

resource \"octopusdeploy_environment\" \"environment_sync\" {
  count                        = length(data.octopusdeploy_environments.environment_sync.environments) == 0 ? 1 : 0
  name                         = \"Sync\"
  description                  = \"\"
  allow_dynamic_infrastructure = true
  use_guided_failure           = false
  sort_order                   = 15

  jira_extension_settings {
    environment_type = \"development\"
  }

  jira_service_management_extension_settings {
    is_enabled = false
  }

  servicenow_extension_settings {
    is_enabled = false
  }
}

data \"octopusdeploy_environments\" \"environment_featurebranch\" {
  ids          = null
  partial_name = \"Feature Branch\"
  skip         = 0
  take         = 1
}

resource \"octopusdeploy_environment\" \"environment_featurebranch\" {
  count                        = length(data.octopusdeploy_environments.environment_featurebranch.environments) == 0 ? 1 : 0
  name                         = \"Feature Branch\"
  description                  = \"\"
  allow_dynamic_infrastructure = true
  use_guided_failure           = false
  sort_order                   = 11

  jira_extension_settings {
    environment_type = \"development\"
  }

  jira_service_management_extension_settings {
    is_enabled = false
  }

  servicenow_extension_settings {
    is_enabled = false
  }
}

data \"octopusdeploy_lifecycles\" \"featurebranch\" {
  ids          = []
  partial_name = \"Feature Branch\"
  skip         = 0
  take         = 1
}

resource \"octopusdeploy_lifecycle\" \"lifecycle_featurebranch\" {
  count       = length(data.octopusdeploy_lifecycles.featurebranch.lifecycles) == 0 ? 1 : 0
  name        = \"Feature Branch\"
  description = \"\"

  phase {
    automatic_deployment_targets = []
    optional_deployment_targets  = [
      local.featurebranch_environment_id
    ]
    name                                  = \"Feature Branch\"
    is_optional_phase                     = false
    minimum_environments_before_promotion = 0
  }

  release_retention_policy {
    quantity_to_keep    = 3
    should_keep_forever = false
    unit                = \"Days\"
  }

  tentacle_retention_policy {
    quantity_to_keep    = 3
    should_keep_forever = false
    unit                = \"Days\"
  }
}

data \"octopusdeploy_lifecycles\" \"sync\" {
  ids          = []
  partial_name = \"Sync\"
  skip         = 0
  take         = 1
}

resource \"octopusdeploy_lifecycle\" \"sync\" {
  count       = length(data.octopusdeploy_lifecycles.sync.lifecycles) == 0 ? 1 : 0
  name        = \"Sync\"
  description = \"\"

  phase {
    automatic_deployment_targets = []
    optional_deployment_targets  = [
      local.sync_environment_id
    ]
    name                                  = \"Sync\"
    is_optional_phase                     = false
    minimum_environments_before_promotion = 0
  }

  release_retention_policy {
    quantity_to_keep    = 3
    should_keep_forever = false
    unit                = \"Days\"
  }

  tentacle_retention_policy {
    quantity_to_keep    = 3
    should_keep_forever = false
    unit                = \"Days\"
  }
}

data \"octopusdeploy_lifecycles\" \"devsecops\" {
  ids          = []
  partial_name = \"DevSecOps\"
  skip         = 0
  take         = 1
}

data \"octopusdeploy_lifecycles\" \"application\" {
  ids          = []
  partial_name = \"Application\"
  skip         = 0
  take         = 1
}

resource \"octopusdeploy_lifecycle\" \"lifecycle_devsecops\" {
  count       = length(data.octopusdeploy_lifecycles.devsecops.lifecycles) == 0 ? 1 : 0
  name        = \"DevSecOps\"
  description = \"\"

  phase {
    automatic_deployment_targets = []
    optional_deployment_targets  = [
      local.development_environment_id
    ]
    name                                  = \"Development\"
    is_optional_phase                     = false
    minimum_environments_before_promotion = 0
  }
  phase {
    automatic_deployment_targets = []
    optional_deployment_targets  = [
      local.featurebranch_environment_id
    ]
    name                                  = \"Feature Branch\"
    is_optional_phase                     = true
    minimum_environments_before_promotion = 0
  }
  phase {
    automatic_deployment_targets = []
    optional_deployment_targets  = [
      local.test_environment_id
    ]
    name                                  = \"Test\"
    is_optional_phase                     = false
    minimum_environments_before_promotion = 0
  }
  phase {
    automatic_deployment_targets = []
    optional_deployment_targets  = [
      local.production_environment_id
    ]
    name                                  = \"Production\"
    is_optional_phase                     = false
    minimum_environments_before_promotion = 0
  }
  phase {
    automatic_deployment_targets = [
      local.security_environment_id
    ]
    optional_deployment_targets           = []
    name                                  = \"Security\"
    is_optional_phase                     = false
    minimum_environments_before_promotion = 0
  }

  release_retention_policy {
    quantity_to_keep    = 3
    should_keep_forever = false
    unit                = \"Days\"
  }

  tentacle_retention_policy {
    quantity_to_keep    = 3
    should_keep_forever = false
    unit                = \"Days\"
  }
}

resource \"octopusdeploy_lifecycle\" \"lifecycle_application\" {
  count       = length(data.octopusdeploy_lifecycles.application.lifecycles) == 0 ? 1 : 0
  name        = \"Application\"
  description = \"\"

  phase {
    automatic_deployment_targets = []
    optional_deployment_targets  = [
      local.development_environment_id
    ]
    name                                  = \"Development\"
    is_optional_phase                     = false
    minimum_environments_before_promotion = 0
  }
  phase {
    automatic_deployment_targets = []
    optional_deployment_targets  = [
      local.featurebranch_environment_id
    ]
    name                                  = \"Feature Branch\"
    is_optional_phase                     = true
    minimum_environments_before_promotion = 0
  }
  phase {
    automatic_deployment_targets = []
    optional_deployment_targets  = [
      local.test_environment_id
    ]
    name                                  = \"Test\"
    is_optional_phase                     = false
    minimum_environments_before_promotion = 0
  }
  phase {
    automatic_deployment_targets = []
    optional_deployment_targets  = [
      local.production_environment_id
    ]
    name                                  = \"Production\"
    is_optional_phase                     = false
    minimum_environments_before_promotion = 0
  }

  release_retention_policy {
    quantity_to_keep    = 3
    should_keep_forever = false
    unit                = \"Days\"
  }

  tentacle_retention_policy {
    quantity_to_keep    = 3
    should_keep_forever = false
    unit                = \"Days\"
  }
}
#endregion

#region Feeds

data \"octopusdeploy_feeds\" \"project\" {
  feed_type = \"OctopusProject\"
  ids       = []
  skip      = 0
  take      = 1
}

data \"octopusdeploy_feeds\" \"bitnami\" {
  feed_type    = \"Helm\"
  ids          = []
  partial_name = \"Bitnami\"
  skip         = 0
  take         = 1
}


resource \"octopusdeploy_helm_feed\" \"feed_helm\" {
  count                                = length(data.octopusdeploy_feeds.bitnami.feeds) == 0 ? 1 : 0
  name                                 = \"Bitnami\"
  feed_uri                             = \"https://repo.vmware.com/bitnami-files/\"
  package_acquisition_location_options = [\"ExecutionTarget\", \"NotAcquired\"]
}

data \"octopusdeploy_feeds\" \"dockerhub\" {
  feed_type    = \"Docker\"
  ids          = []
  partial_name = \"Docker Hub\"
  skip         = 0
  take         = 1
}

variable \"feed_docker_hub_username\" {
  type        = string
  nullable    = false
  sensitive   = true
  description = \"The username used by the feed Docker Hub\"
}

variable \"feed_docker_hub_password\" {
  type        = string
  nullable    = false
  sensitive   = true
  description = \"The password used by the feed Docker Hub\"
}

resource \"octopusdeploy_docker_container_registry\" \"docker_hub\" {
  count                                = length(data.octopusdeploy_feeds.dockerhub.feeds) == 0 ? 1 : 0
  name                                 = \"Docker Hub\"
  password                             = var.feed_docker_hub_password
  username                             = var.feed_docker_hub_username
  api_version                          = \"v1\"
  feed_uri                             = \"https://index.docker.io\"
  package_acquisition_location_options = [\"ExecutionTarget\", \"NotAcquired\"]
}

data \"octopusdeploy_feeds\" \"sales_maven_feed\" {
  feed_type    = \"Maven\"
  ids          = []
  partial_name = \"Sales Maven Feed\"
  skip         = 0
  take         = 1
}

resource \"octopusdeploy_maven_feed\" \"feed_sales_maven_feed\" {
  count                                = length(data.octopusdeploy_feeds.sales_maven_feed.feeds) == 0 ? 1 : 0
  name                                 = \"Sales Maven Feed\"
  feed_uri                             = \"https://octopus-sales-public-maven-repo.s3.ap-southeast-2.amazonaws.com/snapshot\"
  package_acquisition_location_options = [\"Server\", \"ExecutionTarget\"]
  download_attempts                    = 3
  download_retry_backoff_seconds       = 20
}

data \"octopusdeploy_feeds\" \"github_feed\" {
  feed_type    = \"GitHub\"
  ids          = []
  partial_name = \"Github Releases\"
  skip         = 0
  take         = 1
}

resource \"octopusdeploy_github_repository_feed\" \"github_feed\" {
  count                          = length(data.octopusdeploy_feeds.github_feed.feeds) == 0 ? 1 : 0
  download_attempts              = 1
  download_retry_backoff_seconds = 30
  feed_uri                       = \"https://api.github.com\"
  name                           = \"Github Releases\"
}
#endregion

#region Library Variable Sets
data \"octopusdeploy_library_variable_sets\" \"this_instance\" {
  partial_name = \"This Instance\"
  skip         = 0
  take         = 1
}

resource \"octopusdeploy_library_variable_set\" \"this_instance\" {
  count       = length(data.octopusdeploy_library_variable_sets.this_instance.library_variable_sets) == 0 ? 1 : 0
  name        = \"This Instance\"
  description = \"Credentials used to interact with this Octopus instance\"
}

resource \"octopusdeploy_variable\" \"octopus_admin_api_key\" {
  count           = length(data.octopusdeploy_library_variable_sets.this_instance.library_variable_sets) == 0 ? 1 : 0
  name            = \"Octopus.ApiKey\"
  type            = \"Sensitive\"
  description     = \"Octopus API Key\"
  is_sensitive    = true
  is_editable     = true
  owner_id        = octopusdeploy_library_variable_set.this_instance[0].id
  sensitive_value = var.octopus_apikey
}

data \"octopusdeploy_library_variable_sets\" \"github\" {
  partial_name = \"GitHub\"
  skip         = 0
  take         = 1
}

resource \"octopusdeploy_library_variable_set\" \"github\" {
  count       = length(data.octopusdeploy_library_variable_sets.github.library_variable_sets) == 0 ? 1 : 0
  name        = \"GitHub\"
  description = \"Credentials used to interact with GitHub\"
}

variable \"github_access_token\" {
  type        = string
  nullable    = false
  sensitive   = true
  description = \"The GitHub access token\"
}

resource \"octopusdeploy_variable\" \"github_access_token\" {
  count           = length(data.octopusdeploy_library_variable_sets.github.library_variable_sets) == 0 ? 1 : 0
  name            = \"Git.Credentials.Password\"
  type            = \"Sensitive\"
  description     = \"The GitHub access token\"
  is_sensitive    = true
  is_editable     = true
  owner_id        = octopusdeploy_library_variable_set.github[0].id
  sensitive_value = var.github_access_token
}

data \"octopusdeploy_library_variable_sets\" \"docker\" {
  partial_name = \"Docker\"
  skip         = 0
  take         = 1
}

resource \"octopusdeploy_library_variable_set\" \"docker\" {
  count       = length(data.octopusdeploy_library_variable_sets.docker.library_variable_sets) == 0 ? 1 : 0
  name        = \"Docker\"
  description = \"Credentials used to interact with Docker\"
}

resource \"octopusdeploy_variable\" \"docker_username\" {
  count        = length(data.octopusdeploy_library_variable_sets.docker.library_variable_sets) == 0 ? 1 : 0
  name         = \"Docker.Credentials.Username\"
  type         = \"String\"
  description  = \"The docker username\"
  is_sensitive = false
  is_editable  = true
  owner_id     = octopusdeploy_library_variable_set.docker[0].id
  value        = var.feed_docker_hub_username
}

resource \"octopusdeploy_variable\" \"docker_password\" {
  count           = length(data.octopusdeploy_library_variable_sets.docker.library_variable_sets) == 0 ? 1 : 0
  name            = \"Docker.Credentials.Password\"
  type            = \"Sensitive\"
  description     = \"The docker password\"
  is_sensitive    = true
  is_editable     = true
  owner_id        = octopusdeploy_library_variable_set.docker[0].id
  sensitive_value = var.feed_docker_hub_password
}

data \"octopusdeploy_library_variable_sets\" \"aws\" {
  partial_name = \"AWS\"
  skip         = 0
  take         = 1
}

resource \"octopusdeploy_library_variable_set\" \"aws\" {
  count       = length(data.octopusdeploy_library_variable_sets.aws.library_variable_sets) == 0 ? 1 : 0
  name        = \"AWS\"
  description = \"Credentials used to interact with AWS\"
}

resource \"octopusdeploy_variable\" \"library_var_set_aws_access_key\" {
  count        = length(data.octopusdeploy_library_variable_sets.aws.library_variable_sets) == 0 ? 1 : 0
  name         = \"AWS.Credentials.AccessKey\"
  type         = \"String\"
  description  = \"AWS Access Key\"
  is_sensitive = false
  is_editable  = true
  owner_id     = octopusdeploy_library_variable_set.aws[0].id
  value        = var.account_aws_access_key
}

resource \"octopusdeploy_variable\" \"library_var_set_aws_secret_key\" {
  count           = length(data.octopusdeploy_library_variable_sets.aws.library_variable_sets) == 0 ? 1 : 0
  name            = \"AWS.Credentials.SecretKey\"
  type            = \"Sensitive\"
  description     = \"AWS Secret Key\"
  is_sensitive    = true
  is_editable     = true
  owner_id        = octopusdeploy_library_variable_set.aws[0].id
  sensitive_value = var.account_aws_secret_key
}
#endregion

#region Accounts

data \"octopusdeploy_accounts\" \"aws_account\" {
  account_type = \"AmazonWebServicesAccount\"
  ids          = []
  partial_name = \"AWS Account\"
  skip         = 0
  take         = 1
}

variable \"account_aws_access_key\" {
  type        = string
  nullable    = false
  sensitive   = false
  description = \"The AWS access key associated with the account AWS Account\"
}

variable \"account_aws_secret_key\" {
  type        = string
  nullable    = false
  sensitive   = true
  description = \"The AWS secret key associated with the account AWS Account\"
}

resource \"octopusdeploy_aws_account\" \"aws_account\" {
  count                             = length(data.octopusdeploy_accounts.aws_account.accounts) == 0 ? 1 : 0
  name                              = \"AWS Account\"
  description                       = \"\"
  environments                      = []
  tenant_tags                       = []
  tenants                           = []
  tenanted_deployment_participation = \"Untenanted\"
  access_key                        = var.account_aws_access_key
  secret_key                        = var.account_aws_secret_key
}

#endregion

#region Project Groups
data \"octopusdeploy_project_groups\" \"eks\" {
  ids          = []
  partial_name = \"EKS\"
  skip         = 0
  take         = 1
}

resource \"octopusdeploy_project_group\" \"project_group_eks\" {
  count       = length(data.octopusdeploy_project_groups.eks.project_groups) == 0 ? 1 : 0
  name        = \"EKS\"
  description = \"EKS projects.\"
}

data \"octopusdeploy_project_groups\" \"project_templates\" {
  ids          = []
  partial_name = \"Project Templates\"
  skip         = 0
  take         = 1
}

resource \"octopusdeploy_project_group\" \"project_group_project_templates\" {
  count       = length(data.octopusdeploy_project_groups.project_templates.project_groups) == 0 ? 1 : 0
  name        = \"Project Templates\"
  description = \"Sample code project generators\"
}
#endregion

#region Worker Pools

data \"octopusdeploy_worker_pools\" \"workerpool_hosted_ubuntu\" {
  partial_name = \"Hosted Ubuntu\"
  ids          = null
  skip         = 0
  take         = 1
}
#endregion

#region Projects

#region AWS Infrastructure
variable \"infrastructure_project_name\" {
  type    = string
  default = \"\"
}

data \"octopusdeploy_projects\" \"aws_infrastructure\" {
  cloned_from_project_id = \"\"
  ids                    = []
  is_clone               = true
  partial_name           = var.infrastructure_project_name == \"\" ? local.infrastructure_project_name : var.infrastructure_project_name
  skip                   = 0
  take                   = 1
}

resource \"octopusdeploy_project\" \"aws_infrastructure\" {
  count                                = length(data.octopusdeploy_projects.aws_infrastructure.projects) == 0 ? 1 : 0
  name                                 = var.infrastructure_project_name == \"\" ? local.infrastructure_project_name : var.infrastructure_project_name
  auto_create_release                  = false
  default_guided_failure_mode          = \"EnvironmentDefault\"
  default_to_skip_if_already_installed = false
  discrete_channel_release             = false
  is_disabled                          = false
  is_version_controlled                = true
  lifecycle_id                         = local.devops_lifecycle_id
  project_group_id                     = local.eks_project_group_id
  included_library_variable_sets       = []
  tenanted_deployment_participation    = \"Untenanted\"

  connectivity_policy {
    allow_deployments_to_no_targets = false
    exclude_unhealthy_targets       = false
    skip_machine_behavior           = \"None\"
  }

  versioning_strategy {
    template = \"\"
  }

  lifecycle {
    ignore_changes = [\"connectivity_policy\"]
  }
  description = \"AWS infrastrucutre runbooks\"
}

resource \"octopusdeploy_variable\" \"library_variable_set_variables_octopub_aws_account_1\" {
  count        = length(data.octopusdeploy_projects.aws_infrastructure.projects) == 0 ? 1 : 0
  owner_id     = octopusdeploy_project.aws_infrastructure[0].id
  value        = local.aws_account
  name         = \"AWS.Account\"
  type         = \"AmazonWebServicesAccount\"
  description  = \"\"
  is_sensitive = false
  depends_on   = []
}

resource \"octopusdeploy_variable\" \"aws_infrastructure_aws_eks_name_1\" {
  count        = length(data.octopusdeploy_projects.aws_infrastructure.projects) == 0 ? 1 : 0
  owner_id     = octopusdeploy_project.aws_infrastructure[0].id
  value        = \"octopus\"
  name         = \"AWS.EKS.Name\"
  type         = \"String\"
  is_sensitive = false

  prompt {
    description = \"EKS Cluster Name\"
    label       = \"EKS Cluster Name\"
    is_required = true
    display_settings {
      control_type = \"SingleLineText\"
    }
  }
}

resource \"octopusdeploy_variable\" \"aws_infrastructure_aws_eks_region_1\" {
  count        = length(data.octopusdeploy_projects.aws_infrastructure.projects) == 0 ? 1 : 0
  owner_id     = octopusdeploy_project.aws_infrastructure[0].id
  value        = \"ap-southeast-2\"
  name         = \"AWS.EKS.Region\"
  type         = \"String\"
  is_sensitive = false

  prompt {
    description = \"EKS Cluster Region\"
    label       = \"EKS Cluster Region\"
    is_required = true
    display_settings {
      control_type = \"SingleLineText\"
    }
  }
}

resource \"octopusdeploy_runbook\" \"runbook_create_eks_cluster\" {
  count             = length(data.octopusdeploy_projects.aws_infrastructure.projects) == 0 ? 1 : 0
  name              = \"🛠️ Create EKS Cluster\"
  project_id        = octopusdeploy_project.aws_infrastructure[0].id
  environment_scope = \"Specified\"
  environments      = [
    local.development_environment_id,
    local.test_environment_id,
    local.production_environment_id,
    local.featurebranch_environment_id,
  ]
  force_package_download      = false
  default_guided_failure_mode = \"EnvironmentDefault\"
  description                 = <<EOT
**Action**: Creates the EKS cluster.

**Affects**: No existing resources are affected. If the cluster exists, it is not modified.
EOT
  multi_tenancy_mode          = \"Untenanted\"

  retention_policy {
    quantity_to_keep    = 100
    should_keep_forever = false
  }

  connectivity_policy {
    allow_deployments_to_no_targets = true
    exclude_unhealthy_targets       = false
    skip_machine_behavior           = \"None\"
  }
}

resource \"octopusdeploy_runbook_process\" \"runbook_process_eks_create_eks_cluster\" {
  count      = length(data.octopusdeploy_projects.aws_infrastructure.projects) == 0 ? 1 : 0
  runbook_id = octopusdeploy_runbook.runbook_create_eks_cluster[0].id

  step {
    condition           = \"Success\"
    name                = \"Create EKS Cluster\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.AwsRunScript\"
      name                               = \"Create EKS Cluster\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"Octopus.Action.RunOnServer\"                = \"true\"
        \"Octopus.Action.Script.ScriptBody\"          = local.create_cluster_script
        \"Octopus.Action.AwsAccount.UseInstanceRole\" = \"False\"
        \"Octopus.Action.AwsAccount.Variable\"        = \"AWS.Account\"
        \"Octopus.Action.Aws.Region\"                 = \"#{AWS.EKS.Region}\"
        \"Octopus.Action.Script.ScriptSource\"        = \"Inline\"
        \"Octopus.Action.Aws.AssumeRole\"             = \"False\"
        \"Octopus.Action.Script.Syntax\"              = \"PowerShell\"
        \"OctopusUseBundledTooling\"                  = \"False\"
      }
      environments = [
        local.development_environment_id,
        local.test_environment_id,
        local.production_environment_id,
        local.featurebranch_environment_id,
      ]
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []

      container {
        feed_id = local.docker_hub_feed_id
        image   = \"octopuslabs/aws-workertools\"
      }
    }

    properties   = {}
    target_roles = []
  }

  step {
    condition           = \"Always\"
    name                = \"Feedback\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.Script\"
      name                               = \"Feedback\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"Octopus.Action.RunOnServer\"         = \"true\"
        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"
        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"
        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"
      }
      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = []
  }
}

resource \"octopusdeploy_runbook\" \"runbook_octopub_get_nodes\" {
  count             = length(data.octopusdeploy_projects.aws_infrastructure.projects) == 0 ? 1 : 0
  project_id        = octopusdeploy_project.aws_infrastructure[0].id
  name              = \"🛠️ Get Nodes\"
  environment_scope = \"Specified\"
  environments      = [
    local.development_environment_id,
    local.test_environment_id,
    local.production_environment_id,
  ]
  force_package_download      = false
  default_guided_failure_mode = \"Off\"
  description                 = <<EOT
**Action**: Returns the cluster nodes.

**Affects**: Nothing - this runbook makes no changes.
EOT
  multi_tenancy_mode          = \"Untenanted\"

  retention_policy {
    quantity_to_keep    = 100
    should_keep_forever = false
  }

  connectivity_policy {
    allow_deployments_to_no_targets = true
    exclude_unhealthy_targets       = false
    skip_machine_behavior           = \"None\"
  }
}

resource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_get_nodes\" {
  count      = length(data.octopusdeploy_projects.aws_infrastructure.projects) == 0 ? 1 : 0
  runbook_id = octopusdeploy_runbook.runbook_octopub_get_nodes[0].id

  step {
    condition           = \"Success\"
    name                = \"Get Nodes\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.KubernetesRunScript\"
      name                               = \"Get Nodes\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      worker_pool_variable               = \"\"
      properties                         = {
        \"K8SInspectCreateArtifact\"                      = \"False\"
        \"Octopus.Action.Script.ScriptBody\"              = \"<#\
    This script provides a general purpose method for querying Kubernetes resources. It supports common operations\
    like get, describe, logs and output formats like yaml and json. Output can be captured as artifacts.\
#>\
\
<#\
.Description\
Execute an application, capturing the output. Based on https://stackoverflow.com/a/33652732/157605\
#>\
Function Execute-Command ($commandPath, $commandArguments)\
{\
  Write-Host \\\"Executing: $commandPath $($commandArguments -join \\\" \\\")\\\"\
  \
  Try {\
    $pinfo = New-Object System.Diagnostics.ProcessStartInfo\
    $pinfo.FileName = $commandPath\
    $pinfo.RedirectStandardError = $true\
    $pinfo.RedirectStandardOutput = $true\
    $pinfo.UseShellExecute = $false\
    $pinfo.Arguments = $commandArguments\
    $p = New-Object System.Diagnostics.Process\
    $p.StartInfo = $pinfo\
    $p.Start() | Out-Null\
    [pscustomobject]@{\
        stdout = $p.StandardOutput.ReadToEnd()\
        stderr = $p.StandardError.ReadToEnd()\
        ExitCode = $p.ExitCode\
    }\
    $p.WaitForExit()\
  }\
  Catch {\
     exit\
  }\
}\
\
<#\
.Description\
Find any resource names that match a wildcard input if one was specified\
#>\
function Get-Resources() \
{\
    $names = $OctopusParameters[\\\"K8SInspectNames\\\"] -Split \\\"`n\\\" | % {$_.Trim()}\
    \
    if ($OctopusParameters[\\\"K8SInspectNames\\\"] -match '\\\\*' )\
    {\
        return Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", $OctopusParameters[\\\"K8SInspectResource\\\"])) |\
            # Select the stdout property from the execution\
            Select-Object -ExpandProperty stdout |\
            # Convert the output from JSON\
            ConvertFrom-JSON | \
            # Get the items object from the kubectl response\
            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\
            # Extract the name\
            % {$_.metadata.name} |\
            # Find any matching resources\
            ? {$k8sName = $_; ($names | ? {$k8sName -like $_}).Count -ne 0}\
    }\
    else\
    {\
        return $names\
    }\
}\
\
<#\
.Description\
Get the kubectl arguments for a given action\
#>\
function Get-KubectlVerb() \
{\
    switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\
    {\
        \\\"get json\\\" {return ,@(\\\"-o\\\", \\\"json\\\", \\\"get\\\")}\
        \\\"get yaml\\\" {return ,@(\\\"-o\\\", \\\"yaml\\\", \\\"get\\\")}\
        \\\"describe\\\" {return ,@(\\\"describe\\\")}\
        \\\"logs\\\" {return ,@(\\\"logs\\\")}\
        \\\"logs tail\\\" {return ,@(\\\"logs\\\", \\\"--tail\\\", \\\"100\\\")}\
        \\\"previous logs\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\")}\
        \\\"previous logs tail\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\", \\\"--tail\\\", \\\"100\\\")}\
        default {return ,@(\\\"get\\\")}\
    }\
}\
\
<#\
.Description\
Get an appropiate file extension based on the selected action\
#>\
function Get-ArtifactExtension() \
{\
   switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\
    {\
        \\\"get json\\\" {\\\"json\\\"}\
        \\\"get yaml\\\" {\\\"yaml\\\"}\
        default {\\\"txt\\\"}\
    }\
}\
\
if ($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"] -like \\\"*logs*\\\") \
{\
    if ( -not @($OctopusParameters[\\\"K8SInspectResource\\\"]) -like \\\"pod*\\\")\
    {\
        Write-Error \\\"Logs can only be returned for pods, not $($OctopusParameters[\\\"K8SInspectResource\\\"])\\\"\
    }\
    else\
    {\
        Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", \\\"pods\\\") + (Get-Resources)) |\
            # Select the stdout property from the execution\
            Select-Object -ExpandProperty stdout |\
            # Convert the output from JSON\
            ConvertFrom-JSON | \
            # Get the items object from the kubectl response\
            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\
            # Get the pod logs for each container\
            % {\
                $podDetails = $_\
                @{\
                    logs=$podDetails.spec.containers | % {$logs=\\\"\\\"} {$logs += (Select-Object -InputObject (Execute-Command kubectl ((Get-KubectlVerb) + @($podDetails.metadata.name, \\\"-c\\\", $_.name))) -ExpandProperty stdout)} {$logs}; \
                    name=$podDetails.metadata.name\
                }                \
            } |\
            # Write the output\
            % {Write-Host $_.logs; $_} |\
            # Optionally capture the artifact\
            % {\
                if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \
                {\
                    Set-Content -Path \\\"$($_.name).$(Get-ArtifactExtension)\\\" -Value $_.logs\
                    New-OctopusArtifact \\\"$($_.name).$(Get-ArtifactExtension)\\\"\
                }\
            }\
    }      \
}\
else\
{\
    Execute-Command kubectl ((Get-KubectlVerb) + @($OctopusParameters[\\\"K8SInspectResource\\\"]) + (Get-Resources)) |\
        % {Select-Object -InputObject $_ -ExpandProperty stdout} |\
        % {Write-Host $_; $_} |\
        % {\
            if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \
            {\
                Set-Content -Path \\\"output.$(Get-ArtifactExtension)\\\" -Value $_\
                New-OctopusArtifact \\\"output.$(Get-ArtifactExtension)\\\"\
            }\
        }\
}\
\"
        \"Octopus.Action.Script.ScriptSource\"            = \"Inline\"
        \"K8SInspectResource\"                            = \"node\"
        \"Octopus.Action.Script.Syntax\"                  = \"PowerShell\"
        \"Octopus.Action.KubernetesContainers.Namespace\" = \"#{if K8SInspectNamespace}#{K8SInspectNamespace}#{/if}#{unless K8SInspectNamespace}#{Octopus.Action.Kubernetes.Namespace}#{/unless}\"
        \"K8SInspectNames\"                               = \"*\"
        \"K8SInspectKubectlVerb\"                         = \"get\"
      }
      container {
        feed_id = local.docker_hub_feed_id
        image   = \"octopuslabs/k8s-workertools\"
      }
      environments = [
        local.development_environment_id,
        local.test_environment_id,
        local.production_environment_id,
      ]
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = [\"EKS_Reference_Cluster\"]
  }

  step {
    condition           = \"Always\"
    name                = \"Feedback\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.Script\"
      name                               = \"Feedback\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"Octopus.Action.RunOnServer\"         = \"true\"
        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"
        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"
        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"
      }
      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = []
  }
}

resource \"octopusdeploy_runbook\" \"runbook_delete_eks_cluster\" {
  count             = length(data.octopusdeploy_projects.aws_infrastructure.projects) == 0 ? 1 : 0
  name              = \"🗑️ Delete EKS Cluster\"
  project_id        = octopusdeploy_project.aws_infrastructure[0].id
  environment_scope = \"Specified\"
  environments      = [
    local.development_environment_id,
    local.test_environment_id,
    local.production_environment_id,
  ]
  force_package_download      = false
  default_guided_failure_mode = \"EnvironmentDefault\"
  description                 = <<EOT
**WARNING**: This is a destructive operation. All applications will are deleted, and the cluster is destroyed.

**Action**: Deletes the EKS cluster.

**Affects**: All applications installed into the Kubernetes cluster.
EOT
  multi_tenancy_mode          = \"Untenanted\"

  retention_policy {
    quantity_to_keep    = 100
    should_keep_forever = false
  }

  connectivity_policy {
    allow_deployments_to_no_targets = true
    exclude_unhealthy_targets       = false
    skip_machine_behavior           = \"None\"
  }
}

resource \"octopusdeploy_runbook_process\" \"runbook_process_aws_infrastructure_destroy_eks_cluster\" {
  count      = length(data.octopusdeploy_projects.aws_infrastructure.projects) == 0 ? 1 : 0
  runbook_id = octopusdeploy_runbook.runbook_delete_eks_cluster[0].id

  step {
    condition           = \"Success\"
    name                = \"Delete EKS Cluster\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.AwsRunScript\"
      name                               = \"Delete EKS Cluster\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = true
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"Octopus.Action.Aws.AssumeRole\"             = \"False\"
        \"OctopusUseBundledTooling\"                  = \"False\"
        \"Octopus.Action.Script.Syntax\"              = \"PowerShell\"
        \"Octopus.Action.AwsAccount.UseInstanceRole\" = \"False\"
        \"Octopus.Action.Script.ScriptBody\"          = \"eksctl delete cluster --name $OctopusParameters[\\\"AWS.EKS.Name\\\"]\"
        \"Octopus.Action.Aws.Region\"                 = \"#{AWS.EKS.Region}\"
        \"Octopus.Action.AwsAccount.Variable\"        = \"AWS.Account\"
        \"Octopus.Action.Script.ScriptSource\"        = \"Inline\"
        \"Octopus.Action.RunOnServer\"                = \"true\"
      }

      container {
        feed_id = local.docker_hub_feed_id
        image   = \"octopuslabs/aws-workertools\"
      }

      environments = [
        local.development_environment_id,
        local.test_environment_id,
        local.production_environment_id,
      ]
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = []
  }

  step {
    condition           = \"Always\"
    name                = \"Feedback\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.Script\"
      name                               = \"Feedback\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"Octopus.Action.RunOnServer\"         = \"true\"
        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"
        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"
        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"
      }
      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = []
  }
}
#endregion

#region Project Templates
variable \"project_template_project_name\" {
  type    = string
  default = \"\"
}

data \"octopusdeploy_projects\" \"docker_project_template\" {
  partial_name = var.project_template_project_name == \"\" ? local.project_template_project_name : var.project_template_project_name
  skip         = 0
  take         = 1
}

resource \"octopusdeploy_variable\" \"docker_project_template_git_organization\" {
  count        = length(data.octopusdeploy_projects.docker_project_template.projects) == 0 ? 1 : 0
  owner_id     = octopusdeploy_project.docker_project_template[0].id
  value        = \"\"
  name         = \"Git.Url.Organization\"
  type         = \"String\"
  description  = \"The GitHub organization to create the repo in.\"
  is_sensitive = false

  prompt {
    description = \"The Github organization where the repo will be created. This is the `owner` part of the URL `https://github.com/owner/myrepo`.\"
    label       = \"Github Organization\"
    is_required = true
    display_settings {
      control_type = \"SingleLineText\"
    }
  }

  scope {
    actions      = []
    channels     = []
    environments = [local.sync_environment_id]
    machines     = []
    roles        = null
    tenant_tags  = null
  }
}

resource \"octopusdeploy_variable\" \"docker_project_template_git_repo\" {
  count        = length(data.octopusdeploy_projects.docker_project_template.projects) == 0 ? 1 : 0
  owner_id     = octopusdeploy_project.docker_project_template[0].id
  value        = \"\"
  name         = \"Git.Url.Repo\"
  type         = \"String\"
  description  = \"The GitHub repo to create.\"
  is_sensitive = false

  prompt {
    description = \"The Github repo to be created. This is the `myrepo` part of the URL `https://github.com/owner/myrepo`.\"
    label       = \"Github Repo\"
    is_required = true
    display_settings {
      control_type = \"SingleLineText\"
    }
  }

  scope {
    actions      = []
    channels     = []
    environments = [local.sync_environment_id]
    machines     = []
    roles        = null
    tenant_tags  = null
  }
}

resource \"octopusdeploy_variable\" \"docker_project_template_image_name\" {
  count        = length(data.octopusdeploy_projects.docker_project_template.projects) == 0 ? 1 : 0
  owner_id     = octopusdeploy_project.docker_project_template[0].id
  value        = \"\"
  name         = \"Application.Docker.Image\"
  type         = \"String\"
  description  = \"The Docker image to create containing the new application.\"
  is_sensitive = false

  prompt {
    description = \"The Docker image to create containing the new application.\"
    label       = \"Docker Image\"
    is_required = true
    display_settings {
      control_type = \"SingleLineText\"
    }
  }

  scope {
    actions      = []
    channels     = []
    environments = [local.sync_environment_id]
    machines     = []
    roles        = null
    tenant_tags  = null
  }
}

resource \"octopusdeploy_variable\" \"docker_project_template_octopus_project\" {
  count        = length(data.octopusdeploy_projects.docker_project_template.projects) == 0 ? 1 : 0
  owner_id     = octopusdeploy_project.docker_project_template[0].id
  value        = \"\"
  name         = \"Application.Octopus.Project\"
  type         = \"String\"
  description  = \"The Octopus project to associate with the new application.\"
  is_sensitive = false

  prompt {
    description = \"The Octopus project to associate with the new application. A release is created in this project when the image is successfully built.\"
    label       = \"Octopus Project\"
    is_required = true
    display_settings {
      control_type = \"SingleLineText\"
    }
  }

  scope {
    actions      = []
    channels     = []
    environments = [local.sync_environment_id]
    machines     = []
    roles        = null
    tenant_tags  = null
  }
}

resource \"octopusdeploy_project\" \"docker_project_template\" {
  count                                = length(data.octopusdeploy_projects.docker_project_template.projects) == 0 ? 1 : 0
  name                                 = var.project_template_project_name == \"\" ? local.project_template_project_name : var.project_template_project_name
  auto_create_release                  = false
  default_guided_failure_mode          = \"Off\"
  default_to_skip_if_already_installed = false
  discrete_channel_release             = false
  is_disabled                          = false
  is_version_controlled                = false
  lifecycle_id                         = local.application_lifecycle_id
  project_group_id                     = local.project_templates_project_group_id
  included_library_variable_sets       = [
    local.this_instance_library_variable_set, local.github_library_variable_set, local.docker_library_variable_set
  ]
  tenanted_deployment_participation = \"Untenanted\"

  connectivity_policy {
    allow_deployments_to_no_targets = true
    exclude_unhealthy_targets       = false
    skip_machine_behavior           = \"None\"
  }

  versioning_strategy {
    template = \"#{Octopus.Version.LastMajor}.#{Octopus.Version.LastMinor}.#{Octopus.Version.NextPatch}\"
  }

  lifecycle {
    ignore_changes = []
  }
  description = <<EOT
Creates Project Templates.
EOT
}

resource \"octopusdeploy_runbook\" \"docker_project_template_create_nodejs_template\" {
  count                       = length(data.octopusdeploy_projects.docker_project_template.projects) == 0 ? 1 : 0
  name                        = \"📗 Create Template Github Node.js Project\"
  project_id                  = octopusdeploy_project.docker_project_template[0].id
  environment_scope           = \"Specified\"
  environments                = [local.sync_environment_id]
  force_package_download      = false
  default_guided_failure_mode = \"EnvironmentDefault\"
  description                 = \"This runbook populates a GitHub repo with a sample Node.js project and GitHub Actions Workflow that builds a Docker image, pushes it to DockerHub, and triggers the deployment of the associated Octopus project in the Development environment. \
\
**Action**: Creates a new GitHub repo (if it doesn't exist) and populates it with the output of a Yeoman generator.\
\
\
**Affects**: This will overwrite files in the target Git repo. Changes can be reverted with git.\"
  multi_tenancy_mode          = \"Untenanted\"

  retention_policy {
    quantity_to_keep    = 100
    should_keep_forever = false
  }

  connectivity_policy {
    allow_deployments_to_no_targets = true
    exclude_unhealthy_targets       = false
    skip_machine_behavior           = \"None\"
  }
}

resource \"octopusdeploy_runbook_process\" \"docker_project_template_create_nodejs_template\" {
  runbook_id = octopusdeploy_runbook.docker_project_template_create_nodejs_template[0].id
  count      = length(data.octopusdeploy_projects.docker_project_template.projects) == 0 ? 1 : 0

  step {
    condition           = \"Success\"
    name                = \"Get Variables\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.Script\"
      name                               = \"Get Variables\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"Octopus.Action.Script.ScriptBody\"   = \"# This is a workaround to the issue where octostache templates in the Terraform\
# project are replaced during deployment, when we actually want some variables\
# at run time.\
\
Set-OctopusVariable -name \\\"Project.Name\\\" -value $OctopusParameters[\\\"Octopus.Project.Name\\\"]\
Set-OctopusVariable -name \\\"Web.ServerUri\\\" -value $OctopusParameters[\\\"Octopus.Web.ServerUri\\\"]\
Set-OctopusVariable -name \\\"Space.Id\\\" -value $OctopusParameters[\\\"Octopus.Space.Id\\\"]\
Set-OctopusVariable -name \\\"Space.Name\\\" -value $OctopusParameters[\\\"Octopus.Space.Name\\\"]\"
        \"Octopus.Action.RunOnServer\"         = \"true\"
        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"
        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"
      }
      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = []
  }
  step {
    condition           = \"Success\"
    name                = \"Create Repo\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.Script\"
      name                               = \"Create Repo\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"CreateGithubRepo.Git.Url.Organization\"        = \"#{Git.Url.Organization}\"
        \"Octopus.Action.Script.Syntax\"                 = \"Python\"
        \"Octopus.Action.RunOnServer\"                   = \"true\"
        \"CreateGithubRepo.Git.Url.NewRepoNamePrefix\"   = \"\"
        \"CreateGithubRepo.Git.Credentials.AccessToken\" = \"#{Git.Credentials.Password}\"
        \"Octopus.Action.Script.ScriptBody\"             = \"# This script forks a GitHub repo. It creates a token from a GitHub App installation to avoid\
# having to use a regular user account.\
import subprocess\
import sys\
\
# Install our own dependencies\
subprocess.check_call([sys.executable, '-m', 'pip', 'install', 'jwt', '--disable-pip-version-check'])\
\
import json\
import subprocess\
import sys\
import os\
import urllib.request\
import base64\
import re\
import jwt\
import time\
import argparse\
import platform\
from urllib.request import urlretrieve\
\
# If this script is not being run as part of an Octopus step, setting variables is a noop\
if 'set_octopusvariable' not in globals():\
    def set_octopusvariable(variable, value):\
        pass\
\
# If this script is not being run as part of an Octopus step, return variables from environment variables.\
# Periods are replaced with underscores, and the variable name is converted to uppercase\
if \\\"get_octopusvariable\\\" not in globals():\
    def get_octopusvariable(variable):\
        return os.environ[re.sub('\\\\\\\\.', '_', variable.upper())]\
\
# If this script is not being run as part of an Octopus step, print directly to std out.\
if 'printverbose' not in globals():\
    def printverbose(msg):\
        print(msg)\
\
\
def printverbose_noansi(output):\
    \\\"\\\"\\\"\
    Strip ANSI color codes and print the output as verbose\
    :param output: The output to print\
    \\\"\\\"\\\"\
    output_no_ansi = re.sub(r'\\\\x1b\\\\[[0-9;]*m', '', output)\
    printverbose(output_no_ansi)\
\
\
def get_octopusvariable_quiet(variable):\
    \\\"\\\"\\\"\
    Gets an octopus variable, or an empty string if it does not exist.\
    :param variable: The variable name\
    :return: The variable value, or an empty string if the variable does not exist\
    \\\"\\\"\\\"\
    try:\
        return get_octopusvariable(variable)\
    except:\
        return ''\
\
\
def execute(args, cwd=None, env=None, print_args=None, print_output=printverbose_noansi, raise_on_non_zero=False,\
            append_to_path=None):\
    \\\"\\\"\\\"\
        The execute method provides the ability to execute external processes while capturing and returning the\
        output to std err and std out and exit code.\
    \\\"\\\"\\\"\
\
    my_env = os.environ.copy() if env is None else env\
\
    if append_to_path is not None:\
        my_env[\\\"PATH\\\"] = append_to_path + os.pathsep + my_env['PATH']\
\
    process = subprocess.Popen(args,\
                               stdout=subprocess.PIPE,\
                               stderr=subprocess.PIPE,\
                               stdin=open(os.devnull),\
                               text=True,\
                               cwd=cwd,\
                               env=my_env)\
    stdout, stderr = process.communicate()\
    retcode = process.returncode\
\
    if not retcode == 0 and raise_on_non_zero:\
        raise Exception('command returned exit code ' + retcode)\
\
    if print_args is not None:\
        print_output(' '.join(args))\
\
    if print_output is not None:\
        print_output(stdout)\
        print_output(stderr)\
\
    return stdout, stderr, retcode\
\
\
def init_argparse():\
    parser = argparse.ArgumentParser(\
        usage='%(prog)s [OPTION]',\
        description='Create a GitHub repo'\
    )\
    parser.add_argument('--new-repo-name', action='store',\
                        default=get_octopusvariable_quiet(\
                            'CreateGithubRepo.Git.Url.NewRepoName') or get_octopusvariable_quiet(\
                            'Git.Url.NewRepoName') or get_octopusvariable_quiet('Octopus.Project.Name'))\
    parser.add_argument('--new-repo-name-prefix', action='store',\
                        default=get_octopusvariable_quiet(\
                            'CreateGithubRepo.Git.Url.NewRepoNamePrefix') or get_octopusvariable_quiet(\
                            'Git.Url.NewRepoNamePrefix'))\
    parser.add_argument('--git-organization', action='store',\
                        default=get_octopusvariable_quiet(\
                            'CreateGithubRepo.Git.Url.Organization') or get_octopusvariable_quiet(\
                            'Git.Url.Organization'))\
    parser.add_argument('--github-app-id', action='store',\
                        default=get_octopusvariable_quiet(\
                            'CreateGithubRepo.GitHub.App.Id') or get_octopusvariable_quiet('GitHub.App.Id'))\
    parser.add_argument('--github-app-installation-id', action='store',\
                        default=get_octopusvariable_quiet(\
                            'CreateGithubRepo.GitHub.App.InstallationId') or get_octopusvariable_quiet(\
                            'GitHub.App.InstallationId'))\
    parser.add_argument('--github-app-private-key', action='store',\
                        default=get_octopusvariable_quiet(\
                            'CreateGithubRepo.GitHub.App.PrivateKey') or get_octopusvariable_quiet(\
                            'GitHub.App.PrivateKey'))\
    parser.add_argument('--github-access-token', action='store',\
                        default=get_octopusvariable_quiet(\
                            'CreateGithubRepo.Git.Credentials.AccessToken') or get_octopusvariable_quiet(\
                            'Git.Credentials.AccessToken'),\
                        help='The git password')\
\
    return parser.parse_known_args()\
\
\
def generate_github_token(github_app_id, github_app_private_key, github_app_installation_id):\
    # Generate the tokens used by git and the GitHub API\
    app_id = github_app_id\
    signing_key = jwt.jwk_from_pem(github_app_private_key.encode('utf-8'))\
\
    payload = {\
        # Issued at time\
        'iat': int(time.time()),\
        # JWT expiration time (10 minutes maximum)\
        'exp': int(time.time()) + 600,\
        # GitHub App's identifier\
        'iss': app_id\
    }\
\
    # Create JWT\
    jwt_instance = jwt.JWT()\
    encoded_jwt = jwt_instance.encode(payload, signing_key, alg='RS256')\
\
    # Create access token\
    url = 'https://api.github.com/app/installations/' + github_app_installation_id + '/access_tokens'\
    headers = {\
        'Authorization': 'Bearer ' + encoded_jwt,\
        'Accept': 'application/vnd.github+json',\
        'X-GitHub-Api-Version': '2022-11-28'\
    }\
    request = urllib.request.Request(url, headers=headers, method='POST')\
    response = urllib.request.urlopen(request)\
    response_json = json.loads(response.read().decode())\
    return response_json['token']\
\
\
def generate_auth_header(token):\
    auth = base64.b64encode(('x-access-token:' + token).encode('ascii'))\
    return 'Basic ' + auth.decode('ascii')\
\
\
def verify_new_repo(token, cac_org, new_repo):\
    # Attempt to view the new repo\
    try:\
        url = 'https://api.github.com/repos/' + cac_org + '/' + new_repo\
        headers = {\
            'Accept': 'application/vnd.github+json',\
            'Authorization': 'Bearer ' + token,\
            'X-GitHub-Api-Version': '2022-11-28'\
        }\
        request = urllib.request.Request(url, headers=headers)\
        urllib.request.urlopen(request)\
        return True\
    except:\
        return False\
\
\
def create_new_repo(token, cac_org, new_repo):\
    # If we could not view the repo, assume it needs to be created.\
    # https://docs.github.com/en/rest/repos/repos?apiVersion=2022-11-28#create-an-organization-repository\
    # Note you have to use the token rather than the JWT:\
    # https://stackoverflow.com/questions/39600396/bad-credentails-for-jwt-for-github-integrations-api\
\
    headers = {\
        'Authorization': 'token ' + token,\
        'Content-Type': 'application/json',\
        'Accept': 'application/vnd.github+json',\
        'X-GitHub-Api-Version': '2022-11-28',\
    }\
\
    try:\
        # First try to create an organization repo:\
        # https://docs.github.com/en/free-pro-team@latest/rest/repos/repos#create-an-organization-repository\
        url = 'https://api.github.com/orgs/' + cac_org + '/repos'\
        body = {'name': new_repo}\
        request = urllib.request.Request(url, headers=headers, data=json.dumps(body).encode('utf-8'))\
        urllib.request.urlopen(request)\
    except urllib.error.URLError as ex:\
        # Then fall back to creating a repo for the user:\
        # https://docs.github.com/en/free-pro-team@latest/rest/repos/repos?apiVersion=2022-11-28#create-a-repository-for-the-authenticated-user\
        if ex.code == 404:\
            url = 'https://api.github.com/user/repos'\
            body = {'name': new_repo}\
            request = urllib.request.Request(url, headers=headers, data=json.dumps(body).encode('utf-8'))\
            urllib.request.urlopen(request)\
        else:\
            raise ValueError(\\\"Failed to create thew new repository. This could indicate bad credentials.\\\") from ex\
\
\
def is_windows():\
    return platform.system() == 'Windows'\
\
\
parser, _ = init_argparse()\
\
if not parser.github_access_token.strip() and not (\
        parser.github_app_id.strip() and parser.github_app_private_key.strip() and parser.github_app_installation_id.strip()):\
    print(\\\"You must supply the GitHub token, or the GitHub App ID and private key and installation ID\\\")\
    sys.exit(1)\
\
if not parser.new_repo_name.strip():\
    print(\\\"You must define the new repo name\\\")\
    sys.exit(1)\
\
# The access token is generated from a github app or supplied directly as an access token\
token = generate_github_token(parser.github_app_id, parser.github_app_private_key, parser.github_app_installation_id) \\\\\
    if not parser.github_access_token.strip() else parser.github_access_token.strip()\
\
cac_org = parser.git_organization.strip()\
new_repo_custom_prefix = re.sub('[^a-zA-Z0-9-]', '_', parser.new_repo_name_prefix.strip())\
project_repo_sanitized = re.sub('[^a-zA-Z0-9-]', '_', parser.new_repo_name.strip())\
\
# The prefix is optional\
new_repo_prefix_with_separator = new_repo_custom_prefix + '_' if new_repo_custom_prefix else ''\
\
# The new repo name is the prefix + the name of thew new project\
new_repo = new_repo_prefix_with_separator + project_repo_sanitized\
\
# This is the value of the forked git repo\
set_octopusvariable('NewRepoUrl', 'https://github.com/' + cac_org + '/' + new_repo)\
set_octopusvariable('NewRepo', new_repo)\
\
if not verify_new_repo(token, cac_org, new_repo):\
    create_new_repo(token, cac_org, new_repo)\
    print(\
        'New repo was created at https://github.com/' + cac_org + '/' + new_repo)\
else:\
    print('Repo at https://github.com/' + cac_org + '/' + new_repo + ' already exists and has not been modified')\
\
print('New repo URL is defined in the output variable \\\"NewRepoUrl\\\": #{Octopus.Action[' +\
      get_octopusvariable_quiet('Octopus.Step.Name') + '].Output.NewRepoUrl}')\
print('New repo name is defined in the output variable \\\"NewRepo\\\": #{Octopus.Action[' +\
      get_octopusvariable_quiet('Octopus.Step.Name') + '].Output.NewRepo}')\
\"
        \"CreateGithubRepo.Git.Url.NewRepoName\"         = \"#{Git.Url.Repo}\"
        \"Octopus.Action.Script.ScriptSource\"           = \"Inline\"
      }
      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = []
  }
  step {
    condition           = \"Success\"
    name                = \"Create Octopus API Key Secret\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.Script\"
      name                               = \"Create Octopus API Key Secret\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"Octopus.Action.Script.Syntax\"                = \"Python\"
        \"CreateGitHubSecret.Git.Credentials.Password\" = \"#{Git.Credentials.Password}\"
        \"CreateGitHubSecret.GitHub.Secret.Value\"      = \"#{Octopus.ApiKey}\"
        \"CreateGitHubSecret.Git.Url.Repo\"             = \"#{Octopus.Action[Create Repo].Output.NewRepo}\"
        \"Octopus.Action.RunOnServer\"                  = \"true\"
        \"Octopus.Action.Script.ScriptSource\"          = \"Inline\"
        \"CreateGitHubSecret.GitHub.Secret.Name\"       = \"OCTOPUS_API_TOKEN\"
        \"CreateGitHubSecret.Git.Url.Organization\"     = \"#{Git.Url.Organization}\"
        \"Octopus.Action.Script.ScriptBody\"            = \"# https://gist.github.com/comdotlinux/9a53bb00767a16d6646464c4b8249094\
\
# This script forks a GitHub repo. It creates a token from a GitHub App installation to avoid\
# having to use a regular user account.\
import subprocess\
import sys\
\
# Install our own dependencies\
subprocess.check_call([sys.executable, '-m', 'pip', 'install', 'jwt', '--disable-pip-version-check'])\
subprocess.check_call([sys.executable, '-m', 'pip', 'install', 'pynacl', '--disable-pip-version-check'])\
\
import requests\
import json\
import subprocess\
import sys\
import os\
import urllib.request\
import base64\
import re\
import jwt\
import time\
import argparse\
import urllib3\
from base64 import b64encode\
from typing import TypedDict\
from nacl import public, encoding\
\
# Disable insecure http request warnings\
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\
\
# If this script is not being run as part of an Octopus step, setting variables is a noop\
if 'set_octopusvariable' not in globals():\
    def set_octopusvariable(variable, value):\
        pass\
\
# If this script is not being run as part of an Octopus step, return variables from environment variables.\
# Periods are replaced with underscores, and the variable name is converted to uppercase\
if \\\"get_octopusvariable\\\" not in globals():\
    def get_octopusvariable(variable):\
        return os.environ[re.sub('\\\\\\\\.', '_', variable.upper())]\
\
# If this script is not being run as part of an Octopus step, print directly to std out.\
if 'printverbose' not in globals():\
    def printverbose(msg):\
        print(msg)\
\
\
def printverbose_noansi(output):\
    \\\"\\\"\\\"\
    Strip ANSI color codes and print the output as verbose\
    :param output: The output to print\
    \\\"\\\"\\\"\
    output_no_ansi = re.sub(r'\\\\x1b\\\\[[0-9;]*m', '', output)\
    printverbose(output_no_ansi)\
\
\
def get_octopusvariable_quiet(variable):\
    \\\"\\\"\\\"\
    Gets an octopus variable, or an empty string if it does not exist.\
    :param variable: The variable name\
    :return: The variable value, or an empty string if the variable does not exist\
    \\\"\\\"\\\"\
    try:\
        return get_octopusvariable(variable)\
    except:\
        return ''\
\
\
def execute(args, cwd=None, env=None, print_args=None, print_output=printverbose_noansi, raise_on_non_zero=False,\
            append_to_path=None):\
    \\\"\\\"\\\"\
        The execute method provides the ability to execute external processes while capturing and returning the\
        output to std err and std out and exit code.\
    \\\"\\\"\\\"\
\
    my_env = os.environ.copy() if env is None else env\
\
    if append_to_path is not None:\
        my_env[\\\"PATH\\\"] = append_to_path + os.pathsep + my_env['PATH']\
\
    process = subprocess.Popen(args,\
                               stdout=subprocess.PIPE,\
                               stderr=subprocess.PIPE,\
                               stdin=open(os.devnull),\
                               text=True,\
                               cwd=cwd,\
                               env=my_env)\
    stdout, stderr = process.communicate()\
    retcode = process.returncode\
\
    if not retcode == 0 and raise_on_non_zero:\
        raise Exception('command returned exit code ' + retcode)\
\
    if print_args is not None:\
        print_output(' '.join(args))\
\
    if print_output is not None:\
        print_output(stdout)\
        print_output(stderr)\
\
    return stdout, stderr, retcode\
\
\
def init_argparse():\
    parser = argparse.ArgumentParser(\
        usage='%(prog)s [OPTION]',\
        description='Fork a GitHub repo'\
    )\
\
    parser.add_argument('--secret-name', action='store',\
                        default=get_octopusvariable_quiet(\
                            'CreateGitHubSecret.GitHub.Secret.Name') or get_octopusvariable_quiet(\
                            'GitHub.Secret.Name'))\
    parser.add_argument('--secret-value', action='store',\
                        default=get_octopusvariable_quiet(\
                            'CreateGitHubSecret.GitHub.Secret.Value') or get_octopusvariable_quiet(\
                            'GitHub.Secret.Value'))\
\
    parser.add_argument('--repo', action='store',\
                        default=get_octopusvariable_quiet(\
                            'CreateGitHubSecret.Git.Url.Repo') or get_octopusvariable_quiet(\
                            'Git.Url.Repo') or get_octopusvariable_quiet('Octopus.Project.Name'))\
    parser.add_argument('--git-organization', action='store',\
                        default=get_octopusvariable_quiet(\
                            'CreateGitHubSecret.Git.Url.Organization') or get_octopusvariable_quiet(\
                            'Git.Url.Organization'))\
    parser.add_argument('--github-app-id', action='store',\
                        default=get_octopusvariable_quiet(\
                            'CreateGitHubSecret.GitHub.App.Id') or get_octopusvariable_quiet('GitHub.App.Id'))\
    parser.add_argument('--github-app-installation-id', action='store',\
                        default=get_octopusvariable_quiet(\
                            'CreateGitHubSecret.GitHub.App.InstallationId') or get_octopusvariable_quiet(\
                            'GitHub.App.InstallationId'))\
    parser.add_argument('--github-app-private-key', action='store',\
                        default=get_octopusvariable_quiet(\
                            'CreateGitHubSecret.GitHub.App.PrivateKey') or get_octopusvariable_quiet(\
                            'GitHub.App.PrivateKey'))\
    parser.add_argument('--git-password', action='store',\
                        default=get_octopusvariable_quiet(\
                            'CreateGitHubSecret.Git.Credentials.Password') or get_octopusvariable_quiet(\
                            'Git.Credentials.Password'),\
                        help='The git password. This takes precedence over the --github-app-id,  --github-app-installation-id, and --github-app-private-key')\
\
    return parser.parse_known_args()\
\
\
def generate_github_token(github_app_id, github_app_private_key, github_app_installation_id):\
    # Generate the tokens used by git and the GitHub API\
    app_id = github_app_id\
    signing_key = jwt.jwk_from_pem(github_app_private_key.encode('utf-8'))\
\
    payload = {\
        # Issued at time\
        'iat': int(time.time()),\
        # JWT expiration time (10 minutes maximum)\
        'exp': int(time.time()) + 600,\
        # GitHub App's identifier\
        'iss': app_id\
    }\
\
    # Create JWT\
    jwt_instance = jwt.JWT()\
    encoded_jwt = jwt_instance.encode(payload, signing_key, alg='RS256')\
\
    # Create access token\
    url = 'https://api.github.com/app/installations/' + github_app_installation_id + '/access_tokens'\
    headers = {\
        'Authorization': 'Bearer ' + encoded_jwt,\
        'Accept': 'application/vnd.github+json',\
        'X-GitHub-Api-Version': '2022-11-28'\
    }\
    request = urllib.request.Request(url, headers=headers, method='POST')\
    response = urllib.request.urlopen(request)\
    response_json = json.loads(response.read().decode())\
    return response_json['token']\
\
\
def generate_auth_header(token):\
    auth = base64.b64encode(('x-access-token:' + token).encode('ascii'))\
    return 'Basic ' + auth.decode('ascii')\
\
\
def verify_new_repo(token, cac_org, new_repo):\
    # Attempt to view the new repo\
    try:\
        url = 'https://api.github.com/repos/' + cac_org + '/' + new_repo\
        headers = {\
            'Accept': 'application/vnd.github+json',\
            'Authorization': 'Bearer ' + token,\
            'X-GitHub-Api-Version': '2022-11-28'\
        }\
        request = urllib.request.Request(url, headers=headers)\
        urllib.request.urlopen(request)\
        return True\
    except:\
        return False\
\
\
def encrypt(public_key_for_repo: str, secret_value_input: str) -> str:\
    \\\"\\\"\\\"Encrypt a Unicode string using the public key.\\\"\\\"\\\"\
    sealed_box = public.SealedBox(public.PublicKey(public_key_for_repo.encode(\\\"utf-8\\\"), encoding.Base64Encoder()))\
    encrypted = sealed_box.encrypt(secret_value_input.encode(\\\"utf-8\\\"))\
    return b64encode(encrypted).decode(\\\"utf-8\\\")\
\
\
def get_public_key(gh_base_url: str, gh_owner: str, gh_repo: str, gh_auth_token: str) -> (str, str):\
    public_key_endpoint: str = f\\\"{gh_base_url}/{gh_owner}/{gh_repo}/actions/secrets/public-key\\\"\
    headers: TypedDict[str, str] = {\\\"Authorization\\\": f\\\"Bearer {gh_auth_token}\\\"}\
    response = requests.get(url=public_key_endpoint, headers=headers)\
    if response.status_code != 200:\
        raise IOError(\
            f\\\"Could not get public key for repository {gh_owner}/{gh_repo}. The Response code was {response.status_code}\\\")\
\
    public_key_json = response.json()\
    return public_key_json['key_id'], public_key_json['key']\
\
\
def set_secret(gh_base_url: str, gh_owner: str, gh_repo: str, gh_auth_token: str, public_key_id: str, secret_key: str,\
               encrypted_secret_value: str):\
    secret_creation_url = f\\\"{gh_base_url}/{gh_owner}/{gh_repo}/actions/secrets/{secret_key}\\\"\
    secret_creation_body = {\\\"key_id\\\": public_key_id, \\\"encrypted_value\\\": encrypted_secret_value}\
    headers: TypedDict[str, str] = {\\\"Authorization\\\": f\\\"Bearer {gh_auth_token}\\\", \\\"Content-Type\\\": \\\"application/json\\\"}\
\
    secret_creation_response = requests.put(url=secret_creation_url, json=secret_creation_body, headers=headers)\
    if secret_creation_response.status_code == 201 or secret_creation_response.status_code == 204:\
        print(\\\"--Secret Created / Updated!--\\\")\
    else:\
        print(f\\\"-- Error creating / updating github secret, the reason was : {secret_creation_response.reason}\\\")\
\
\
parser, _ = init_argparse()\
\
if not parser.git_password.strip() and not (\
        parser.github_app_id.strip() and parser.github_app_private_key.strip() and parser.github_app_installation_id.strip()):\
    print(\\\"You must supply the GitHub token, or the GitHub App ID and private key and installation ID\\\")\
    sys.exit(1)\
\
if not parser.git_organization.strip():\
    print(\\\"You must define the organization\\\")\
    sys.exit(1)\
\
if not parser.repo.strip():\
    print(\\\"You must define the repo name\\\")\
    sys.exit(1)\
\
token = generate_github_token(parser.github_app_id, parser.github_app_private_key,\
                              parser.github_app_installation_id) if len(\
    parser.git_password.strip()) == 0 else parser.git_password.strip()\
\
if not parser.git_password.strip() and not (\
        parser.github_app_id.strip() and parser.github_app_private_key.strip() and parser.github_app_installation_id.strip()):\
    print(\\\"You must supply the GitHub token, or the GitHub App ID and private key and installation ID\\\")\
    sys.exit(1)\
\
if not parser.git_organization.strip():\
    print(\\\"You must define the organization\\\")\
    sys.exit(1)\
\
if not parser.repo.strip():\
    print(\\\"You must define the repo name\\\")\
    sys.exit(1)\
\
if not parser.secret_name.strip():\
    print(\\\"You must define the secret name\\\")\
    sys.exit(1)\
    \
if not verify_new_repo(token, parser.git_organization, parser.repo):\
    print(\\\"Could not find the repo\\\")\
    sys.exit(1)\
\
key_id, public_key = get_public_key('https://api.github.com/repos', parser.git_organization, parser.repo,\
                                    token)\
encrypted_secret: str = encrypt(public_key_for_repo=public_key, secret_value_input=parser.secret_value)\
set_secret(gh_base_url='https://api.github.com/repos', gh_owner=parser.git_organization, gh_repo=parser.repo,\
           gh_auth_token=token, public_key_id=key_id, secret_key=parser.secret_name,\
           encrypted_secret_value=encrypted_secret)\
\"
      }
      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = []
  }
  step {
    condition           = \"Success\"
    name                = \"Create Docker Hub Password Secret\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.Script\"
      name                               = \"Create Docker Hub Password Secret\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"CreateGitHubSecret.Git.Credentials.Password\" = \"#{Git.Credentials.Password}\"
        \"CreateGitHubSecret.GitHub.Secret.Name\"       = \"DOCKERHUB_TOKEN\"
        \"Octopus.Action.Script.Syntax\"                = \"Python\"
        \"CreateGitHubSecret.GitHub.Secret.Value\"      = \"#{Docker.Credentials.Password}\"
        \"CreateGitHubSecret.Git.Url.Organization\"     = \"#{Git.Url.Organization}\"
        \"Octopus.Action.Script.ScriptSource\"          = \"Inline\"
        \"Octopus.Action.RunOnServer\"                  = \"true\"
        \"CreateGitHubSecret.Git.Url.Repo\"             = \"#{Octopus.Action[Create Repo].Output.NewRepo}\"
        \"Octopus.Action.Script.ScriptBody\"            = \"# https://gist.github.com/comdotlinux/9a53bb00767a16d6646464c4b8249094\
\
# This script forks a GitHub repo. It creates a token from a GitHub App installation to avoid\
# having to use a regular user account.\
import subprocess\
import sys\
\
# Install our own dependencies\
subprocess.check_call([sys.executable, '-m', 'pip', 'install', 'jwt', '--disable-pip-version-check'])\
subprocess.check_call([sys.executable, '-m', 'pip', 'install', 'pynacl', '--disable-pip-version-check'])\
\
import requests\
import json\
import subprocess\
import sys\
import os\
import urllib.request\
import base64\
import re\
import jwt\
import time\
import argparse\
import urllib3\
from base64 import b64encode\
from typing import TypedDict\
from nacl import public, encoding\
\
# Disable insecure http request warnings\
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\
\
# If this script is not being run as part of an Octopus step, setting variables is a noop\
if 'set_octopusvariable' not in globals():\
    def set_octopusvariable(variable, value):\
        pass\
\
# If this script is not being run as part of an Octopus step, return variables from environment variables.\
# Periods are replaced with underscores, and the variable name is converted to uppercase\
if \\\"get_octopusvariable\\\" not in globals():\
    def get_octopusvariable(variable):\
        return os.environ[re.sub('\\\\\\\\.', '_', variable.upper())]\
\
# If this script is not being run as part of an Octopus step, print directly to std out.\
if 'printverbose' not in globals():\
    def printverbose(msg):\
        print(msg)\
\
\
def printverbose_noansi(output):\
    \\\"\\\"\\\"\
    Strip ANSI color codes and print the output as verbose\
    :param output: The output to print\
    \\\"\\\"\\\"\
    output_no_ansi = re.sub(r'\\\\x1b\\\\[[0-9;]*m', '', output)\
    printverbose(output_no_ansi)\
\
\
def get_octopusvariable_quiet(variable):\
    \\\"\\\"\\\"\
    Gets an octopus variable, or an empty string if it does not exist.\
    :param variable: The variable name\
    :return: The variable value, or an empty string if the variable does not exist\
    \\\"\\\"\\\"\
    try:\
        return get_octopusvariable(variable)\
    except:\
        return ''\
\
\
def execute(args, cwd=None, env=None, print_args=None, print_output=printverbose_noansi, raise_on_non_zero=False,\
            append_to_path=None):\
    \\\"\\\"\\\"\
        The execute method provides the ability to execute external processes while capturing and returning the\
        output to std err and std out and exit code.\
    \\\"\\\"\\\"\
\
    my_env = os.environ.copy() if env is None else env\
\
    if append_to_path is not None:\
        my_env[\\\"PATH\\\"] = append_to_path + os.pathsep + my_env['PATH']\
\
    process = subprocess.Popen(args,\
                               stdout=subprocess.PIPE,\
                               stderr=subprocess.PIPE,\
                               stdin=open(os.devnull),\
                               text=True,\
                               cwd=cwd,\
                               env=my_env)\
    stdout, stderr = process.communicate()\
    retcode = process.returncode\
\
    if not retcode == 0 and raise_on_non_zero:\
        raise Exception('command returned exit code ' + retcode)\
\
    if print_args is not None:\
        print_output(' '.join(args))\
\
    if print_output is not None:\
        print_output(stdout)\
        print_output(stderr)\
\
    return stdout, stderr, retcode\
\
\
def init_argparse():\
    parser = argparse.ArgumentParser(\
        usage='%(prog)s [OPTION]',\
        description='Fork a GitHub repo'\
    )\
\
    parser.add_argument('--secret-name', action='store',\
                        default=get_octopusvariable_quiet(\
                            'CreateGitHubSecret.GitHub.Secret.Name') or get_octopusvariable_quiet(\
                            'GitHub.Secret.Name'))\
    parser.add_argument('--secret-value', action='store',\
                        default=get_octopusvariable_quiet(\
                            'CreateGitHubSecret.GitHub.Secret.Value') or get_octopusvariable_quiet(\
                            'GitHub.Secret.Value'))\
\
    parser.add_argument('--repo', action='store',\
                        default=get_octopusvariable_quiet(\
                            'CreateGitHubSecret.Git.Url.Repo') or get_octopusvariable_quiet(\
                            'Git.Url.Repo') or get_octopusvariable_quiet('Octopus.Project.Name'))\
    parser.add_argument('--git-organization', action='store',\
                        default=get_octopusvariable_quiet(\
                            'CreateGitHubSecret.Git.Url.Organization') or get_octopusvariable_quiet(\
                            'Git.Url.Organization'))\
    parser.add_argument('--github-app-id', action='store',\
                        default=get_octopusvariable_quiet(\
                            'CreateGitHubSecret.GitHub.App.Id') or get_octopusvariable_quiet('GitHub.App.Id'))\
    parser.add_argument('--github-app-installation-id', action='store',\
                        default=get_octopusvariable_quiet(\
                            'CreateGitHubSecret.GitHub.App.InstallationId') or get_octopusvariable_quiet(\
                            'GitHub.App.InstallationId'))\
    parser.add_argument('--github-app-private-key', action='store',\
                        default=get_octopusvariable_quiet(\
                            'CreateGitHubSecret.GitHub.App.PrivateKey') or get_octopusvariable_quiet(\
                            'GitHub.App.PrivateKey'))\
    parser.add_argument('--git-password', action='store',\
                        default=get_octopusvariable_quiet(\
                            'CreateGitHubSecret.Git.Credentials.Password') or get_octopusvariable_quiet(\
                            'Git.Credentials.Password'),\
                        help='The git password. This takes precedence over the --github-app-id,  --github-app-installation-id, and --github-app-private-key')\
\
    return parser.parse_known_args()\
\
\
def generate_github_token(github_app_id, github_app_private_key, github_app_installation_id):\
    # Generate the tokens used by git and the GitHub API\
    app_id = github_app_id\
    signing_key = jwt.jwk_from_pem(github_app_private_key.encode('utf-8'))\
\
    payload = {\
        # Issued at time\
        'iat': int(time.time()),\
        # JWT expiration time (10 minutes maximum)\
        'exp': int(time.time()) + 600,\
        # GitHub App's identifier\
        'iss': app_id\
    }\
\
    # Create JWT\
    jwt_instance = jwt.JWT()\
    encoded_jwt = jwt_instance.encode(payload, signing_key, alg='RS256')\
\
    # Create access token\
    url = 'https://api.github.com/app/installations/' + github_app_installation_id + '/access_tokens'\
    headers = {\
        'Authorization': 'Bearer ' + encoded_jwt,\
        'Accept': 'application/vnd.github+json',\
        'X-GitHub-Api-Version': '2022-11-28'\
    }\
    request = urllib.request.Request(url, headers=headers, method='POST')\
    response = urllib.request.urlopen(request)\
    response_json = json.loads(response.read().decode())\
    return response_json['token']\
\
\
def generate_auth_header(token):\
    auth = base64.b64encode(('x-access-token:' + token).encode('ascii'))\
    return 'Basic ' + auth.decode('ascii')\
\
\
def verify_new_repo(token, cac_org, new_repo):\
    # Attempt to view the new repo\
    try:\
        url = 'https://api.github.com/repos/' + cac_org + '/' + new_repo\
        headers = {\
            'Accept': 'application/vnd.github+json',\
            'Authorization': 'Bearer ' + token,\
            'X-GitHub-Api-Version': '2022-11-28'\
        }\
        request = urllib.request.Request(url, headers=headers)\
        urllib.request.urlopen(request)\
        return True\
    except:\
        return False\
\
\
def encrypt(public_key_for_repo: str, secret_value_input: str) -> str:\
    \\\"\\\"\\\"Encrypt a Unicode string using the public key.\\\"\\\"\\\"\
    sealed_box = public.SealedBox(public.PublicKey(public_key_for_repo.encode(\\\"utf-8\\\"), encoding.Base64Encoder()))\
    encrypted = sealed_box.encrypt(secret_value_input.encode(\\\"utf-8\\\"))\
    return b64encode(encrypted).decode(\\\"utf-8\\\")\
\
\
def get_public_key(gh_base_url: str, gh_owner: str, gh_repo: str, gh_auth_token: str) -> (str, str):\
    public_key_endpoint: str = f\\\"{gh_base_url}/{gh_owner}/{gh_repo}/actions/secrets/public-key\\\"\
    headers: TypedDict[str, str] = {\\\"Authorization\\\": f\\\"Bearer {gh_auth_token}\\\"}\
    response = requests.get(url=public_key_endpoint, headers=headers)\
    if response.status_code != 200:\
        raise IOError(\
            f\\\"Could not get public key for repository {gh_owner}/{gh_repo}. The Response code was {response.status_code}\\\")\
\
    public_key_json = response.json()\
    return public_key_json['key_id'], public_key_json['key']\
\
\
def set_secret(gh_base_url: str, gh_owner: str, gh_repo: str, gh_auth_token: str, public_key_id: str, secret_key: str,\
               encrypted_secret_value: str):\
    secret_creation_url = f\\\"{gh_base_url}/{gh_owner}/{gh_repo}/actions/secrets/{secret_key}\\\"\
    secret_creation_body = {\\\"key_id\\\": public_key_id, \\\"encrypted_value\\\": encrypted_secret_value}\
    headers: TypedDict[str, str] = {\\\"Authorization\\\": f\\\"Bearer {gh_auth_token}\\\", \\\"Content-Type\\\": \\\"application/json\\\"}\
\
    secret_creation_response = requests.put(url=secret_creation_url, json=secret_creation_body, headers=headers)\
    if secret_creation_response.status_code == 201 or secret_creation_response.status_code == 204:\
        print(\\\"--Secret Created / Updated!--\\\")\
    else:\
        print(f\\\"-- Error creating / updating github secret, the reason was : {secret_creation_response.reason}\\\")\
\
\
parser, _ = init_argparse()\
\
if not parser.git_password.strip() and not (\
        parser.github_app_id.strip() and parser.github_app_private_key.strip() and parser.github_app_installation_id.strip()):\
    print(\\\"You must supply the GitHub token, or the GitHub App ID and private key and installation ID\\\")\
    sys.exit(1)\
\
if not parser.git_organization.strip():\
    print(\\\"You must define the organization\\\")\
    sys.exit(1)\
\
if not parser.repo.strip():\
    print(\\\"You must define the repo name\\\")\
    sys.exit(1)\
\
token = generate_github_token(parser.github_app_id, parser.github_app_private_key,\
                              parser.github_app_installation_id) if len(\
    parser.git_password.strip()) == 0 else parser.git_password.strip()\
\
if not parser.git_password.strip() and not (\
        parser.github_app_id.strip() and parser.github_app_private_key.strip() and parser.github_app_installation_id.strip()):\
    print(\\\"You must supply the GitHub token, or the GitHub App ID and private key and installation ID\\\")\
    sys.exit(1)\
\
if not parser.git_organization.strip():\
    print(\\\"You must define the organization\\\")\
    sys.exit(1)\
\
if not parser.repo.strip():\
    print(\\\"You must define the repo name\\\")\
    sys.exit(1)\
\
if not parser.secret_name.strip():\
    print(\\\"You must define the secret name\\\")\
    sys.exit(1)\
    \
if not verify_new_repo(token, parser.git_organization, parser.repo):\
    print(\\\"Could not find the repo\\\")\
    sys.exit(1)\
\
key_id, public_key = get_public_key('https://api.github.com/repos', parser.git_organization, parser.repo,\
                                    token)\
encrypted_secret: str = encrypt(public_key_for_repo=public_key, secret_value_input=parser.secret_value)\
set_secret(gh_base_url='https://api.github.com/repos', gh_owner=parser.git_organization, gh_repo=parser.repo,\
           gh_auth_token=token, public_key_id=key_id, secret_key=parser.secret_name,\
           encrypted_secret_value=encrypted_secret)\
\"
      }
      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = []
  }
  step {
    condition           = \"Success\"
    name                = \"Create Docker Hub Password Username\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.Script\"
      name                               = \"Create Docker Hub Password Username\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"CreateGitHubSecret.Git.Credentials.Password\" = \"#{Git.Credentials.Password}\"
        \"Octopus.Action.RunOnServer\"                  = \"true\"
        \"CreateGitHubSecret.GitHub.Secret.Value\"      = \"#{Docker.Credentials.Username}\"
        \"CreateGitHubSecret.Git.Url.Repo\"             = \"#{Octopus.Action[Create Repo].Output.NewRepo}\"
        \"Octopus.Action.Script.ScriptSource\"          = \"Inline\"
        \"Octopus.Action.Script.ScriptBody\"            = \"# https://gist.github.com/comdotlinux/9a53bb00767a16d6646464c4b8249094\
\
# This script forks a GitHub repo. It creates a token from a GitHub App installation to avoid\
# having to use a regular user account.\
import subprocess\
import sys\
\
# Install our own dependencies\
subprocess.check_call([sys.executable, '-m', 'pip', 'install', 'jwt', '--disable-pip-version-check'])\
subprocess.check_call([sys.executable, '-m', 'pip', 'install', 'pynacl', '--disable-pip-version-check'])\
\
import requests\
import json\
import subprocess\
import sys\
import os\
import urllib.request\
import base64\
import re\
import jwt\
import time\
import argparse\
import urllib3\
from base64 import b64encode\
from typing import TypedDict\
from nacl import public, encoding\
\
# Disable insecure http request warnings\
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\
\
# If this script is not being run as part of an Octopus step, setting variables is a noop\
if 'set_octopusvariable' not in globals():\
    def set_octopusvariable(variable, value):\
        pass\
\
# If this script is not being run as part of an Octopus step, return variables from environment variables.\
# Periods are replaced with underscores, and the variable name is converted to uppercase\
if \\\"get_octopusvariable\\\" not in globals():\
    def get_octopusvariable(variable):\
        return os.environ[re.sub('\\\\\\\\.', '_', variable.upper())]\
\
# If this script is not being run as part of an Octopus step, print directly to std out.\
if 'printverbose' not in globals():\
    def printverbose(msg):\
        print(msg)\
\
\
def printverbose_noansi(output):\
    \\\"\\\"\\\"\
    Strip ANSI color codes and print the output as verbose\
    :param output: The output to print\
    \\\"\\\"\\\"\
    output_no_ansi = re.sub(r'\\\\x1b\\\\[[0-9;]*m', '', output)\
    printverbose(output_no_ansi)\
\
\
def get_octopusvariable_quiet(variable):\
    \\\"\\\"\\\"\
    Gets an octopus variable, or an empty string if it does not exist.\
    :param variable: The variable name\
    :return: The variable value, or an empty string if the variable does not exist\
    \\\"\\\"\\\"\
    try:\
        return get_octopusvariable(variable)\
    except:\
        return ''\
\
\
def execute(args, cwd=None, env=None, print_args=None, print_output=printverbose_noansi, raise_on_non_zero=False,\
            append_to_path=None):\
    \\\"\\\"\\\"\
        The execute method provides the ability to execute external processes while capturing and returning the\
        output to std err and std out and exit code.\
    \\\"\\\"\\\"\
\
    my_env = os.environ.copy() if env is None else env\
\
    if append_to_path is not None:\
        my_env[\\\"PATH\\\"] = append_to_path + os.pathsep + my_env['PATH']\
\
    process = subprocess.Popen(args,\
                               stdout=subprocess.PIPE,\
                               stderr=subprocess.PIPE,\
                               stdin=open(os.devnull),\
                               text=True,\
                               cwd=cwd,\
                               env=my_env)\
    stdout, stderr = process.communicate()\
    retcode = process.returncode\
\
    if not retcode == 0 and raise_on_non_zero:\
        raise Exception('command returned exit code ' + retcode)\
\
    if print_args is not None:\
        print_output(' '.join(args))\
\
    if print_output is not None:\
        print_output(stdout)\
        print_output(stderr)\
\
    return stdout, stderr, retcode\
\
\
def init_argparse():\
    parser = argparse.ArgumentParser(\
        usage='%(prog)s [OPTION]',\
        description='Fork a GitHub repo'\
    )\
\
    parser.add_argument('--secret-name', action='store',\
                        default=get_octopusvariable_quiet(\
                            'CreateGitHubSecret.GitHub.Secret.Name') or get_octopusvariable_quiet(\
                            'GitHub.Secret.Name'))\
    parser.add_argument('--secret-value', action='store',\
                        default=get_octopusvariable_quiet(\
                            'CreateGitHubSecret.GitHub.Secret.Value') or get_octopusvariable_quiet(\
                            'GitHub.Secret.Value'))\
\
    parser.add_argument('--repo', action='store',\
                        default=get_octopusvariable_quiet(\
                            'CreateGitHubSecret.Git.Url.Repo') or get_octopusvariable_quiet(\
                            'Git.Url.Repo') or get_octopusvariable_quiet('Octopus.Project.Name'))\
    parser.add_argument('--git-organization', action='store',\
                        default=get_octopusvariable_quiet(\
                            'CreateGitHubSecret.Git.Url.Organization') or get_octopusvariable_quiet(\
                            'Git.Url.Organization'))\
    parser.add_argument('--github-app-id', action='store',\
                        default=get_octopusvariable_quiet(\
                            'CreateGitHubSecret.GitHub.App.Id') or get_octopusvariable_quiet('GitHub.App.Id'))\
    parser.add_argument('--github-app-installation-id', action='store',\
                        default=get_octopusvariable_quiet(\
                            'CreateGitHubSecret.GitHub.App.InstallationId') or get_octopusvariable_quiet(\
                            'GitHub.App.InstallationId'))\
    parser.add_argument('--github-app-private-key', action='store',\
                        default=get_octopusvariable_quiet(\
                            'CreateGitHubSecret.GitHub.App.PrivateKey') or get_octopusvariable_quiet(\
                            'GitHub.App.PrivateKey'))\
    parser.add_argument('--git-password', action='store',\
                        default=get_octopusvariable_quiet(\
                            'CreateGitHubSecret.Git.Credentials.Password') or get_octopusvariable_quiet(\
                            'Git.Credentials.Password'),\
                        help='The git password. This takes precedence over the --github-app-id,  --github-app-installation-id, and --github-app-private-key')\
\
    return parser.parse_known_args()\
\
\
def generate_github_token(github_app_id, github_app_private_key, github_app_installation_id):\
    # Generate the tokens used by git and the GitHub API\
    app_id = github_app_id\
    signing_key = jwt.jwk_from_pem(github_app_private_key.encode('utf-8'))\
\
    payload = {\
        # Issued at time\
        'iat': int(time.time()),\
        # JWT expiration time (10 minutes maximum)\
        'exp': int(time.time()) + 600,\
        # GitHub App's identifier\
        'iss': app_id\
    }\
\
    # Create JWT\
    jwt_instance = jwt.JWT()\
    encoded_jwt = jwt_instance.encode(payload, signing_key, alg='RS256')\
\
    # Create access token\
    url = 'https://api.github.com/app/installations/' + github_app_installation_id + '/access_tokens'\
    headers = {\
        'Authorization': 'Bearer ' + encoded_jwt,\
        'Accept': 'application/vnd.github+json',\
        'X-GitHub-Api-Version': '2022-11-28'\
    }\
    request = urllib.request.Request(url, headers=headers, method='POST')\
    response = urllib.request.urlopen(request)\
    response_json = json.loads(response.read().decode())\
    return response_json['token']\
\
\
def generate_auth_header(token):\
    auth = base64.b64encode(('x-access-token:' + token).encode('ascii'))\
    return 'Basic ' + auth.decode('ascii')\
\
\
def verify_new_repo(token, cac_org, new_repo):\
    # Attempt to view the new repo\
    try:\
        url = 'https://api.github.com/repos/' + cac_org + '/' + new_repo\
        headers = {\
            'Accept': 'application/vnd.github+json',\
            'Authorization': 'Bearer ' + token,\
            'X-GitHub-Api-Version': '2022-11-28'\
        }\
        request = urllib.request.Request(url, headers=headers)\
        urllib.request.urlopen(request)\
        return True\
    except:\
        return False\
\
\
def encrypt(public_key_for_repo: str, secret_value_input: str) -> str:\
    \\\"\\\"\\\"Encrypt a Unicode string using the public key.\\\"\\\"\\\"\
    sealed_box = public.SealedBox(public.PublicKey(public_key_for_repo.encode(\\\"utf-8\\\"), encoding.Base64Encoder()))\
    encrypted = sealed_box.encrypt(secret_value_input.encode(\\\"utf-8\\\"))\
    return b64encode(encrypted).decode(\\\"utf-8\\\")\
\
\
def get_public_key(gh_base_url: str, gh_owner: str, gh_repo: str, gh_auth_token: str) -> (str, str):\
    public_key_endpoint: str = f\\\"{gh_base_url}/{gh_owner}/{gh_repo}/actions/secrets/public-key\\\"\
    headers: TypedDict[str, str] = {\\\"Authorization\\\": f\\\"Bearer {gh_auth_token}\\\"}\
    response = requests.get(url=public_key_endpoint, headers=headers)\
    if response.status_code != 200:\
        raise IOError(\
            f\\\"Could not get public key for repository {gh_owner}/{gh_repo}. The Response code was {response.status_code}\\\")\
\
    public_key_json = response.json()\
    return public_key_json['key_id'], public_key_json['key']\
\
\
def set_secret(gh_base_url: str, gh_owner: str, gh_repo: str, gh_auth_token: str, public_key_id: str, secret_key: str,\
               encrypted_secret_value: str):\
    secret_creation_url = f\\\"{gh_base_url}/{gh_owner}/{gh_repo}/actions/secrets/{secret_key}\\\"\
    secret_creation_body = {\\\"key_id\\\": public_key_id, \\\"encrypted_value\\\": encrypted_secret_value}\
    headers: TypedDict[str, str] = {\\\"Authorization\\\": f\\\"Bearer {gh_auth_token}\\\", \\\"Content-Type\\\": \\\"application/json\\\"}\
\
    secret_creation_response = requests.put(url=secret_creation_url, json=secret_creation_body, headers=headers)\
    if secret_creation_response.status_code == 201 or secret_creation_response.status_code == 204:\
        print(\\\"--Secret Created / Updated!--\\\")\
    else:\
        print(f\\\"-- Error creating / updating github secret, the reason was : {secret_creation_response.reason}\\\")\
\
\
parser, _ = init_argparse()\
\
if not parser.git_password.strip() and not (\
        parser.github_app_id.strip() and parser.github_app_private_key.strip() and parser.github_app_installation_id.strip()):\
    print(\\\"You must supply the GitHub token, or the GitHub App ID and private key and installation ID\\\")\
    sys.exit(1)\
\
if not parser.git_organization.strip():\
    print(\\\"You must define the organization\\\")\
    sys.exit(1)\
\
if not parser.repo.strip():\
    print(\\\"You must define the repo name\\\")\
    sys.exit(1)\
\
token = generate_github_token(parser.github_app_id, parser.github_app_private_key,\
                              parser.github_app_installation_id) if len(\
    parser.git_password.strip()) == 0 else parser.git_password.strip()\
\
if not parser.git_password.strip() and not (\
        parser.github_app_id.strip() and parser.github_app_private_key.strip() and parser.github_app_installation_id.strip()):\
    print(\\\"You must supply the GitHub token, or the GitHub App ID and private key and installation ID\\\")\
    sys.exit(1)\
\
if not parser.git_organization.strip():\
    print(\\\"You must define the organization\\\")\
    sys.exit(1)\
\
if not parser.repo.strip():\
    print(\\\"You must define the repo name\\\")\
    sys.exit(1)\
\
if not parser.secret_name.strip():\
    print(\\\"You must define the secret name\\\")\
    sys.exit(1)\
    \
if not verify_new_repo(token, parser.git_organization, parser.repo):\
    print(\\\"Could not find the repo\\\")\
    sys.exit(1)\
\
key_id, public_key = get_public_key('https://api.github.com/repos', parser.git_organization, parser.repo,\
                                    token)\
encrypted_secret: str = encrypt(public_key_for_repo=public_key, secret_value_input=parser.secret_value)\
set_secret(gh_base_url='https://api.github.com/repos', gh_owner=parser.git_organization, gh_repo=parser.repo,\
           gh_auth_token=token, public_key_id=key_id, secret_key=parser.secret_name,\
           encrypted_secret_value=encrypted_secret)\
\"
        \"CreateGitHubSecret.Git.Url.Organization\"     = \"#{Git.Url.Organization}\"
        \"CreateGitHubSecret.GitHub.Secret.Name\"       = \"DOCKERHUB_USERNAME\"
        \"Octopus.Action.Script.Syntax\"                = \"Python\"
      }
      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = []
  }
  step {
    condition           = \"Success\"
    name                = \"Generate and Push\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.Script\"
      name                               = \"Generate and Push\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = true
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"PopulateGithubRepo.Yeoman.Generator.SubGenerator\" = \"nodejs-docker-webapp\"
        \"PopulateGithubRepo.Yeoman.Generator.Arguments\"    = \"--octopusUrl #{Octopus.Action[Get Variables].Output.Web.ServerUri} --octopusSpace \\\"#{Octopus.Action[Get Variables].Output.Space.Name}\\\" --octopusApi #{Octopus.ApiKey} --octopusProject \\\"#{Application.Octopus.Project}\\\" --dockerImage #{Application.Docker.Image}\"
        \"PopulateGithubRepo.Yeoman.Generator.Name\"         = \"octopus-reference-architecture-apps\"
        \"Octopus.Action.Script.Syntax\"                     = \"Python\"
        \"Octopus.Action.Script.ScriptSource\"               = \"Inline\"
        \"Octopus.Action.Script.ScriptBody\"                 = \"# This script forks a GitHub repo. It creates a token from a GitHub App installation to avoid\
# having to use a regular user account.\
import subprocess\
import sys\
\
# Install our own dependencies\
env_vars = os.environ.copy()\
env_vars['PIP_ROOT_USER_ACTION'] = 'ignore'\
subprocess.check_call([sys.executable, '-m', 'pip', 'install', 'jwt', '--disable-pip-version-check'], env=env_vars)\
subprocess.check_call([sys.executable, '-m', 'pip', 'install', 'requests', '--disable-pip-version-check'], env=env_vars)\
subprocess.check_call([sys.executable, '-m', 'pip', 'install', 'anyascii', '--disable-pip-version-check'], env=env_vars)\
\
import requests\
import json\
import subprocess\
import sys\
import os\
import urllib.request\
import base64\
import re\
import jwt\
import time\
import argparse\
import platform\
import zipfile\
import lzma\
import tarfile\
import shutil\
import urllib3\
from shlex import split\
from anyascii import anyascii\
\
# Disable insecure http request warnings\
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\
\
# If this script is not being run as part of an Octopus step, setting variables is a noop\
if 'set_octopusvariable' not in globals():\
    def set_octopusvariable(variable, value):\
        pass\
\
# If this script is not being run as part of an Octopus step, return variables from environment variables.\
# Periods are replaced with underscores, and the variable name is converted to uppercase\
if \\\"get_octopusvariable\\\" not in globals():\
    def get_octopusvariable(variable):\
        return os.environ[re.sub('\\\\\\\\.', '_', variable.upper())]\
\
# If this script is not being run as part of an Octopus step, print directly to std out.\
if 'printverbose' not in globals():\
    def printverbose(msg):\
        print(msg)\
\
\
def printverbose_noansi(output):\
    \\\"\\\"\\\"\
    Strip ANSI color codes and print the output as verbose\
    :param output: The output to print\
    \\\"\\\"\\\"\
    output_no_ansi = re.sub(r'\\\\x1b\\\\[[0-9;]*m', '', output)\
    printverbose(output_no_ansi)\
\
\
def get_octopusvariable_quiet(variable):\
    \\\"\\\"\\\"\
    Gets an octopus variable, or an empty string if it does not exist.\
    :param variable: The variable name\
    :return: The variable value, or an empty string if the variable does not exist\
    \\\"\\\"\\\"\
    try:\
        return get_octopusvariable(variable)\
    except Exception as inst:\
        return ''\
\
\
def execute(args, cwd=None, env=None, print_args=None, print_output=printverbose_noansi, raise_on_non_zero=False,\
            append_to_path=None):\
    \\\"\\\"\\\"\
        The execute method provides the ability to execute external processes while capturing and returning the\
        output to std err and std out and exit code.\
    \\\"\\\"\\\"\
\
    my_env = os.environ.copy() if env is None else env\
\
    if append_to_path is not None:\
        my_env[\\\"PATH\\\"] = append_to_path + os.pathsep + my_env['PATH']\
\
    process = subprocess.Popen(args,\
                               stdout=subprocess.PIPE,\
                               stderr=subprocess.PIPE,\
                               stdin=open(os.devnull),\
                               text=True,\
                               cwd=cwd,\
                               env=my_env)\
    stdout, stderr = process.communicate()\
    retcode = process.returncode\
\
    if not retcode == 0 and raise_on_non_zero:\
        raise Exception('command returned exit code ' + retcode)\
\
    if print_args is not None:\
        print_output(' '.join(args))\
\
    if print_output is not None:\
        print_output(stdout)\
        print_output(stderr)\
\
    return stdout, stderr, retcode\
\
\
def init_argparse():\
    parser = argparse.ArgumentParser(\
        usage='%(prog)s [OPTION]',\
        description='Fork a GitHub repo'\
    )\
    parser.add_argument('--generator', action='store',\
                        default=get_octopusvariable_quiet(\
                            'PopulateGithubRepo.Yeoman.Generator.Name') or get_octopusvariable_quiet(\
                            'Yeoman.Generator.Name'))\
    parser.add_argument('--sub-generator', action='store',\
                        default=get_octopusvariable_quiet(\
                            'PopulateGithubRepo.Yeoman.Generator.SubGenerator') or get_octopusvariable_quiet(\
                            'Yeoman.Generator.SubGenerator'))\
    parser.add_argument('--generator-arguments', action='store',\
                        default=get_octopusvariable_quiet(\
                            'PopulateGithubRepo.Yeoman.Generator.Arguments') or get_octopusvariable_quiet(\
                            'Yeoman.Generator.Arguments'),\
                        help='The arguments to pas to yo. Pass all arguments as a single string. This string is then parsed as if it were yo arguments.')\
    parser.add_argument('--repo', action='store',\
                        default=get_octopusvariable_quiet(\
                            'PopulateGithubRepo.Git.Url.Repo') or get_octopusvariable_quiet(\
                            'Git.Url.Repo'))\
    parser.add_argument('--git-organization', action='store',\
                        default=get_octopusvariable_quiet(\
                            'PopulateGithubRepo.Git.Url.Organization') or get_octopusvariable_quiet(\
                            'Git.Url.Organization'))\
    parser.add_argument('--github-app-id', action='store',\
                        default=get_octopusvariable_quiet(\
                            'PopulateGithubRepo.GitHub.App.Id') or get_octopusvariable_quiet('GitHub.App.Id'))\
    parser.add_argument('--github-app-installation-id', action='store',\
                        default=get_octopusvariable_quiet(\
                            'PopulateGithubRepo.GitHub.App.InstallationId') or get_octopusvariable_quiet(\
                            'GitHub.App.InstallationId'))\
    parser.add_argument('--github-app-private-key', action='store',\
                        default=get_octopusvariable_quiet(\
                            'PopulateGithubRepo.GitHub.App.PrivateKey') or get_octopusvariable_quiet(\
                            'GitHub.App.PrivateKey'))\
    parser.add_argument('--git-password', action='store',\
                        default=get_octopusvariable_quiet(\
                            'PopulateGithubRepo.Git.Credentials.Password') or get_octopusvariable_quiet(\
                            'Git.Credentials.Password'),\
                        help='The git password. This takes precedence over the --github-app-id,  --github-app-installation-id, and --github-app-private-key')\
    parser.add_argument('--git-username', action='store',\
                        default=get_octopusvariable_quiet(\
                            'PopulateGithubRepo.Git.Credentials.Username') or get_octopusvariable_quiet(\
                            'Git.Credentials.Username'),\
                        help='The git username. This will be used for both the git authentication and the username associated with any commits.')\
\
    return parser.parse_known_args()\
\
\
def generate_github_token(github_app_id, github_app_private_key, github_app_installation_id):\
    # Generate the tokens used by git and the GitHub API\
    app_id = github_app_id\
    signing_key = jwt.jwk_from_pem(github_app_private_key.encode('utf-8'))\
\
    payload = {\
        # Issued at time\
        'iat': int(time.time()),\
        # JWT expiration time (10 minutes maximum)\
        'exp': int(time.time()) + 600,\
        # GitHub App's identifier\
        'iss': app_id\
    }\
\
    # Create JWT\
    jwt_instance = jwt.JWT()\
    encoded_jwt = jwt_instance.encode(payload, signing_key, alg='RS256')\
\
    # Create access token\
    url = 'https://api.github.com/app/installations/' + github_app_installation_id + '/access_tokens'\
    headers = {\
        'Authorization': 'Bearer ' + encoded_jwt,\
        'Accept': 'application/vnd.github+json',\
        'X-GitHub-Api-Version': '2022-11-28'\
    }\
    request = urllib.request.Request(url, headers=headers, method='POST')\
    response = urllib.request.urlopen(request)\
    response_json = json.loads(response.read().decode())\
    return response_json['token']\
\
\
def generate_auth_header(token):\
    auth = base64.b64encode(('x-access-token:' + token).encode('ascii'))\
    return 'Basic ' + auth.decode('ascii')\
\
\
def verify_new_repo(token, cac_org, new_repo):\
    # Attempt to view the new repo\
    try:\
        url = 'https://api.github.com/repos/' + cac_org + '/' + new_repo\
        headers = {\
            'Accept': 'application/vnd.github+json',\
            'Authorization': 'Bearer ' + token,\
            'X-GitHub-Api-Version': '2022-11-28'\
        }\
        request = urllib.request.Request(url, headers=headers)\
        urllib.request.urlopen(request)\
        return True\
    except Exception as inst:\
        return False\
\
\
def is_windows():\
    return platform.system() == 'Windows'\
\
\
def download_file(url, filename, verify_ssl=True):\
    r = requests.get(url, verify=verify_ssl)\
    with open(filename, 'wb') as file:\
        file.write(r.content)\
\
\
def ensure_git_exists():\
    if is_windows():\
        print(\\\"Checking git is installed\\\")\
        try:\
            stdout, _, exit_code = execute(['git', 'version'])\
            printverbose(stdout)\
            if not exit_code == 0:\
                raise \\\"git not found\\\"\
        except:\
            print(\\\"Downloading git\\\")\
            download_file('https://www.7-zip.org/a/7zr.exe', '7zr.exe')\
            download_file(\
                'https://github.com/git-for-windows/git/releases/download/v2.42.0.windows.2/PortableGit-2.42.0.2-64-bit.7z.exe',\
                'PortableGit.7z.exe')\
            print(\\\"Installing git\\\")\
            print(\\\"Consider installing git on the worker or using a standard worker-tools image\\\")\
            execute(['7zr.exe', 'x', 'PortableGit.7z.exe', '-o' + os.path.join(os.getcwd(), 'git'), '-y'])\
            return os.path.join(os.getcwd(), 'git', 'bin', 'git')\
\
    return 'git'\
\
\
def install_npm_linux():\
    print(\\\"Downloading node\\\")\
    download_file(\
        'https://nodejs.org/dist/v18.18.2/node-v18.18.2-linux-x64.tar.xz',\
        'node.tar.xz')\
    print(\\\"Installing node on Linux\\\")\
    with lzma.open(\\\"node.tar.xz\\\", \\\"r\\\") as lzma_ref:\
        with open(\\\"node.tar\\\", \\\"wb\\\") as fdst:\
            shutil.copyfileobj(lzma_ref, fdst)\
    with tarfile.open(\\\"node.tar\\\", \\\"r\\\") as tar_ref:\
        tar_ref.extractall(os.getcwd())\
\
    try:\
        _, _, exit_code = execute([os.getcwd() + '/node-v18.18.2-linux-x64/bin/npm', '--version'],\
                                  append_to_path=os.getcwd() + '/node-v18.18.2-linux-x64/bin')\
        if not exit_code == 0:\
            raise Exception(\\\"Failed to run npm\\\")\
    except Exception as ex:\
        print('Failed to install npm ' + str(ex))\
        sys.exit(1)\
    return os.getcwd() + '/node-v18.18.2-linux-x64/bin/npm', os.getcwd() + '/node-v18.18.2-linux-x64/bin'\
\
\
def install_npm_windows():\
    print(\\\"Downloading node\\\")\
    download_file('https://nodejs.org/dist/v18.18.2/node-v18.18.2-win-x64.zip', 'node.zip', False)\
    print(\\\"Installing node on Windows\\\")\
    with zipfile.ZipFile(\\\"node.zip\\\", \\\"r\\\") as zip_ref:\
        zip_ref.extractall(os.getcwd())\
    try:\
        _, _, exit_code = execute([os.path.join(os.getcwd(), 'node-v18.18.2-win-x64', 'npm.cmd'), '--version'],\
                                  append_to_path=os.path.join(os.getcwd(), 'node-v18.18.2-win-x64'))\
        if not exit_code == 0:\
            raise Exception(\\\"Failed to run npm\\\")\
    except Exception as ex:\
        print('Failed to install npm ' + str(ex))\
        sys.exit(1)\
\
    return (os.path.join(os.getcwd(), 'node-v18.18.2-win-x64', 'npm.cmd'),\
            os.path.join(os.getcwd(), 'node-v18.18.2-win-x64'))\
\
\
def ensure_node_exists():\
    try:\
        print(\\\"Checking node is installed\\\")\
        _, _, exit_code = execute(['npm', '--version'])\
        if not exit_code == 0:\
            raise Exception(\\\"npm not found\\\")\
    except:\
        if is_windows():\
            return install_npm_windows()\
        else:\
            return install_npm_linux()\
\
    return 'npm', None\
\
\
def ensure_yo_exists(npm_executable, npm_path):\
    try:\
        print(\\\"Checking Yeoman is installed\\\")\
        _, _, exit_code = execute(['yo', '--version'])\
        if not exit_code == 0:\
            raise Exception(\\\"yo not found\\\")\
    except:\
        print('Installing Yeoman')\
\
        _, _, retcode = execute([npm_executable, 'install', '-g', 'yo'], append_to_path=npm_path)\
\
        if not retcode == 0:\
            print(\\\"Failed to set install Yeoman. Check the verbose logs for details.\\\")\
            sys.exit(1)\
\
        npm_bin, _, retcode = execute([npm_executable, 'config', 'get', 'prefix'], append_to_path=npm_path)\
\
        if not retcode == 0:\
            print(\\\"Failed to set get the npm prefix directory. Check the verbose logs for details.\\\")\
            sys.exit(1)\
\
        try:\
            if is_windows():\
                _, _, exit_code = execute([os.path.join(npm_bin.strip(), 'yo.cmd'), '--version'],\
                                          append_to_path=npm_path)\
            else:\
                _, _, exit_code = execute([os.path.join(npm_bin.strip(), 'bin', 'yo'), '--version'],\
                                          append_to_path=npm_path)\
\
            if not exit_code == 0:\
                raise Exception(\\\"Failed to run yo\\\")\
        except Exception as ex:\
            print('Failed to install yo ' + str(ex))\
            sys.exit(1)\
\
        # Windows and Linux save NPM binaries in different directories\
        if is_windows():\
            return os.path.join(npm_bin.strip(), 'yo.cmd')\
\
        return os.path.join(npm_bin.strip(), 'bin', 'yo')\
\
    return 'yo'\
\
\
git_executable = ensure_git_exists()\
npm_executable, npm_path = ensure_node_exists()\
yo_executable = ensure_yo_exists(npm_executable, npm_path)\
parser, _ = init_argparse()\
\
if not parser.git_password.strip() and not (\
        parser.github_app_id.strip() and parser.github_app_private_key.strip() and parser.github_app_installation_id.strip()):\
    print(\\\"You must supply the GitHub token, or the GitHub App ID and private key and installation ID\\\")\
    sys.exit(1)\
\
if not parser.git_organization.strip():\
    print(\\\"You must define the organization\\\")\
    sys.exit(1)\
\
if not parser.repo.strip():\
    print(\\\"You must define the repo name\\\")\
    sys.exit(1)\
\
if not parser.generator.strip():\
    print(\\\"You must define the Yeoman generator\\\")\
    sys.exit(1)\
\
# Create a dir for the git clone\
if os.path.exists('downstream'):\
    shutil.rmtree('downstream')\
\
os.mkdir('downstream')\
\
# Create a dir for yeoman to use\
if os.path.exists('downstream-yeoman'):\
    shutil.rmtree('downstream-yeoman')\
\
os.mkdir('downstream-yeoman')\
# Yeoman will use a less privileged user to write to this directory, so grant full access\
if not is_windows():\
    os.chmod('downstream-yeoman', 0o777)\
\
downstream_dir = os.path.join(os.getcwd(), 'downstream')\
downstream_yeoman_dir = os.path.join(os.getcwd(), 'downstream-yeoman')\
\
# The access token is generated from a github app or supplied directly as an access token\
token = generate_github_token(parser.github_app_id, parser.github_app_private_key,\
                              parser.github_app_installation_id) if len(\
    parser.git_password.strip()) == 0 else parser.git_password.strip()\
\
if not verify_new_repo(token, parser.git_organization, parser.repo):\
    print('Repo at https://github.com/' + parser.git_organization + '/' + parser.repo + ' could not be accessed')\
    sys.exit(1)\
\
# We need to disable the credentials helper prompt, which will pop open a GUI prompt that we can never close\
if is_windows():\
    _, _, retcode = execute([git_executable, 'config', '--system', 'credential.helper', 'manager'])\
\
    if not retcode == 0:\
        print(\\\"Failed to set the credential.helper setting. Check the verbose logs for details.\\\")\
        sys.exit(1)\
\
    _, _, retcode = execute([git_executable, 'config', '--system', 'credential.modalprompt', 'false'])\
\
    if not retcode == 0:\
        print(\\\"Failed to srt the credential.modalprompt setting. Check the verbose logs for details.\\\")\
        sys.exit(1)\
\
    # We need to disable the credentials helper prompt, which will pop open a GUI prompt that we can never close\
    _, _, retcode = execute(\
        [git_executable, 'config', '--system', 'credential.microsoft.visualstudio.com.interactive', 'never'])\
\
    if not retcode == 0:\
        print(\
            \\\"Failed to set the credential.microsoft.visualstudio.com.interactive setting. Check the verbose logs for details.\\\")\
        sys.exit(1)\
\
_, _, retcode = execute([git_executable, 'config', '--global', 'user.email', 'octopus@octopus.com'])\
\
if not retcode == 0:\
    print(\\\"Failed to set the user.email setting. Check the verbose logs for details.\\\")\
    sys.exit(1)\
\
_, _, retcode = execute([git_executable, 'config', '--global', 'core.autocrlf', 'input'])\
\
if not retcode == 0:\
    print(\\\"Failed to set the core.autocrlf setting. Check the verbose logs for details.\\\")\
    sys.exit(1)\
\
username = parser.git_username if len(parser.git_username) != 0 else 'Octopus'\
_, _, retcode = execute([git_executable, 'config', '--global', 'user.name', username])\
\
if not retcode == 0:\
    print(\\\"Failed to set the git username. Check the verbose logs for details.\\\")\
    sys.exit(1)\
\
_, _, retcode = execute([git_executable, 'config', '--global', 'credential.helper', 'cache'])\
\
if not retcode == 0:\
    print(\\\"Failed to set the git credential helper. Check the verbose logs for details.\\\")\
    sys.exit(1)\
\
print('Cloning repo')\
\
_, _, retcode = execute(\
    [git_executable, 'clone',\
     'https://' + username + ':' + token + '@github.com/' + parser.git_organization + '/' + parser.repo + '.git',\
     'downstream'])\
\
if not retcode == 0:\
    print(\\\"Failed to clone the git repo. Check the verbose logs for details.\\\")\
    sys.exit(1)\
\
print('Configuring Yeoman Generator')\
\
_, _, retcode = execute([npm_executable, 'install'], cwd=os.path.join(os.getcwd(), 'YeomanGenerator'), append_to_path=npm_path)\
\
if not retcode == 0:\
    print(\\\"Failed to install the generator dependencies. Check the verbose logs for details.\\\")\
    sys.exit(1)\
\
_, _, retcode = execute([npm_executable, 'link'], cwd=os.path.join(os.getcwd(), 'YeomanGenerator'), append_to_path=npm_path)\
\
if not retcode == 0:\
    print(\\\"Failed to link the npm module. Check the verbose logs for details.\\\")\
    sys.exit(1)\
\
print('Running Yeoman Generator')\
\
# Treat the string of yo arguments as a raw input and parse it again. The resulting list of unknown arguments\
# is then passed to yo. We have to convert the incoming values from utf to ascii when parsing a second time.\
yo_args = split(anyascii(parser.generator_arguments))\
\
generator_name = parser.generator + ':' + parser.sub_generator if len(parser.sub_generator) != 0 else parser.generator\
\
yo_arguments = [yo_executable, generator_name, '--force', '--skip-install']\
\
# Yeoman has issues running as root, which it will often do in a container.\
# So we run Yeoman in its own directory, and then copy the changes to the git directory.\
_, _, retcode = execute(yo_arguments + yo_args, cwd=downstream_yeoman_dir, append_to_path=npm_path)\
\
if not retcode == 0:\
    print(\\\"Failed to run Yeoman. Check the verbose logs for details.\\\")\
    sys.exit(1)\
\
shutil.copytree(downstream_yeoman_dir, downstream_dir, dirs_exist_ok=True)\
\
print('Adding changes to git')\
\
_, _, retcode = execute([git_executable, 'add', '.'], cwd=downstream_dir)\
\
if not retcode == 0:\
    print(\\\"Failed to add the git changes. Check the verbose logs for details.\\\")\
    sys.exit(1)\
\
# Check for pending changes\
_, _, retcode = execute([git_executable, 'diff-index', '--quiet', 'HEAD'], cwd=downstream_dir)\
\
if not retcode == 0:\
    print('Committing changes to git')\
    _, _, retcode = execute([git_executable, 'commit', '-m',\
                             'Added files from Yeoman generator ' + parser.generator + ':' + parser.sub_generator],\
                            cwd=downstream_dir)\
\
    if not retcode == 0:\
        print(\\\"Failed to set commit the git changes. Check the verbose logs for details.\\\")\
        sys.exit(1)\
\
    print('Pushing changes to git')\
\
    _, _, retcode = execute([git_executable, 'push', 'origin', 'main'], cwd=downstream_dir)\
\
    if not retcode == 0:\
        print(\\\"Failed to push the git changes. Check the verbose logs for details.\\\")\
        sys.exit(1)\
\"
        \"PopulateGithubRepo.Yeoman.Generator.Package\"      = jsonencode({
          \"PackageId\" = \"OctopusSolutionsEngineering/ReferenceArchitectureAppGenerators\"
          \"FeedId\"    = local.github_feed_id
        })
        \"Octopus.Action.RunOnServer\"                  = \"true\"
        \"PopulateGithubRepo.Git.Url.Organization\"     = \"#{Git.Url.Organization}\"
        \"PopulateGithubRepo.Git.Url.Repo\"             = \"#{Octopus.Action[Create Repo].Output.NewRepo}\"
        \"PopulateGithubRepo.Git.Credentials.Password\" = \"#{Git.Credentials.Password}\"
      }

      container {
        feed_id = local.docker_hub_feed_id
        image   = \"octopussamples/node-workertools\"
      }

      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []

      package {
        name                      = \"YeomanGenerator\"
        package_id                = \"OctopusSolutionsEngineering/ReferenceArchitectureAppGenerators\"
        acquisition_location      = \"Server\"
        extract_during_deployment = false
        feed_id                   = local.github_feed_id
        properties                = {
          Extract       = \"True\", PackageParameterName = \"PopulateGithubRepo.Yeoman.Generator.Package\", Purpose = \"\",
          SelectionMode = \"deferred\"
        }
      }
      features = []
    }

    properties   = {}
    target_roles = []
  }
}
#endregion

#region Frontend
variable \"frontend_project_name\" {
  type    = string
  default = \"\"
}

data \"octopusdeploy_projects\" \"octopub_frontend\" {
  partial_name = var.frontend_project_name == \"\" ? local.frontend_project_name : var.frontend_project_name
  skip         = 0
  take         = 1
}

resource \"octopusdeploy_variable\" \"frontend_deployment_feed\" {
  count        = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0
  owner_id     = octopusdeploy_project.project_octopub_frontend[0].id
  value        = local.docker_hub_feed_id
  name         = \"Kubernetes.Deployment.Feed\"
  type         = \"String\"
  description  = \"The feed ID hosting the image\"
  is_sensitive = false
}

resource \"octopusdeploy_variable\" \"frontend_deployment_image\" {
  count        = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0
  owner_id     = octopusdeploy_project.project_octopub_frontend[0].id
  value        = \"octopussamples/octopub-frontend\"
  name         = \"Kubernetes.Deployment.Image\"
  type         = \"String\"
  description  = \"The image to deploy\"
  is_sensitive = false
}

resource \"octopusdeploy_variable\" \"frontend_deployment_port\" {
  count        = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0
  owner_id     = octopusdeploy_project.project_octopub_frontend[0].id
  value        = \"8080\"
  name         = \"Kubernetes.Deployment.Port\"
  type         = \"String\"
  description  = \"The port exposed by the web app\"
  is_sensitive = false
}

resource \"octopusdeploy_variable\" \"frontend_microservice_name\" {
  count        = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0
  owner_id     = octopusdeploy_project.project_octopub_frontend[0].id
  value        = \"frontend\"
  name         = \"Microservice.Name\"
  type         = \"String\"
  description  = \"The microservice name, which is used as the basis for K8s resources and networking paths\"
  is_sensitive = false
  depends_on   = []
}

resource \"octopusdeploy_variable\" \"frontend_deployment_name\" {
  count        = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0
  owner_id     = octopusdeploy_project.project_octopub_frontend[0].id
  value        = \"#{Microservice.Name}\"
  name         = \"Kubernetes.Deployment.Name\"
  type         = \"String\"
  description  = \"The name of the Kubernetes deployment resource\"
  is_sensitive = false
  depends_on   = []
}

resource \"octopusdeploy_variable\" \"frontend_service_name\" {
  count        = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0
  owner_id     = octopusdeploy_project.project_octopub_frontend[0].id
  value        = \"#{Microservice.Name}\"
  name         = \"Kubernetes.Service.Name\"
  type         = \"String\"
  description  = \"The name of the Kubernetes service resource\"
  is_sensitive = false
  depends_on   = []
}

resource \"octopusdeploy_variable\" \"frontend_ingress_path\" {
  count        = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0
  owner_id     = octopusdeploy_project.project_octopub_frontend[0].id
  value        = \"/#{Kubernetes.Namespace}(/.*)?\"
  name         = \"Kubernetes.Ingress.Path\"
  type         = \"String\"
  description  = \"The name of the Kubernetes ingress resource\"
  is_sensitive = false
  depends_on   = []
}

resource \"octopusdeploy_variable\" \"frontend_app_path\" {
  count        = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0
  owner_id     = octopusdeploy_project.project_octopub_frontend[0].id
  value        = \"/#{Kubernetes.Namespace}/index.html\"
  name         = \"Kubernetes.App.HealthCheck\"
  type         = \"String\"
  description  = \"The path to perform a health check on.\"
  is_sensitive = false
  depends_on   = []
}

resource \"octopusdeploy_variable\" \"frontend_ingress_name\" {
  count        = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0
  owner_id     = octopusdeploy_project.project_octopub_frontend[0].id
  value        = \"#{Microservice.Name}\"
  name         = \"Kubernetes.Ingress.Name\"
  type         = \"String\"
  description  = \"The name of the Kubernetes ingress resource\"
  is_sensitive = false
  depends_on   = []
}

resource \"octopusdeploy_variable\" \"frontend_namespace_default\" {
  count        = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0
  owner_id     = octopusdeploy_project.project_octopub_frontend[0].id
  value        = \"#{Octopus.Action.Kubernetes.Namespace}\"
  name         = \"Kubernetes.Namespace\"
  type         = \"String\"
  description  = \"The namespace to perform the deployments in.\"
  is_sensitive = false
  depends_on   = []
}

resource \"octopusdeploy_variable\" \"frontend_namespace_featurebranch\" {
  count        = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0
  owner_id     = octopusdeploy_project.project_octopub_frontend[0].id
  value        = \"\"
  name         = \"Kubernetes.Namespace\"
  type         = \"String\"
  description  = \"The custom namespace to use when deploying a feature branch\"
  is_sensitive = false

  scope {
    actions      = []
    channels     = []
    environments = [local.featurebranch_environment_id]
    machines     = []
    roles        = null
    tenant_tags  = null
  }

  prompt {
    description = \"Feature branch namespace\"
    label       = \"Namespace\"
    is_required = true
    display_settings {
      control_type = \"SingleLineText\"
    }
  }
}

resource \"octopusdeploy_channel\" \"frontend_featurebranch\" {
  count        = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0
  name         = \"Feature Branch\"
  project_id   = octopusdeploy_project.project_octopub_frontend[0].id
  description  = \"Deploy feature branch builds\"
  is_default   = false
  lifecycle_id = local.featurebranch_lifecycle_id
}

resource \"octopusdeploy_channel\" \"frontend_mainline\" {
  count        = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0
  name         = \"Mainline\"
  project_id   = octopusdeploy_project.project_octopub_frontend[0].id
  description  = \"Deploy mainline builds\"
  is_default   = true
  lifecycle_id = local.devops_lifecycle_id
  rule {
    tag = \"^$\"
    action_package {
      deployment_action = \"Deploy Container\"
      package_reference = \"web\"
    }
  }

  depends_on  = [octopusdeploy_deployment_process.deployment_process_octopub_frontend]
}

resource \"octopusdeploy_project\" \"project_octopub_frontend\" {
  count                                = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0
  name                                 = var.frontend_project_name == \"\" ? local.frontend_project_name : var.frontend_project_name
  auto_create_release                  = false
  default_guided_failure_mode          = \"Off\"
  default_to_skip_if_already_installed = false
  discrete_channel_release             = false
  is_disabled                          = false
  is_version_controlled                = false
  lifecycle_id                         = local.devops_lifecycle_id
  project_group_id                     = local.eks_project_group_id
  included_library_variable_sets       = [local.this_instance_library_variable_set, local.github_library_variable_set]
  tenanted_deployment_participation    = \"Untenanted\"

  connectivity_policy {
    allow_deployments_to_no_targets = true
    exclude_unhealthy_targets       = false
    skip_machine_behavior           = \"None\"
  }

  versioning_strategy {
    template = \"#{Octopus.Version.LastMajor}.#{Octopus.Version.LastMinor}.#{Octopus.Version.NextPatch}\"
  }

  lifecycle {
    ignore_changes = []
  }
  description = <<EOT
Deploys the Octopub Frontend

**Source**: [GitHub](https://github.com/OctopusSolutionsEngineering/Octopub)

**Build**: [GitHub Actions](https://github.com/OctopusSolutionsEngineering/Octopub/actions)

**Issues**: [GitHub Issues](https://github.com/OctopusSolutionsEngineering/Octopub/issues)
EOT
}

resource \"octopusdeploy_deployment_process\" \"deployment_process_octopub_frontend\" {
  count      = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0
  project_id = octopusdeploy_project.project_octopub_frontend[0].id

  step {
    condition           = \"Success\"
    name                = \"Generate Variables\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.Script\"
      name                               = \"Generate Variables\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"Octopus.Action.RunOnServer\"         = \"true\"
        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"
        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"
        \"Octopus.Action.Script.ScriptBody\"   = local.variable_script
      }
      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = []
  }

  step {
    condition           = \"Success\"
    name                = \"Deploy Container\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.KubernetesDeployContainers\"
      name                               = \"Deploy Container\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = true
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      worker_pool_variable               = \"\"
      properties                         = {
        \"Octopus.Action.KubernetesContainers.Namespace\"              = \"#{Kubernetes.Namespace}\"
        \"Octopus.Action.KubernetesContainers.Replicas\"               = \"1\"
        \"Octopus.Action.KubernetesContainers.DeploymentResourceType\" = \"Deployment\"
        \"Octopus.Action.KubernetesContainers.IngressAnnotations\"     = jsonencode([
          {
            \"optionError\"  = null
            \"option2\"      = \"\"
            \"option2Error\" = null
            \"key\"          = \"nginx.ingress.kubernetes.io/rewrite-target\"
            \"keyError\"     = null
            \"value\"        = \"$1\"
            \"valueError\"   = null
            \"option\"       = \"\"
          },
          {
            \"keyError\"     = null
            \"value\"        = \"true\"
            \"valueError\"   = null
            \"option\"       = \"\"
            \"optionError\"  = null
            \"option2\"      = \"\"
            \"option2Error\" = null
            \"key\"          = \"nginx.ingress.kubernetes.io/use-regex\"
          },
        ])
        \"Octopus.Action.KubernetesContainers.DeploymentStyle\" = \"RollingUpdate\"
        \"Octopus.Action.KubernetesContainers.IngressName\"     = \"#{Kubernetes.Ingress.Name}\"
        \"Octopus.Action.KubernetesContainers.DeploymentName\"  = \"#{Kubernetes.Deployment.Name}\"
        \"Octopus.Action.KubernetesContainers.IngressRules\"    = jsonencode([
          {
            \"host\" = \"\"
            \"http\" = {
              \"paths\" = [
                {
                  \"key\"     = \"#{Kubernetes.Ingress.Path}\"
                  \"value\"   = \"web\"
                  \"option\"  = \"\"
                  \"option2\" = \"ImplementationSpecific\"
                },
              ]
            }
          },
        ])
        \"OctopusUseBundledTooling\"                       = \"False\"
        \"Octopus.Action.KubernetesContainers.Containers\" = jsonencode([
          {
            \"Args\"                         = []
            \"FieldRefEnvironmentVariables\" = []
            \"SecretEnvFromSource\"          = []
            \"Command\"                      = []
            \"Ports\"                        = [
              {
                \"option2Error\" = null
                \"optionError\"  = null
                \"value\"        = \"#{Kubernetes.Deployment.Port}\"
                \"valueError\"   = null
                \"key\"          = \"web\"
                \"keyError\"     = null
                \"option\"       = \"TCP\"
                \"option2\"      = \"\"
              },
            ]
            \"Resources\" = {
              \"limits\" = {
                \"storage\"          = \"\"
                \"amdGpu\"           = \"\"
                \"cpu\"              = \"\"
                \"ephemeralStorage\" = \"\"
                \"memory\"           = \"\"
                \"nvidiaGpu\"        = \"\"
              }
              \"requests\" = {
                \"amdGpu\"           = \"\"
                \"cpu\"              = \"\"
                \"ephemeralStorage\" = \"\"
                \"memory\"           = \"\"
                \"nvidiaGpu\"        = \"\"
                \"storage\"          = \"\"
              }
            }
            \"SecretEnvironmentVariables\" = []
            \"SecurityContext\"            = {
              \"runAsNonRoot\"   = \"True\"
              \"runAsUser\"      = \"\"
              \"seLinuxOptions\" = {
                \"level\" = \"\"
                \"role\"  = \"\"
                \"type\"  = \"\"
                \"user\"  = \"\"
              }
              \"allowPrivilegeEscalation\" = \"\"
              \"capabilities\"             = {
                \"add\"  = []
                \"drop\" = [
                  \"ALL\",
                ]
              }
              \"privileged\"             = \"\"
              \"readOnlyRootFilesystem\" = \"\"
              \"runAsGroup\"             = \"\"
            }
            \"TerminationMessagePath\" = \"\"
            \"EnvironmentVariables\"   = [
              {
                \"key\"          = \"PORT\"
                \"keyError\"     = null
                \"value\"        = \"#{Kubernetes.Deployment.Port}\"
                \"valueError\"   = null
                \"option\"       = \"\"
                \"optionError\"  = null
                \"option2\"      = \"\"
                \"option2Error\" = null
              },
              {
                \"key\"          = \"UDL_SETVALUE_1\"
                \"keyError\"     = null
                \"value\"        = \"[/usr/share/nginx/html/config.json][productEndpoint]/#{Kubernetes.Namespace}/api/products\"
                \"valueError\"   = null
                \"option\"       = \"\"
                \"optionError\"  = null
                \"option2\"      = \"\"
                \"option2Error\" = null
              },
              {
                \"key\"          = \"UDL_SETVALUE_2\"
                \"keyError\"     = null
                \"value\"        = \"[/usr/share/nginx/html/config.json][productHealthEndpoint]/#{Kubernetes.Namespace}/health/products\"
                \"valueError\"   = null
                \"option\"       = \"\"
                \"optionError\"  = null
                \"option2\"      = \"\"
                \"option2Error\" = null
              },
              {
                \"key\"          = \"UDL_SETVALUE_3\"
                \"keyError\"     = null
                \"value\"        = \"[/usr/share/nginx/html/config.json][auditEndpoint]/#{Kubernetes.Namespace}/api/audits\"
                \"valueError\"   = null
                \"option\"       = \"\"
                \"optionError\"  = null
                \"option2\"      = \"\"
                \"option2Error\" = null
              },
              {
                \"key\"          = \"UDL_SETVALUE_4\"
                \"keyError\"     = null
                \"value\"        = \"[/usr/share/nginx/html/config.json][auditHealthEndpoint]/#{Kubernetes.Namespace}/health/audits\"
                \"valueError\"   = null
                \"option\"       = \"\"
                \"optionError\"  = null
                \"option2\"      = \"\"
                \"option2Error\" = null
              },
            ]
            \"LivenessProbe\" = {
              \"successThreshold\" = \"\"
              \"tcpSocket\"        = {
                \"port\" = \"\"
                \"host\" = \"\"
              }
              \"exec\" = {
                \"command\" = []
              }
              \"failureThreshold\" = \"\"
              \"periodSeconds\"    = \"\"
              \"type\"             = \"\"
              \"httpGet\"          = {
                \"host\"        = \"\"
                \"httpHeaders\" = []
                \"path\"        = \"\"
                \"port\"        = \"\"
                \"scheme\"      = \"\"
              }
              \"initialDelaySeconds\" = \"\"
              \"timeoutSeconds\"      = \"\"
            }
            \"ReadinessProbe\" = {
              \"exec\" = {
                \"command\" = []
              }
              \"failureThreshold\" = \"\"
              \"timeoutSeconds\"   = \"\"
              \"successThreshold\" = \"\"
              \"tcpSocket\"        = {
                \"host\" = \"\"
                \"port\" = \"\"
              }
              \"type\"    = \"\"
              \"httpGet\" = {
                \"host\"        = \"\"
                \"httpHeaders\" = []
                \"path\"        = \"\"
                \"port\"        = \"\"
                \"scheme\"      = \"\"
              }
              \"initialDelaySeconds\" = \"\"
              \"periodSeconds\"       = \"\"
            }
            \"TerminationMessagePolicy\"      = \"\"
            \"VolumeMounts\"                  = []
            \"ConfigMapEnvFromSource\"        = []
            \"ConfigMapEnvironmentVariables\" = []
            \"CreateFeedSecrets\"             = \"False\"
            \"Lifecycle\"                     = {
              \"PostStart\" = null
              \"PreStop\"   = null
            }
            \"Name\"         = \"web\"
            \"StartupProbe\" = {
              \"successThreshold\" = \"\"
              \"tcpSocket\"        = {
                \"host\" = \"\"
                \"port\" = \"\"
              }
              \"failureThreshold\" = \"\"
              \"httpGet\"          = {
                \"host\"        = \"\"
                \"httpHeaders\" = []
                \"path\"        = \"\"
                \"port\"        = \"\"
                \"scheme\"      = \"\"
              }
              \"initialDelaySeconds\" = \"\"
              \"type\"                = \"\"
              \"exec\"                = {
                \"command\" = []
              }
              \"periodSeconds\"  = \"\"
              \"timeoutSeconds\" = \"\"
            }
          },
        ])
        \"Octopus.Action.KubernetesContainers.ServiceName\"         = \"#{Kubernetes.Service.Name}\"
        \"Octopus.Action.KubernetesContainers.PodManagementPolicy\" = \"OrderedReady\"
        \"Octopus.Action.Kubernetes.DeploymentTimeout\"             = \"180\"
        \"Octopus.Action.RunOnServer\"                              = \"true\"
        \"Octopus.Action.KubernetesContainers.IngressClassName\"    = \"nginx\"
        \"Octopus.Action.KubernetesContainers.ServicePorts\"        = jsonencode([
          {
            \"port\"       = \"80\"
            \"protocol\"   = \"TCP\"
            \"targetPort\" = \"web\"
            \"name\"       = \"web\"
            \"nodePort\"   = \"\"
          },
        ])
        \"Octopus.Action.Kubernetes.ResourceStatusCheck\"       = \"True\"
        \"Octopus.Action.KubernetesContainers.ServiceNameType\" = \"External\"
        \"Octopus.Action.KubernetesContainers.ServiceType\"     = \"ClusterIP\"
      }
      container {
        feed_id = local.docker_hub_feed_id
        image   = \"octopuslabs/k8s-workertools\"
      }

      environments = [
        local.development_environment_id,
        local.test_environment_id,
        local.production_environment_id,
        local.featurebranch_environment_id,
      ]
      excluded_environments = []
      channels              = []
      tenant_tags           = []

      package {
        name                      = \"web\"
        package_id                = \"#{Kubernetes.Deployment.Image}\"
        acquisition_location      = \"NotAcquired\"
        extract_during_deployment = false
        feed_id                   = \"#{Kubernetes.Deployment.Feed}\"
        properties                = { Extract = \"False\", PackageParameterName = \"\", SelectionMode = \"immediate\" }
      }
      features = [
        \"\", \"Octopus.Features.KubernetesService\", \"Octopus.Features.KubernetesIngress\",
        \"Octopus.Features.KubernetesConfigMap\", \"Octopus.Features.KubernetesSecret\"
      ]
    }

    properties   = {}
    target_roles = [\"EKS_Reference_Cluster\"]
  }

  step {
    condition           = \"Success\"
    name                = \"Smoke Test\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.KubernetesRunScript\"
      name                               = \"Smoke Test\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"Octopus.Action.KubernetesContainers.Namespace\" = \"#{Kubernetes.Namespace}\"
        \"Octopus.Action.RunOnServer\"                    = \"true\"
        \"Octopus.Action.Script.ScriptSource\"            = \"Inline\"
        \"Octopus.Action.Script.Syntax\"                  = \"Bash\"
        \"Octopus.Action.Script.ScriptBody\"              = local.smoke_test
      }
      container {
        feed_id = local.docker_hub_feed_id
        image   = \"octopuslabs/k8s-workertools\"
      }
      environments = [
        local.development_environment_id,
        local.test_environment_id,
        local.production_environment_id,
        local.featurebranch_environment_id,
      ]
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = [\"EKS_Reference_Cluster\"]
  }

  step {
    condition           = \"Success\"
    name                = \"Security Scan\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.Script\"
      name                               = \"Security Scan\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = true
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"Octopus.Action.RunOnServer\"         = \"true\"
        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"
        \"Octopus.Action.Script.Syntax\"       = \"Bash\"
        \"Octopus.Action.Script.ScriptBody\"   = local.security_scan_script
      }
      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = []
  }

  step {
    condition           = \"Always\"
    name                = \"Feedback\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.Script\"
      name                               = \"Feedback\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"Octopus.Action.RunOnServer\"         = \"true\"
        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"
        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"
        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"
      }
      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = []
  }
}

resource \"octopusdeploy_runbook\" \"runbook_octopub_frontend_scale_to_zero\" {
  count             = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0
  name              = \"🌃 Scale Pods to Zero\"
  project_id        = octopusdeploy_project.project_octopub_frontend[0].id
  environment_scope = \"Specified\"
  environments      = [
    local.development_environment_id,
    local.test_environment_id,
    local.production_environment_id,
  ]
  force_package_download      = false
  default_guided_failure_mode = \"Off\"
  description                 = <<EOT
**WARNING**: This is a destructive operation. The service will no longer be available when scaled down.

**Action**: Scales the deployment down to zero pods.

**Affects**: The frontend service is effectively shut down.

This runbook is designed to be be run in non-production environments after hours to remove the Fargate nodes hosting
the service. This removes the cost of hosting the service out of hours.
EOT
  multi_tenancy_mode          = \"Untenanted\"

  retention_policy {
    quantity_to_keep    = 100
    should_keep_forever = false
  }

  connectivity_policy {
    allow_deployments_to_no_targets = true
    exclude_unhealthy_targets       = false
    skip_machine_behavior           = \"None\"
  }
}

resource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_frontend_scale_pods_to_zero\" {
  count      = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0
  runbook_id = octopusdeploy_runbook.runbook_octopub_frontend_scale_to_zero[0].id

  step {
    condition           = \"Success\"
    name                = \"Scale Pods to Zero\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.KubernetesRunScript\"
      name                               = \"Scale Pods to Zero\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = true
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      worker_pool_variable               = \"\"
      properties                         = {
        \"OctopusUseBundledTooling\"           = \"False\"
        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"
        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"
        \"Octopus.Action.Script.ScriptBody\"   = \"kubectl scale --replicas=0 deployment/#{Kubernetes.Deployment.Name}\"
        \"Octopus.Action.RunOnServer\"         = \"true\"
      }

      container {
        feed_id = local.docker_hub_feed_id
        image   = \"octopuslabs/k8s-workertools\"
      }

      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = [\"EKS_Reference_Cluster\"]
  }

  step {
    condition           = \"Always\"
    name                = \"Feedback\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.Script\"
      name                               = \"Feedback\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"Octopus.Action.RunOnServer\"         = \"true\"
        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"
        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"
        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"
      }
      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = []
  }
}

resource \"octopusdeploy_runbook\" \"runbook_octopub_frontend_scale_to_one\" {
  count             = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0
  name              = \"🌇 Scale Pods to One\"
  project_id        = octopusdeploy_project.project_octopub_frontend[0].id
  environment_scope = \"Specified\"
  environments      = [
    local.development_environment_id,
    local.test_environment_id,
    local.production_environment_id,
  ]
  force_package_download      = false
  default_guided_failure_mode = \"Off\"
  description                 = <<EOT
**Action**: Scales the deployment to one pod.

**Affects**: Frontend service - this will create new pods if the deployment has been scaled to zero.

This runbook is designed to be be run in non-production environments during office hours to recreate the pods after they
were shutdown after hours.
EOT
  multi_tenancy_mode          = \"Untenanted\"

  retention_policy {
    quantity_to_keep    = 100
    should_keep_forever = false
  }

  connectivity_policy {
    allow_deployments_to_no_targets = true
    exclude_unhealthy_targets       = false
    skip_machine_behavior           = \"None\"
  }
}

resource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_frontend_scale_pods_to_one\" {
  count      = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0
  runbook_id = octopusdeploy_runbook.runbook_octopub_frontend_scale_to_one[0].id

  step {
    condition           = \"Success\"
    name                = \"Scale Pods to One\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.KubernetesRunScript\"
      name                               = \"Scale Pods to One\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = true
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      worker_pool_variable               = \"\"
      properties                         = {
        \"OctopusUseBundledTooling\"           = \"False\"
        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"
        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"
        \"Octopus.Action.Script.ScriptBody\"   = \"kubectl scale --replicas=1 deployment/#{Kubernetes.Deployment.Name}\"
        \"Octopus.Action.RunOnServer\"         = \"true\"
      }

      container {
        feed_id = local.docker_hub_feed_id
        image   = \"octopuslabs/k8s-workertools\"
      }

      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = [\"EKS_Reference_Cluster\"]
  }

  step {
    condition           = \"Always\"
    name                = \"Feedback\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.Script\"
      name                               = \"Feedback\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"Octopus.Action.RunOnServer\"         = \"true\"
        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"
        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"
        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"
      }
      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = []
  }
}

resource \"octopusdeploy_runbook\" \"runbook_octopub_frontend_get_pod_logs\" {
  count             = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0
  name              = \"🛠️ Get Pod Logs\"
  project_id        = octopusdeploy_project.project_octopub_frontend[0].id
  environment_scope = \"Specified\"
  environments      = [
    local.development_environment_id,
    local.test_environment_id,
    local.production_environment_id,
  ]
  force_package_download      = false
  default_guided_failure_mode = \"Off\"
  description                 = <<EOT
**Action**: Returns the pod logs.

**Affects**: Nothing - this runbook makes no changes.
EOT
  multi_tenancy_mode          = \"Untenanted\"

  retention_policy {
    quantity_to_keep    = 100
    should_keep_forever = false
  }

  connectivity_policy {
    allow_deployments_to_no_targets = true
    exclude_unhealthy_targets       = false
    skip_machine_behavior           = \"None\"
  }
}

resource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_frontend_get_pod_logs\" {
  count      = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0
  runbook_id = octopusdeploy_runbook.runbook_octopub_frontend_get_pod_logs[0].id

  step {
    condition           = \"Success\"
    name                = \"Get Pod Logs\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.KubernetesRunScript\"
      name                               = \"Get Pod Logs\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      worker_pool_variable               = \"\"
      properties                         = {
        \"K8SInspectCreateArtifact\"                      = \"False\"
        \"Octopus.Action.Script.ScriptBody\"              = \"<#\
    This script provides a general purpose method for querying Kubernetes resources. It supports common operations\
    like get, describe, logs and output formats like yaml and json. Output can be captured as artifacts.\
#>\
\
<#\
.Description\
Execute an application, capturing the output. Based on https://stackoverflow.com/a/33652732/157605\
#>\
Function Execute-Command ($commandPath, $commandArguments)\
{\
  Write-Host \\\"Executing: $commandPath $($commandArguments -join \\\" \\\")\\\"\
  \
  Try {\
    $pinfo = New-Object System.Diagnostics.ProcessStartInfo\
    $pinfo.FileName = $commandPath\
    $pinfo.RedirectStandardError = $true\
    $pinfo.RedirectStandardOutput = $true\
    $pinfo.UseShellExecute = $false\
    $pinfo.Arguments = $commandArguments\
    $p = New-Object System.Diagnostics.Process\
    $p.StartInfo = $pinfo\
    $p.Start() | Out-Null\
    [pscustomobject]@{\
        stdout = $p.StandardOutput.ReadToEnd()\
        stderr = $p.StandardError.ReadToEnd()\
        ExitCode = $p.ExitCode\
    }\
    $p.WaitForExit()\
  }\
  Catch {\
     exit\
  }\
}\
\
<#\
.Description\
Find any resource names that match a wildcard input if one was specified\
#>\
function Get-Resources() \
{\
    $names = $OctopusParameters[\\\"K8SInspectNames\\\"] -Split \\\"`n\\\" | % {$_.Trim()}\
    \
    if ($OctopusParameters[\\\"K8SInspectNames\\\"] -match '\\\\*' )\
    {\
        return Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", $OctopusParameters[\\\"K8SInspectResource\\\"])) |\
            # Select the stdout property from the execution\
            Select-Object -ExpandProperty stdout |\
            # Convert the output from JSON\
            ConvertFrom-JSON | \
            # Get the items object from the kubectl response\
            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\
            # Extract the name\
            % {$_.metadata.name} |\
            # Find any matching resources\
            ? {$k8sName = $_; ($names | ? {$k8sName -like $_}).Count -ne 0}\
    }\
    else\
    {\
        return $names\
    }\
}\
\
<#\
.Description\
Get the kubectl arguments for a given action\
#>\
function Get-KubectlVerb() \
{\
    switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\
    {\
        \\\"get json\\\" {return ,@(\\\"-o\\\", \\\"json\\\", \\\"get\\\")}\
        \\\"get yaml\\\" {return ,@(\\\"-o\\\", \\\"yaml\\\", \\\"get\\\")}\
        \\\"describe\\\" {return ,@(\\\"describe\\\")}\
        \\\"logs\\\" {return ,@(\\\"logs\\\")}\
        \\\"logs tail\\\" {return ,@(\\\"logs\\\", \\\"--tail\\\", \\\"100\\\")}\
        \\\"previous logs\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\")}\
        \\\"previous logs tail\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\", \\\"--tail\\\", \\\"100\\\")}\
        default {return ,@(\\\"get\\\")}\
    }\
}\
\
<#\
.Description\
Get an appropiate file extension based on the selected action\
#>\
function Get-ArtifactExtension() \
{\
   switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\
    {\
        \\\"get json\\\" {\\\"json\\\"}\
        \\\"get yaml\\\" {\\\"yaml\\\"}\
        default {\\\"txt\\\"}\
    }\
}\
\
if ($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"] -like \\\"*logs*\\\") \
{\
    if ( -not @($OctopusParameters[\\\"K8SInspectResource\\\"]) -like \\\"pod*\\\")\
    {\
        Write-Error \\\"Logs can only be returned for pods, not $($OctopusParameters[\\\"K8SInspectResource\\\"])\\\"\
    }\
    else\
    {\
        Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", \\\"pods\\\") + (Get-Resources)) |\
            # Select the stdout property from the execution\
            Select-Object -ExpandProperty stdout |\
            # Convert the output from JSON\
            ConvertFrom-JSON | \
            # Get the items object from the kubectl response\
            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\
            # Get the pod logs for each container\
            % {\
                $podDetails = $_\
                @{\
                    logs=$podDetails.spec.containers | % {$logs=\\\"\\\"} {$logs += (Select-Object -InputObject (Execute-Command kubectl ((Get-KubectlVerb) + @($podDetails.metadata.name, \\\"-c\\\", $_.name))) -ExpandProperty stdout)} {$logs}; \
                    name=$podDetails.metadata.name\
                }                \
            } |\
            # Write the output\
            % {Write-Host $_.logs; $_} |\
            # Optionally capture the artifact\
            % {\
                if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \
                {\
                    Set-Content -Path \\\"$($_.name).$(Get-ArtifactExtension)\\\" -Value $_.logs\
                    New-OctopusArtifact \\\"$($_.name).$(Get-ArtifactExtension)\\\"\
                }\
            }\
    }      \
}\
else\
{\
    Execute-Command kubectl ((Get-KubectlVerb) + @($OctopusParameters[\\\"K8SInspectResource\\\"]) + (Get-Resources)) |\
        % {Select-Object -InputObject $_ -ExpandProperty stdout} |\
        % {Write-Host $_; $_} |\
        % {\
            if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \
            {\
                Set-Content -Path \\\"output.$(Get-ArtifactExtension)\\\" -Value $_\
                New-OctopusArtifact \\\"output.$(Get-ArtifactExtension)\\\"\
            }\
        }\
}\
\"
        \"Octopus.Action.Script.ScriptSource\"            = \"Inline\"
        \"K8SInspectResource\"                            = \"pod\"
        \"Octopus.Action.Script.Syntax\"                  = \"PowerShell\"
        \"Octopus.Action.KubernetesContainers.Namespace\" = \"#{if K8SInspectNamespace}#{K8SInspectNamespace}#{/if}#{unless K8SInspectNamespace}#{Octopus.Action.Kubernetes.Namespace}#{/unless}\"
        \"K8SInspectNames\"                               = \"#{Kubernetes.Deployment.Name}*\"
        \"K8SInspectKubectlVerb\"                         = \"logs\"
      }
      container {
        feed_id = local.docker_hub_feed_id
        image   = \"octopuslabs/k8s-workertools\"
      }
      environments = [
        local.development_environment_id,
        local.test_environment_id,
        local.production_environment_id,
      ]
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = [\"EKS_Reference_Cluster\"]
  }

  step {
    condition           = \"Always\"
    name                = \"Feedback\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.Script\"
      name                               = \"Feedback\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"Octopus.Action.RunOnServer\"         = \"true\"
        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"
        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"
        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"
      }
      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = []
  }
}

resource \"octopusdeploy_runbook\" \"runbook_octopub_frontend_get_pods\" {
  count             = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0
  name              = \"🛠️ Get Pods\"
  project_id        = octopusdeploy_project.project_octopub_frontend[0].id
  environment_scope = \"Specified\"
  environments      = [
    local.development_environment_id,
    local.test_environment_id,
    local.production_environment_id,
  ]
  force_package_download      = false
  default_guided_failure_mode = \"Off\"
  description                 = <<EOT
**Action**: Returns the pods.

**Affects**: Nothing - this runbook makes no changes.
EOT
  multi_tenancy_mode          = \"Untenanted\"

  retention_policy {
    quantity_to_keep    = 100
    should_keep_forever = false
  }

  connectivity_policy {
    allow_deployments_to_no_targets = true
    exclude_unhealthy_targets       = false
    skip_machine_behavior           = \"None\"
  }
}

resource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_frontend_get_pods\" {
  count      = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0
  runbook_id = octopusdeploy_runbook.runbook_octopub_frontend_get_pods[0].id

  step {
    condition           = \"Success\"
    name                = \"Get Pods\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.KubernetesRunScript\"
      name                               = \"Get Pods\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = \"\"
      worker_pool_variable               = \"OctopusInstance.WorkerPool.Id\"
      properties                         = {
        \"K8SInspectCreateArtifact\"                      = \"False\"
        \"Octopus.Action.Script.ScriptBody\"              = \"<#\
    This script provides a general purpose method for querying Kubernetes resources. It supports common operations\
    like get, describe, logs and output formats like yaml and json. Output can be captured as artifacts.\
#>\
\
<#\
.Description\
Execute an application, capturing the output. Based on https://stackoverflow.com/a/33652732/157605\
#>\
Function Execute-Command ($commandPath, $commandArguments)\
{\
  Write-Host \\\"Executing: $commandPath $($commandArguments -join \\\" \\\")\\\"\
  \
  Try {\
    $pinfo = New-Object System.Diagnostics.ProcessStartInfo\
    $pinfo.FileName = $commandPath\
    $pinfo.RedirectStandardError = $true\
    $pinfo.RedirectStandardOutput = $true\
    $pinfo.UseShellExecute = $false\
    $pinfo.Arguments = $commandArguments\
    $p = New-Object System.Diagnostics.Process\
    $p.StartInfo = $pinfo\
    $p.Start() | Out-Null\
    [pscustomobject]@{\
        stdout = $p.StandardOutput.ReadToEnd()\
        stderr = $p.StandardError.ReadToEnd()\
        ExitCode = $p.ExitCode\
    }\
    $p.WaitForExit()\
  }\
  Catch {\
     exit\
  }\
}\
\
<#\
.Description\
Find any resource names that match a wildcard input if one was specified\
#>\
function Get-Resources() \
{\
    $names = $OctopusParameters[\\\"K8SInspectNames\\\"] -Split \\\"`n\\\" | % {$_.Trim()}\
    \
    if ($OctopusParameters[\\\"K8SInspectNames\\\"] -match '\\\\*' )\
    {\
        return Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", $OctopusParameters[\\\"K8SInspectResource\\\"])) |\
            # Select the stdout property from the execution\
            Select-Object -ExpandProperty stdout |\
            # Convert the output from JSON\
            ConvertFrom-JSON | \
            # Get the items object from the kubectl response\
            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\
            # Extract the name\
            % {$_.metadata.name} |\
            # Find any matching resources\
            ? {$k8sName = $_; ($names | ? {$k8sName -like $_}).Count -ne 0}\
    }\
    else\
    {\
        return $names\
    }\
}\
\
<#\
.Description\
Get the kubectl arguments for a given action\
#>\
function Get-KubectlVerb() \
{\
    switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\
    {\
        \\\"get json\\\" {return ,@(\\\"-o\\\", \\\"json\\\", \\\"get\\\")}\
        \\\"get yaml\\\" {return ,@(\\\"-o\\\", \\\"yaml\\\", \\\"get\\\")}\
        \\\"describe\\\" {return ,@(\\\"describe\\\")}\
        \\\"logs\\\" {return ,@(\\\"logs\\\")}\
        \\\"logs tail\\\" {return ,@(\\\"logs\\\", \\\"--tail\\\", \\\"100\\\")}\
        \\\"previous logs\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\")}\
        \\\"previous logs tail\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\", \\\"--tail\\\", \\\"100\\\")}\
        default {return ,@(\\\"get\\\")}\
    }\
}\
\
<#\
.Description\
Get an appropiate file extension based on the selected action\
#>\
function Get-ArtifactExtension() \
{\
   switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\
    {\
        \\\"get json\\\" {\\\"json\\\"}\
        \\\"get yaml\\\" {\\\"yaml\\\"}\
        default {\\\"txt\\\"}\
    }\
}\
\
if ($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"] -like \\\"*logs*\\\") \
{\
    if ( -not @($OctopusParameters[\\\"K8SInspectResource\\\"]) -like \\\"pod*\\\")\
    {\
        Write-Error \\\"Logs can only be returned for pods, not $($OctopusParameters[\\\"K8SInspectResource\\\"])\\\"\
    }\
    else\
    {\
        Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", \\\"pods\\\") + (Get-Resources)) |\
            # Select the stdout property from the execution\
            Select-Object -ExpandProperty stdout |\
            # Convert the output from JSON\
            ConvertFrom-JSON | \
            # Get the items object from the kubectl response\
            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\
            # Get the pod logs for each container\
            % {\
                $podDetails = $_\
                @{\
                    logs=$podDetails.spec.containers | % {$logs=\\\"\\\"} {$logs += (Select-Object -InputObject (Execute-Command kubectl ((Get-KubectlVerb) + @($podDetails.metadata.name, \\\"-c\\\", $_.name))) -ExpandProperty stdout)} {$logs}; \
                    name=$podDetails.metadata.name\
                }                \
            } |\
            # Write the output\
            % {Write-Host $_.logs; $_} |\
            # Optionally capture the artifact\
            % {\
                if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \
                {\
                    Set-Content -Path \\\"$($_.name).$(Get-ArtifactExtension)\\\" -Value $_.logs\
                    New-OctopusArtifact \\\"$($_.name).$(Get-ArtifactExtension)\\\"\
                }\
            }\
    }      \
}\
else\
{\
    Execute-Command kubectl ((Get-KubectlVerb) + @($OctopusParameters[\\\"K8SInspectResource\\\"]) + (Get-Resources)) |\
        % {Select-Object -InputObject $_ -ExpandProperty stdout} |\
        % {Write-Host $_; $_} |\
        % {\
            if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \
            {\
                Set-Content -Path \\\"output.$(Get-ArtifactExtension)\\\" -Value $_\
                New-OctopusArtifact \\\"output.$(Get-ArtifactExtension)\\\"\
            }\
        }\
}\
\"
        \"Octopus.Action.Script.ScriptSource\"            = \"Inline\"
        \"K8SInspectResource\"                            = \"pod\"
        \"Octopus.Action.Script.Syntax\"                  = \"PowerShell\"
        \"Octopus.Action.KubernetesContainers.Namespace\" = \"#{if K8SInspectNamespace}#{K8SInspectNamespace}#{/if}#{unless K8SInspectNamespace}#{Octopus.Action.Kubernetes.Namespace}#{/unless}\"
        \"K8SInspectNames\"                               = \"#{Kubernetes.Deployment.Name}*\"
        \"K8SInspectKubectlVerb\"                         = \"get\"
      }
      container {
        feed_id = local.docker_hub_feed_id
        image   = \"octopuslabs/k8s-workertools\"
      }
      environments = [
        local.development_environment_id,
        local.test_environment_id,
        local.production_environment_id,
      ]
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = [\"EKS_Reference_Cluster\"]
  }

  step {
    condition           = \"Always\"
    name                = \"Feedback\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.Script\"
      name                               = \"Feedback\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"Octopus.Action.RunOnServer\"         = \"true\"
        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"
        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"
        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"
      }
      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = []
  }
}

resource \"octopusdeploy_runbook\" \"runbook_octopub_frontend_describe_pods\" {
  count             = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0
  name              = \"🛠️ Describe Pods\"
  project_id        = octopusdeploy_project.project_octopub_frontend[0].id
  environment_scope = \"Specified\"
  environments      = [
    local.development_environment_id,
    local.test_environment_id,
    local.production_environment_id,
  ]
  force_package_download      = false
  default_guided_failure_mode = \"Off\"
  description                 = <<EOT
**Action**: Returns the pods.

**Affects**: Nothing - this runbook makes no changes.
EOT
  multi_tenancy_mode          = \"Untenanted\"

  retention_policy {
    quantity_to_keep    = 100
    should_keep_forever = false
  }

  connectivity_policy {
    allow_deployments_to_no_targets = true
    exclude_unhealthy_targets       = false
    skip_machine_behavior           = \"None\"
  }
}

resource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_frontend_describe_pods\" {
  count      = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0
  runbook_id = octopusdeploy_runbook.runbook_octopub_frontend_describe_pods[0].id

  step {
    condition           = \"Success\"
    name                = \"Describe Pods\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.KubernetesRunScript\"
      name                               = \"Describe Pods\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      worker_pool_variable               = \"\"
      properties                         = {
        \"K8SInspectCreateArtifact\"                      = \"False\"
        \"Octopus.Action.Script.ScriptBody\"              = \"<#\
    This script provides a general purpose method for querying Kubernetes resources. It supports common operations\
    like get, describe, logs and output formats like yaml and json. Output can be captured as artifacts.\
#>\
\
<#\
.Description\
Execute an application, capturing the output. Based on https://stackoverflow.com/a/33652732/157605\
#>\
Function Execute-Command ($commandPath, $commandArguments)\
{\
  Write-Host \\\"Executing: $commandPath $($commandArguments -join \\\" \\\")\\\"\
  \
  Try {\
    $pinfo = New-Object System.Diagnostics.ProcessStartInfo\
    $pinfo.FileName = $commandPath\
    $pinfo.RedirectStandardError = $true\
    $pinfo.RedirectStandardOutput = $true\
    $pinfo.UseShellExecute = $false\
    $pinfo.Arguments = $commandArguments\
    $p = New-Object System.Diagnostics.Process\
    $p.StartInfo = $pinfo\
    $p.Start() | Out-Null\
    [pscustomobject]@{\
        stdout = $p.StandardOutput.ReadToEnd()\
        stderr = $p.StandardError.ReadToEnd()\
        ExitCode = $p.ExitCode\
    }\
    $p.WaitForExit()\
  }\
  Catch {\
     exit\
  }\
}\
\
<#\
.Description\
Find any resource names that match a wildcard input if one was specified\
#>\
function Get-Resources() \
{\
    $names = $OctopusParameters[\\\"K8SInspectNames\\\"] -Split \\\"`n\\\" | % {$_.Trim()}\
    \
    if ($OctopusParameters[\\\"K8SInspectNames\\\"] -match '\\\\*' )\
    {\
        return Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", $OctopusParameters[\\\"K8SInspectResource\\\"])) |\
            # Select the stdout property from the execution\
            Select-Object -ExpandProperty stdout |\
            # Convert the output from JSON\
            ConvertFrom-JSON | \
            # Get the items object from the kubectl response\
            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\
            # Extract the name\
            % {$_.metadata.name} |\
            # Find any matching resources\
            ? {$k8sName = $_; ($names | ? {$k8sName -like $_}).Count -ne 0}\
    }\
    else\
    {\
        return $names\
    }\
}\
\
<#\
.Description\
Get the kubectl arguments for a given action\
#>\
function Get-KubectlVerb() \
{\
    switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\
    {\
        \\\"get json\\\" {return ,@(\\\"-o\\\", \\\"json\\\", \\\"get\\\")}\
        \\\"get yaml\\\" {return ,@(\\\"-o\\\", \\\"yaml\\\", \\\"get\\\")}\
        \\\"describe\\\" {return ,@(\\\"describe\\\")}\
        \\\"logs\\\" {return ,@(\\\"logs\\\")}\
        \\\"logs tail\\\" {return ,@(\\\"logs\\\", \\\"--tail\\\", \\\"100\\\")}\
        \\\"previous logs\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\")}\
        \\\"previous logs tail\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\", \\\"--tail\\\", \\\"100\\\")}\
        default {return ,@(\\\"get\\\")}\
    }\
}\
\
<#\
.Description\
Get an appropiate file extension based on the selected action\
#>\
function Get-ArtifactExtension() \
{\
   switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\
    {\
        \\\"get json\\\" {\\\"json\\\"}\
        \\\"get yaml\\\" {\\\"yaml\\\"}\
        default {\\\"txt\\\"}\
    }\
}\
\
if ($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"] -like \\\"*logs*\\\") \
{\
    if ( -not @($OctopusParameters[\\\"K8SInspectResource\\\"]) -like \\\"pod*\\\")\
    {\
        Write-Error \\\"Logs can only be returned for pods, not $($OctopusParameters[\\\"K8SInspectResource\\\"])\\\"\
    }\
    else\
    {\
        Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", \\\"pods\\\") + (Get-Resources)) |\
            # Select the stdout property from the execution\
            Select-Object -ExpandProperty stdout |\
            # Convert the output from JSON\
            ConvertFrom-JSON | \
            # Get the items object from the kubectl response\
            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\
            # Get the pod logs for each container\
            % {\
                $podDetails = $_\
                @{\
                    logs=$podDetails.spec.containers | % {$logs=\\\"\\\"} {$logs += (Select-Object -InputObject (Execute-Command kubectl ((Get-KubectlVerb) + @($podDetails.metadata.name, \\\"-c\\\", $_.name))) -ExpandProperty stdout)} {$logs}; \
                    name=$podDetails.metadata.name\
                }                \
            } |\
            # Write the output\
            % {Write-Host $_.logs; $_} |\
            # Optionally capture the artifact\
            % {\
                if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \
                {\
                    Set-Content -Path \\\"$($_.name).$(Get-ArtifactExtension)\\\" -Value $_.logs\
                    New-OctopusArtifact \\\"$($_.name).$(Get-ArtifactExtension)\\\"\
                }\
            }\
    }      \
}\
else\
{\
    Execute-Command kubectl ((Get-KubectlVerb) + @($OctopusParameters[\\\"K8SInspectResource\\\"]) + (Get-Resources)) |\
        % {Select-Object -InputObject $_ -ExpandProperty stdout} |\
        % {Write-Host $_; $_} |\
        % {\
            if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \
            {\
                Set-Content -Path \\\"output.$(Get-ArtifactExtension)\\\" -Value $_\
                New-OctopusArtifact \\\"output.$(Get-ArtifactExtension)\\\"\
            }\
        }\
}\
\"
        \"Octopus.Action.Script.ScriptSource\"            = \"Inline\"
        \"K8SInspectResource\"                            = \"pod\"
        \"Octopus.Action.Script.Syntax\"                  = \"PowerShell\"
        \"Octopus.Action.KubernetesContainers.Namespace\" = \"#{if K8SInspectNamespace}#{K8SInspectNamespace}#{/if}#{unless K8SInspectNamespace}#{Octopus.Action.Kubernetes.Namespace}#{/unless}\"
        \"K8SInspectNames\"                               = \"#{Kubernetes.Deployment.Name}*\"
        \"K8SInspectKubectlVerb\"                         = \"describe\"
      }
      container {
        feed_id = local.docker_hub_feed_id
        image   = \"octopuslabs/k8s-workertools\"
      }
      environments = [
        local.development_environment_id,
        local.test_environment_id,
        local.production_environment_id,
      ]
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = [\"EKS_Reference_Cluster\"]
  }

  step {
    condition           = \"Always\"
    name                = \"Feedback\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.Script\"
      name                               = \"Feedback\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"Octopus.Action.RunOnServer\"         = \"true\"
        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"
        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"
        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"
      }
      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = []
  }
}

resource \"octopusdeploy_runbook\" \"runbook_octopub_frontend_get_ingress\" {
  count             = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0
  name              = \"🛠️ Get Ingress\"
  project_id        = octopusdeploy_project.project_octopub_frontend[0].id
  environment_scope = \"Specified\"
  environments      = [
    local.development_environment_id,
    local.test_environment_id,
    local.production_environment_id,
  ]
  force_package_download      = false
  default_guided_failure_mode = \"Off\"
  description                 = <<EOT
**Action**: Returns the ingresses.

**Affects**: Nothing - this runbook makes no changes.

**Resolves**: Finding the public IP to access the deployed application.
EOT
  multi_tenancy_mode          = \"Untenanted\"

  retention_policy {
    quantity_to_keep    = 100
    should_keep_forever = false
  }

  connectivity_policy {
    allow_deployments_to_no_targets = true
    exclude_unhealthy_targets       = false
    skip_machine_behavior           = \"None\"
  }
}

resource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_frontend_get_ingress\" {
  count      = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0
  runbook_id = octopusdeploy_runbook.runbook_octopub_frontend_get_ingress[0].id

  step {
    condition           = \"Success\"
    name                = \"Get Ingress\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.KubernetesRunScript\"
      name                               = \"Get Ingress\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      worker_pool_variable               = \"\"
      properties                         = {
        \"K8SInspectCreateArtifact\"                      = \"False\"
        \"Octopus.Action.Script.ScriptBody\"              = \"<#\
    This script provides a general purpose method for querying Kubernetes resources. It supports common operations\
    like get, describe, logs and output formats like yaml and json. Output can be captured as artifacts.\
#>\
\
<#\
.Description\
Execute an application, capturing the output. Based on https://stackoverflow.com/a/33652732/157605\
#>\
Function Execute-Command ($commandPath, $commandArguments)\
{\
  Write-Host \\\"Executing: $commandPath $($commandArguments -join \\\" \\\")\\\"\
  \
  Try {\
    $pinfo = New-Object System.Diagnostics.ProcessStartInfo\
    $pinfo.FileName = $commandPath\
    $pinfo.RedirectStandardError = $true\
    $pinfo.RedirectStandardOutput = $true\
    $pinfo.UseShellExecute = $false\
    $pinfo.Arguments = $commandArguments\
    $p = New-Object System.Diagnostics.Process\
    $p.StartInfo = $pinfo\
    $p.Start() | Out-Null\
    [pscustomobject]@{\
        stdout = $p.StandardOutput.ReadToEnd()\
        stderr = $p.StandardError.ReadToEnd()\
        ExitCode = $p.ExitCode\
    }\
    $p.WaitForExit()\
  }\
  Catch {\
     exit\
  }\
}\
\
<#\
.Description\
Find any resource names that match a wildcard input if one was specified\
#>\
function Get-Resources() \
{\
    $names = $OctopusParameters[\\\"K8SInspectNames\\\"] -Split \\\"`n\\\" | % {$_.Trim()}\
    \
    if ($OctopusParameters[\\\"K8SInspectNames\\\"] -match '\\\\*' )\
    {\
        return Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", $OctopusParameters[\\\"K8SInspectResource\\\"])) |\
            # Select the stdout property from the execution\
            Select-Object -ExpandProperty stdout |\
            # Convert the output from JSON\
            ConvertFrom-JSON | \
            # Get the items object from the kubectl response\
            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\
            # Extract the name\
            % {$_.metadata.name} |\
            # Find any matching resources\
            ? {$k8sName = $_; ($names | ? {$k8sName -like $_}).Count -ne 0}\
    }\
    else\
    {\
        return $names\
    }\
}\
\
<#\
.Description\
Get the kubectl arguments for a given action\
#>\
function Get-KubectlVerb() \
{\
    switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\
    {\
        \\\"get json\\\" {return ,@(\\\"-o\\\", \\\"json\\\", \\\"get\\\")}\
        \\\"get yaml\\\" {return ,@(\\\"-o\\\", \\\"yaml\\\", \\\"get\\\")}\
        \\\"describe\\\" {return ,@(\\\"describe\\\")}\
        \\\"logs\\\" {return ,@(\\\"logs\\\")}\
        \\\"logs tail\\\" {return ,@(\\\"logs\\\", \\\"--tail\\\", \\\"100\\\")}\
        \\\"previous logs\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\")}\
        \\\"previous logs tail\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\", \\\"--tail\\\", \\\"100\\\")}\
        default {return ,@(\\\"get\\\")}\
    }\
}\
\
<#\
.Description\
Get an appropiate file extension based on the selected action\
#>\
function Get-ArtifactExtension() \
{\
   switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\
    {\
        \\\"get json\\\" {\\\"json\\\"}\
        \\\"get yaml\\\" {\\\"yaml\\\"}\
        default {\\\"txt\\\"}\
    }\
}\
\
if ($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"] -like \\\"*logs*\\\") \
{\
    if ( -not @($OctopusParameters[\\\"K8SInspectResource\\\"]) -like \\\"pod*\\\")\
    {\
        Write-Error \\\"Logs can only be returned for pods, not $($OctopusParameters[\\\"K8SInspectResource\\\"])\\\"\
    }\
    else\
    {\
        Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", \\\"pods\\\") + (Get-Resources)) |\
            # Select the stdout property from the execution\
            Select-Object -ExpandProperty stdout |\
            # Convert the output from JSON\
            ConvertFrom-JSON | \
            # Get the items object from the kubectl response\
            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\
            # Get the pod logs for each container\
            % {\
                $podDetails = $_\
                @{\
                    logs=$podDetails.spec.containers | % {$logs=\\\"\\\"} {$logs += (Select-Object -InputObject (Execute-Command kubectl ((Get-KubectlVerb) + @($podDetails.metadata.name, \\\"-c\\\", $_.name))) -ExpandProperty stdout)} {$logs}; \
                    name=$podDetails.metadata.name\
                }                \
            } |\
            # Write the output\
            % {Write-Host $_.logs; $_} |\
            # Optionally capture the artifact\
            % {\
                if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \
                {\
                    Set-Content -Path \\\"$($_.name).$(Get-ArtifactExtension)\\\" -Value $_.logs\
                    New-OctopusArtifact \\\"$($_.name).$(Get-ArtifactExtension)\\\"\
                }\
            }\
    }      \
}\
else\
{\
    Execute-Command kubectl ((Get-KubectlVerb) + @($OctopusParameters[\\\"K8SInspectResource\\\"]) + (Get-Resources)) |\
        % {Select-Object -InputObject $_ -ExpandProperty stdout} |\
        % {Write-Host $_; $_} |\
        % {\
            if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \
            {\
                Set-Content -Path \\\"output.$(Get-ArtifactExtension)\\\" -Value $_\
                New-OctopusArtifact \\\"output.$(Get-ArtifactExtension)\\\"\
            }\
        }\
}\
\"
        \"Octopus.Action.Script.ScriptSource\"            = \"Inline\"
        \"K8SInspectResource\"                            = \"ingress\"
        \"Octopus.Action.Script.Syntax\"                  = \"PowerShell\"
        \"Octopus.Action.KubernetesContainers.Namespace\" = \"#{if K8SInspectNamespace}#{K8SInspectNamespace}#{/if}#{unless K8SInspectNamespace}#{Octopus.Action.Kubernetes.Namespace}#{/unless}\"
        \"K8SInspectNames\"                               = \"#{Kubernetes.Ingress.Name}*\"
        \"K8SInspectKubectlVerb\"                         = \"get\"
      }
      container {
        feed_id = local.docker_hub_feed_id
        image   = \"octopuslabs/k8s-workertools\"
      }
      environments = [
        local.development_environment_id,
        local.test_environment_id,
        local.production_environment_id,
      ]
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = [\"EKS_Reference_Cluster\"]
  }

  step {
    condition           = \"Always\"
    name                = \"Feedback\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.Script\"
      name                               = \"Feedback\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"Octopus.Action.RunOnServer\"         = \"true\"
        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"
        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"
        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"
      }
      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = []
  }
}

resource \"octopusdeploy_runbook\" \"runbook_octopub_frontend_get_service\" {
  count             = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0
  name              = \"🛠️ Get Service\"
  project_id        = octopusdeploy_project.project_octopub_frontend[0].id
  environment_scope = \"Specified\"
  environments      = [
    local.development_environment_id,
    local.test_environment_id,
    local.production_environment_id,
  ]
  force_package_download      = false
  default_guided_failure_mode = \"Off\"
  description                 = <<EOT
**Action**: Returns the services.

**Affects**: Nothing - this runbook makes no changes.
EOT
  multi_tenancy_mode          = \"Untenanted\"

  retention_policy {
    quantity_to_keep    = 100
    should_keep_forever = false
  }

  connectivity_policy {
    allow_deployments_to_no_targets = true
    exclude_unhealthy_targets       = false
    skip_machine_behavior           = \"None\"
  }
}

resource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_frontend_get_service\" {
  count      = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0
  runbook_id = octopusdeploy_runbook.runbook_octopub_frontend_get_service[0].id

  step {
    condition           = \"Success\"
    name                = \"Get Service\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.KubernetesRunScript\"
      name                               = \"Get Service\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      worker_pool_variable               = \"\"
      properties                         = {
        \"K8SInspectCreateArtifact\"                      = \"False\"
        \"Octopus.Action.Script.ScriptBody\"              = \"<#\
    This script provides a general purpose method for querying Kubernetes resources. It supports common operations\
    like get, describe, logs and output formats like yaml and json. Output can be captured as artifacts.\
#>\
\
<#\
.Description\
Execute an application, capturing the output. Based on https://stackoverflow.com/a/33652732/157605\
#>\
Function Execute-Command ($commandPath, $commandArguments)\
{\
  Write-Host \\\"Executing: $commandPath $($commandArguments -join \\\" \\\")\\\"\
  \
  Try {\
    $pinfo = New-Object System.Diagnostics.ProcessStartInfo\
    $pinfo.FileName = $commandPath\
    $pinfo.RedirectStandardError = $true\
    $pinfo.RedirectStandardOutput = $true\
    $pinfo.UseShellExecute = $false\
    $pinfo.Arguments = $commandArguments\
    $p = New-Object System.Diagnostics.Process\
    $p.StartInfo = $pinfo\
    $p.Start() | Out-Null\
    [pscustomobject]@{\
        stdout = $p.StandardOutput.ReadToEnd()\
        stderr = $p.StandardError.ReadToEnd()\
        ExitCode = $p.ExitCode\
    }\
    $p.WaitForExit()\
  }\
  Catch {\
     exit\
  }\
}\
\
<#\
.Description\
Find any resource names that match a wildcard input if one was specified\
#>\
function Get-Resources() \
{\
    $names = $OctopusParameters[\\\"K8SInspectNames\\\"] -Split \\\"`n\\\" | % {$_.Trim()}\
    \
    if ($OctopusParameters[\\\"K8SInspectNames\\\"] -match '\\\\*' )\
    {\
        return Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", $OctopusParameters[\\\"K8SInspectResource\\\"])) |\
            # Select the stdout property from the execution\
            Select-Object -ExpandProperty stdout |\
            # Convert the output from JSON\
            ConvertFrom-JSON | \
            # Get the items object from the kubectl response\
            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\
            # Extract the name\
            % {$_.metadata.name} |\
            # Find any matching resources\
            ? {$k8sName = $_; ($names | ? {$k8sName -like $_}).Count -ne 0}\
    }\
    else\
    {\
        return $names\
    }\
}\
\
<#\
.Description\
Get the kubectl arguments for a given action\
#>\
function Get-KubectlVerb() \
{\
    switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\
    {\
        \\\"get json\\\" {return ,@(\\\"-o\\\", \\\"json\\\", \\\"get\\\")}\
        \\\"get yaml\\\" {return ,@(\\\"-o\\\", \\\"yaml\\\", \\\"get\\\")}\
        \\\"describe\\\" {return ,@(\\\"describe\\\")}\
        \\\"logs\\\" {return ,@(\\\"logs\\\")}\
        \\\"logs tail\\\" {return ,@(\\\"logs\\\", \\\"--tail\\\", \\\"100\\\")}\
        \\\"previous logs\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\")}\
        \\\"previous logs tail\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\", \\\"--tail\\\", \\\"100\\\")}\
        default {return ,@(\\\"get\\\")}\
    }\
}\
\
<#\
.Description\
Get an appropiate file extension based on the selected action\
#>\
function Get-ArtifactExtension() \
{\
   switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\
    {\
        \\\"get json\\\" {\\\"json\\\"}\
        \\\"get yaml\\\" {\\\"yaml\\\"}\
        default {\\\"txt\\\"}\
    }\
}\
\
if ($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"] -like \\\"*logs*\\\") \
{\
    if ( -not @($OctopusParameters[\\\"K8SInspectResource\\\"]) -like \\\"pod*\\\")\
    {\
        Write-Error \\\"Logs can only be returned for pods, not $($OctopusParameters[\\\"K8SInspectResource\\\"])\\\"\
    }\
    else\
    {\
        Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", \\\"pods\\\") + (Get-Resources)) |\
            # Select the stdout property from the execution\
            Select-Object -ExpandProperty stdout |\
            # Convert the output from JSON\
            ConvertFrom-JSON | \
            # Get the items object from the kubectl response\
            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\
            # Get the pod logs for each container\
            % {\
                $podDetails = $_\
                @{\
                    logs=$podDetails.spec.containers | % {$logs=\\\"\\\"} {$logs += (Select-Object -InputObject (Execute-Command kubectl ((Get-KubectlVerb) + @($podDetails.metadata.name, \\\"-c\\\", $_.name))) -ExpandProperty stdout)} {$logs}; \
                    name=$podDetails.metadata.name\
                }                \
            } |\
            # Write the output\
            % {Write-Host $_.logs; $_} |\
            # Optionally capture the artifact\
            % {\
                if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \
                {\
                    Set-Content -Path \\\"$($_.name).$(Get-ArtifactExtension)\\\" -Value $_.logs\
                    New-OctopusArtifact \\\"$($_.name).$(Get-ArtifactExtension)\\\"\
                }\
            }\
    }      \
}\
else\
{\
    Execute-Command kubectl ((Get-KubectlVerb) + @($OctopusParameters[\\\"K8SInspectResource\\\"]) + (Get-Resources)) |\
        % {Select-Object -InputObject $_ -ExpandProperty stdout} |\
        % {Write-Host $_; $_} |\
        % {\
            if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \
            {\
                Set-Content -Path \\\"output.$(Get-ArtifactExtension)\\\" -Value $_\
                New-OctopusArtifact \\\"output.$(Get-ArtifactExtension)\\\"\
            }\
        }\
}\
\"
        \"Octopus.Action.Script.ScriptSource\"            = \"Inline\"
        \"K8SInspectResource\"                            = \"service\"
        \"Octopus.Action.Script.Syntax\"                  = \"PowerShell\"
        \"Octopus.Action.KubernetesContainers.Namespace\" = \"#{if K8SInspectNamespace}#{K8SInspectNamespace}#{/if}#{unless K8SInspectNamespace}#{Octopus.Action.Kubernetes.Namespace}#{/unless}\"
        \"K8SInspectNames\"                               = \"#{Kubernetes.Service.Name}*\"
        \"K8SInspectKubectlVerb\"                         = \"get\"
      }
      container {
        feed_id = local.docker_hub_feed_id
        image   = \"octopuslabs/k8s-workertools\"
      }
      environments = [
        local.development_environment_id,
        local.test_environment_id,
        local.production_environment_id,
      ]
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = [\"EKS_Reference_Cluster\"]
  }

  step {
    condition           = \"Always\"
    name                = \"Feedback\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.Script\"
      name                               = \"Feedback\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"Octopus.Action.RunOnServer\"         = \"true\"
        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"
        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"
        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"
      }
      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = []
  }
}

resource \"octopusdeploy_runbook\" \"runbook_octopub_frontend_get_deployment\" {
  count             = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0
  name              = \"🛠️ Get Deployment\"
  project_id        = octopusdeploy_project.project_octopub_frontend[0].id
  environment_scope = \"Specified\"
  environments      = [
    local.development_environment_id,
    local.test_environment_id,
    local.production_environment_id,
  ]
  force_package_download      = false
  default_guided_failure_mode = \"Off\"
  description                 = <<EOT
**Action**: Returns the deployments.

**Affects**: Nothing - this runbook makes no changes.
EOT
  multi_tenancy_mode          = \"Untenanted\"

  retention_policy {
    quantity_to_keep    = 100
    should_keep_forever = false
  }

  connectivity_policy {
    allow_deployments_to_no_targets = true
    exclude_unhealthy_targets       = false
    skip_machine_behavior           = \"None\"
  }
}

resource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_frontend_get_deployment\" {
  count      = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0
  runbook_id = octopusdeploy_runbook.runbook_octopub_frontend_get_deployment[0].id

  step {
    condition           = \"Success\"
    name                = \"Get Deployment\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.KubernetesRunScript\"
      name                               = \"Get Deployment\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      worker_pool_variable               = \"\"
      properties                         = {
        \"K8SInspectCreateArtifact\"                      = \"False\"
        \"Octopus.Action.Script.ScriptBody\"              = \"<#\
    This script provides a general purpose method for querying Kubernetes resources. It supports common operations\
    like get, describe, logs and output formats like yaml and json. Output can be captured as artifacts.\
#>\
\
<#\
.Description\
Execute an application, capturing the output. Based on https://stackoverflow.com/a/33652732/157605\
#>\
Function Execute-Command ($commandPath, $commandArguments)\
{\
  Write-Host \\\"Executing: $commandPath $($commandArguments -join \\\" \\\")\\\"\
  \
  Try {\
    $pinfo = New-Object System.Diagnostics.ProcessStartInfo\
    $pinfo.FileName = $commandPath\
    $pinfo.RedirectStandardError = $true\
    $pinfo.RedirectStandardOutput = $true\
    $pinfo.UseShellExecute = $false\
    $pinfo.Arguments = $commandArguments\
    $p = New-Object System.Diagnostics.Process\
    $p.StartInfo = $pinfo\
    $p.Start() | Out-Null\
    [pscustomobject]@{\
        stdout = $p.StandardOutput.ReadToEnd()\
        stderr = $p.StandardError.ReadToEnd()\
        ExitCode = $p.ExitCode\
    }\
    $p.WaitForExit()\
  }\
  Catch {\
     exit\
  }\
}\
\
<#\
.Description\
Find any resource names that match a wildcard input if one was specified\
#>\
function Get-Resources() \
{\
    $names = $OctopusParameters[\\\"K8SInspectNames\\\"] -Split \\\"`n\\\" | % {$_.Trim()}\
    \
    if ($OctopusParameters[\\\"K8SInspectNames\\\"] -match '\\\\*' )\
    {\
        return Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", $OctopusParameters[\\\"K8SInspectResource\\\"])) |\
            # Select the stdout property from the execution\
            Select-Object -ExpandProperty stdout |\
            # Convert the output from JSON\
            ConvertFrom-JSON | \
            # Get the items object from the kubectl response\
            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\
            # Extract the name\
            % {$_.metadata.name} |\
            # Find any matching resources\
            ? {$k8sName = $_; ($names | ? {$k8sName -like $_}).Count -ne 0}\
    }\
    else\
    {\
        return $names\
    }\
}\
\
<#\
.Description\
Get the kubectl arguments for a given action\
#>\
function Get-KubectlVerb() \
{\
    switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\
    {\
        \\\"get json\\\" {return ,@(\\\"-o\\\", \\\"json\\\", \\\"get\\\")}\
        \\\"get yaml\\\" {return ,@(\\\"-o\\\", \\\"yaml\\\", \\\"get\\\")}\
        \\\"describe\\\" {return ,@(\\\"describe\\\")}\
        \\\"logs\\\" {return ,@(\\\"logs\\\")}\
        \\\"logs tail\\\" {return ,@(\\\"logs\\\", \\\"--tail\\\", \\\"100\\\")}\
        \\\"previous logs\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\")}\
        \\\"previous logs tail\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\", \\\"--tail\\\", \\\"100\\\")}\
        default {return ,@(\\\"get\\\")}\
    }\
}\
\
<#\
.Description\
Get an appropiate file extension based on the selected action\
#>\
function Get-ArtifactExtension() \
{\
   switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\
    {\
        \\\"get json\\\" {\\\"json\\\"}\
        \\\"get yaml\\\" {\\\"yaml\\\"}\
        default {\\\"txt\\\"}\
    }\
}\
\
if ($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"] -like \\\"*logs*\\\") \
{\
    if ( -not @($OctopusParameters[\\\"K8SInspectResource\\\"]) -like \\\"pod*\\\")\
    {\
        Write-Error \\\"Logs can only be returned for pods, not $($OctopusParameters[\\\"K8SInspectResource\\\"])\\\"\
    }\
    else\
    {\
        Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", \\\"pods\\\") + (Get-Resources)) |\
            # Select the stdout property from the execution\
            Select-Object -ExpandProperty stdout |\
            # Convert the output from JSON\
            ConvertFrom-JSON | \
            # Get the items object from the kubectl response\
            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\
            # Get the pod logs for each container\
            % {\
                $podDetails = $_\
                @{\
                    logs=$podDetails.spec.containers | % {$logs=\\\"\\\"} {$logs += (Select-Object -InputObject (Execute-Command kubectl ((Get-KubectlVerb) + @($podDetails.metadata.name, \\\"-c\\\", $_.name))) -ExpandProperty stdout)} {$logs}; \
                    name=$podDetails.metadata.name\
                }                \
            } |\
            # Write the output\
            % {Write-Host $_.logs; $_} |\
            # Optionally capture the artifact\
            % {\
                if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \
                {\
                    Set-Content -Path \\\"$($_.name).$(Get-ArtifactExtension)\\\" -Value $_.logs\
                    New-OctopusArtifact \\\"$($_.name).$(Get-ArtifactExtension)\\\"\
                }\
            }\
    }      \
}\
else\
{\
    Execute-Command kubectl ((Get-KubectlVerb) + @($OctopusParameters[\\\"K8SInspectResource\\\"]) + (Get-Resources)) |\
        % {Select-Object -InputObject $_ -ExpandProperty stdout} |\
        % {Write-Host $_; $_} |\
        % {\
            if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \
            {\
                Set-Content -Path \\\"output.$(Get-ArtifactExtension)\\\" -Value $_\
                New-OctopusArtifact \\\"output.$(Get-ArtifactExtension)\\\"\
            }\
        }\
}\
\"
        \"Octopus.Action.Script.ScriptSource\"            = \"Inline\"
        \"K8SInspectResource\"                            = \"deployment\"
        \"Octopus.Action.Script.Syntax\"                  = \"PowerShell\"
        \"Octopus.Action.KubernetesContainers.Namespace\" = \"#{if K8SInspectNamespace}#{K8SInspectNamespace}#{/if}#{unless K8SInspectNamespace}#{Octopus.Action.Kubernetes.Namespace}#{/unless}\"
        \"K8SInspectNames\"                               = \"#{Kubernetes.Deployment.Name}*\"
        \"K8SInspectKubectlVerb\"                         = \"get\"
      }
      container {
        feed_id = local.docker_hub_feed_id
        image   = \"octopuslabs/k8s-workertools\"
      }
      environments = [
        local.development_environment_id,
        local.test_environment_id,
        local.production_environment_id,
      ]
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = [\"EKS_Reference_Cluster\"]
  }

  step {
    condition           = \"Always\"
    name                = \"Feedback\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.Script\"
      name                               = \"Feedback\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"Octopus.Action.RunOnServer\"         = \"true\"
        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"
        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"
        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"
      }
      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = []
  }
}
#endregion

#region Products
variable \"products_project_name\" {
  type    = string
  default = \"\"
}

data \"octopusdeploy_projects\" \"octopub_products\" {
  partial_name = var.products_project_name == \"\" ? local.products_project_name : var.products_project_name
  skip         = 0
  take         = 1
}

resource \"octopusdeploy_variable\" \"products_deployment_feed\" {
  count        = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0
  owner_id     = octopusdeploy_project.project_octopub_products[0].id
  value        = local.docker_hub_feed_id
  name         = \"Kubernetes.Deployment.Feed\"
  type         = \"String\"
  description  = \"The feed ID hosting the image\"
  is_sensitive = false
}

resource \"octopusdeploy_variable\" \"products_deployment_image\" {
  count        = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0
  owner_id     = octopusdeploy_project.project_octopub_products[0].id
  value        = \"octopussamples/octopub-products-microservice\"
  name         = \"Kubernetes.Deployment.Image\"
  type         = \"String\"
  description  = \"The image to deploy\"
  is_sensitive = false
}

resource \"octopusdeploy_variable\" \"products_deployment_port\" {
  count        = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0
  owner_id     = octopusdeploy_project.project_octopub_products[0].id
  value        = \"8083\"
  name         = \"Kubernetes.Deployment.Port\"
  type         = \"String\"
  description  = \"The port exposed by the web app\"
  is_sensitive = false
}

resource \"octopusdeploy_variable\" \"products_microservice_name\" {
  count        = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0
  owner_id     = octopusdeploy_project.project_octopub_products[0].id
  value        = \"products\"
  name         = \"Microservice.Name\"
  type         = \"String\"
  description  = \"The microservice name, which is used as the basis for K8s resources and networking paths\"
  is_sensitive = false
  depends_on   = []
}

resource \"octopusdeploy_variable\" \"products_deployment_name\" {
  count        = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0
  owner_id     = octopusdeploy_project.project_octopub_products[0].id
  value        = \"#{Microservice.Name}\"
  name         = \"Kubernetes.Deployment.Name\"
  type         = \"String\"
  description  = \"The name of the Kubernetes deployment resource\"
  is_sensitive = false
  depends_on   = []
}

resource \"octopusdeploy_variable\" \"products_service_name\" {
  count        = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0
  owner_id     = octopusdeploy_project.project_octopub_products[0].id
  value        = \"#{Microservice.Name}\"
  name         = \"Kubernetes.Service.Name\"
  type         = \"String\"
  description  = \"The name of the Kubernetes service resource\"
  is_sensitive = false
  depends_on   = []
}

resource \"octopusdeploy_variable\" \"products_ingress_name\" {
  count        = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0
  owner_id     = octopusdeploy_project.project_octopub_products[0].id
  value        = \"#{Microservice.Name}\"
  name         = \"Kubernetes.Ingress.Name\"
  type         = \"String\"
  description  = \"The name of the Kubernetes ingress resource\"
  is_sensitive = false
  depends_on   = []
}

resource \"octopusdeploy_variable\" \"products_ingress_path\" {
  count        = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0
  owner_id     = octopusdeploy_project.project_octopub_products[0].id
  value        = \"/#{Kubernetes.Namespace}(/api/#{Microservice.Name})(/.*)?\"
  name         = \"Kubernetes.Ingress.Path\"
  type         = \"String\"
  description  = \"The path of the Kubernetes ingress resource\"
  is_sensitive = false
  depends_on   = []
}

resource \"octopusdeploy_variable\" \"products_app_path\" {
  count        = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0
  owner_id     = octopusdeploy_project.project_octopub_products[0].id
  value        = \"/#{Kubernetes.Namespace}/api/#{Microservice.Name}\"
  name         = \"Kubernetes.App.HealthCheck\"
  type         = \"String\"
  description  = \"The path to perform a health check on.\"
  is_sensitive = false
  depends_on   = []
}

resource \"octopusdeploy_variable\" \"products_namespace_default\" {
  count        = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0
  owner_id     = octopusdeploy_project.project_octopub_products[0].id
  value        = \"#{Octopus.Action.Kubernetes.Namespace}\"
  name         = \"Kubernetes.Namespace\"
  type         = \"String\"
  description  = \"The namespace to perform the deployments in.\"
  is_sensitive = false
  depends_on   = []
}

resource \"octopusdeploy_variable\" \"products_namespace_featurebranch\" {
  count        = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0
  owner_id     = octopusdeploy_project.project_octopub_products[0].id
  value        = \"\"
  name         = \"Kubernetes.Namespace\"
  type         = \"String\"
  description  = \"The custom namespace to use when deploying a feature branch\"
  is_sensitive = false

  scope {
    actions      = []
    channels     = []
    environments = [local.featurebranch_environment_id]
    machines     = []
    roles        = null
    tenant_tags  = null
  }

  prompt {
    description = \"Feature branch namespace\"
    label       = \"Namespace\"
    is_required = true
    display_settings {
      control_type = \"SingleLineText\"
    }
  }
}

resource \"octopusdeploy_channel\" \"products_featurebranch\" {
  count        = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0
  name         = \"Feature Branch\"
  project_id   = octopusdeploy_project.project_octopub_products[0].id
  description  = \"Deploy feature branch builds\"
  is_default   = false
  lifecycle_id = local.featurebranch_lifecycle_id
}

resource \"octopusdeploy_channel\" \"products_mainline\" {
  count        = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0
  name         = \"Mainline\"
  project_id   = octopusdeploy_project.project_octopub_products[0].id
  description  = \"Deploy mainline builds\"
  is_default   = true
  lifecycle_id = local.devops_lifecycle_id
  rule {
    tag = \"^$\"
    action_package {
      deployment_action = \"Deploy Container\"
      package_reference = \"web\"
    }
  }

  depends_on  = [octopusdeploy_deployment_process.deployment_process_octopub_products]
}

resource \"octopusdeploy_project\" \"project_octopub_products\" {
  count                                = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0
  name                                 = var.products_project_name == \"\" ? local.products_project_name : var.products_project_name
  auto_create_release                  = false
  default_guided_failure_mode          = \"Off\"
  default_to_skip_if_already_installed = false
  discrete_channel_release             = false
  is_disabled                          = false
  is_version_controlled                = false
  lifecycle_id                         = local.devops_lifecycle_id
  project_group_id                     = local.eks_project_group_id
  included_library_variable_sets       = [local.this_instance_library_variable_set, local.github_library_variable_set]
  tenanted_deployment_participation    = \"Untenanted\"

  connectivity_policy {
    allow_deployments_to_no_targets = true
    exclude_unhealthy_targets       = false
    skip_machine_behavior           = \"None\"
  }

  versioning_strategy {
    template = \"#{Octopus.Version.LastMajor}.#{Octopus.Version.LastMinor}.#{Octopus.Version.NextPatch}\"
  }

  lifecycle {
    ignore_changes = []
  }
  description = <<EOT
Deploys the Octopub Products Service

**Source**: [GitHub](https://github.com/OctopusSolutionsEngineering/Octopub)

**Build**: [GitHub Actions](https://github.com/OctopusSolutionsEngineering/Octopub/actions)

**Issues**: [GitHub Issues](https://github.com/OctopusSolutionsEngineering/Octopub/issues)
EOT
}

resource \"octopusdeploy_deployment_process\" \"deployment_process_octopub_products\" {
  count      = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0
  project_id = octopusdeploy_project.project_octopub_products[0].id

  step {
    condition           = \"Success\"
    name                = \"Generate Variables\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.Script\"
      name                               = \"Generate Variables\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"Octopus.Action.RunOnServer\"         = \"true\"
        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"
        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"
        \"Octopus.Action.Script.ScriptBody\"   = local.variable_script
      }
      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = []
  }

  step {
    condition           = \"Success\"
    name                = \"Deploy Container\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.KubernetesDeployContainers\"
      name                               = \"Deploy Container\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = true
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"Octopus.Action.KubernetesContainers.Namespace\"              = \"#{Kubernetes.Namespace}\"
        \"Octopus.Action.KubernetesContainers.Replicas\"               = \"1\"
        \"Octopus.Action.KubernetesContainers.DeploymentResourceType\" = \"Deployment\"
        \"Octopus.Action.KubernetesContainers.IngressAnnotations\"     = jsonencode([
          {
            \"optionError\"  = null
            \"option2\"      = \"\"
            \"option2Error\" = null
            \"key\"          = \"nginx.ingress.kubernetes.io/rewrite-target\"
            \"keyError\"     = null
            \"value\"        = \"$1$2\"
            \"valueError\"   = null
            \"option\"       = \"\"
          },
          {
            \"keyError\"     = null
            \"value\"        = \"true\"
            \"valueError\"   = null
            \"option\"       = \"\"
            \"optionError\"  = null
            \"option2\"      = \"\"
            \"option2Error\" = null
            \"key\"          = \"nginx.ingress.kubernetes.io/use-regex\"
          },
        ])
        \"Octopus.Action.KubernetesContainers.DeploymentStyle\" = \"RollingUpdate\"
        \"Octopus.Action.KubernetesContainers.IngressName\"     = \"#{Kubernetes.Ingress.Name}\"
        \"Octopus.Action.KubernetesContainers.DeploymentName\"  = \"#{Kubernetes.Deployment.Name}\"
        \"Octopus.Action.KubernetesContainers.IngressRules\"    = jsonencode([
          {
            \"host\" = \"\"
            \"http\" = {
              \"paths\" = [
                {
                  \"key\"     = \"#{Kubernetes.Ingress.Path}\"
                  \"value\"   = \"web\"
                  \"option\"  = \"\"
                  \"option2\" = \"ImplementationSpecific\"
                },
              ]
            }
          },
        ])
        \"OctopusUseBundledTooling\"                       = \"False\"
        \"Octopus.Action.KubernetesContainers.Containers\" = jsonencode([
          {
            \"Args\"                         = []
            \"FieldRefEnvironmentVariables\" = []
            \"SecretEnvFromSource\"          = []
            \"Command\"                      = []
            \"Ports\"                        = [
              {
                \"option2Error\" = null
                \"optionError\"  = null
                \"value\"        = \"#{Kubernetes.Deployment.Port}\"
                \"valueError\"   = null
                \"key\"          = \"web\"
                \"keyError\"     = null
                \"option\"       = \"TCP\"
                \"option2\"      = \"\"
              },
            ]
            \"Resources\" = {
              \"limits\" = {
                \"storage\"          = \"\"
                \"amdGpu\"           = \"\"
                \"cpu\"              = \"\"
                \"ephemeralStorage\" = \"\"
                \"memory\"           = \"\"
                \"nvidiaGpu\"        = \"\"
              }
              \"requests\" = {
                \"amdGpu\"           = \"\"
                \"cpu\"              = \"\"
                \"ephemeralStorage\" = \"\"
                \"memory\"           = \"\"
                \"nvidiaGpu\"        = \"\"
                \"storage\"          = \"\"
              }
            }
            \"SecretEnvironmentVariables\" = []
            \"SecurityContext\"            = {
              \"runAsNonRoot\"   = \"True\"
              \"runAsUser\"      = \"\"
              \"seLinuxOptions\" = {
                \"level\" = \"\"
                \"role\"  = \"\"
                \"type\"  = \"\"
                \"user\"  = \"\"
              }
              \"allowPrivilegeEscalation\" = \"\"
              \"capabilities\"             = {
                \"add\"  = []
                \"drop\" = [
                  \"ALL\",
                ]
              }
              \"privileged\"             = \"\"
              \"readOnlyRootFilesystem\" = \"\"
              \"runAsGroup\"             = \"\"
            }
            \"TerminationMessagePath\" = \"\"
            \"EnvironmentVariables\"   = [
              {
                \"key\"          = \"PORT\"
                \"keyError\"     = null
                \"value\"        = \"#{Kubernetes.Deployment.Port}\"
                \"valueError\"   = null
                \"option\"       = \"\"
                \"optionError\"  = null
                \"option2\"      = \"\"
                \"option2Error\" = null
              }
            ]
            \"LivenessProbe\" = {
              \"successThreshold\" = \"\"
              \"tcpSocket\"        = {
                \"port\" = \"\"
                \"host\" = \"\"
              }
              \"exec\" = {
                \"command\" = []
              }
              \"failureThreshold\" = \"\"
              \"periodSeconds\"    = \"\"
              \"type\"             = \"\"
              \"httpGet\"          = {
                \"host\"        = \"\"
                \"httpHeaders\" = []
                \"path\"        = \"\"
                \"port\"        = \"\"
                \"scheme\"      = \"\"
              }
              \"initialDelaySeconds\" = \"\"
              \"timeoutSeconds\"      = \"\"
            }
            \"ReadinessProbe\" = {
              \"exec\" = {
                \"command\" = []
              }
              \"failureThreshold\" = \"\"
              \"timeoutSeconds\"   = \"\"
              \"successThreshold\" = \"\"
              \"tcpSocket\"        = {
                \"host\" = \"\"
                \"port\" = \"\"
              }
              \"type\"    = \"\"
              \"httpGet\" = {
                \"host\"        = \"\"
                \"httpHeaders\" = []
                \"path\"        = \"\"
                \"port\"        = \"\"
                \"scheme\"      = \"\"
              }
              \"initialDelaySeconds\" = \"\"
              \"periodSeconds\"       = \"\"
            }
            \"TerminationMessagePolicy\"      = \"\"
            \"VolumeMounts\"                  = []
            \"ConfigMapEnvFromSource\"        = []
            \"ConfigMapEnvironmentVariables\" = []
            \"CreateFeedSecrets\"             = \"False\"
            \"Lifecycle\"                     = {
              \"PostStart\" = null
              \"PreStop\"   = null
            }
            \"Name\"         = \"web\"
            \"StartupProbe\" = {
              \"successThreshold\" = \"\"
              \"tcpSocket\"        = {
                \"host\" = \"\"
                \"port\" = \"\"
              }
              \"failureThreshold\" = \"\"
              \"httpGet\"          = {
                \"host\"        = \"\"
                \"httpHeaders\" = []
                \"path\"        = \"\"
                \"port\"        = \"\"
                \"scheme\"      = \"\"
              }
              \"initialDelaySeconds\" = \"\"
              \"type\"                = \"\"
              \"exec\"                = {
                \"command\" = []
              }
              \"periodSeconds\"  = \"\"
              \"timeoutSeconds\" = \"\"
            }
          },
        ])
        \"Octopus.Action.KubernetesContainers.ServiceName\"         = \"#{Kubernetes.Service.Name}\"
        \"Octopus.Action.KubernetesContainers.PodManagementPolicy\" = \"OrderedReady\"
        \"Octopus.Action.Kubernetes.DeploymentTimeout\"             = \"180\"
        \"Octopus.Action.RunOnServer\"                              = \"true\"
        \"Octopus.Action.KubernetesContainers.IngressClassName\"    = \"nginx\"
        \"Octopus.Action.KubernetesContainers.ServicePorts\"        = jsonencode([
          {
            \"port\"       = \"80\"
            \"protocol\"   = \"TCP\"
            \"targetPort\" = \"web\"
            \"name\"       = \"web\"
            \"nodePort\"   = \"\"
          },
        ])
        \"Octopus.Action.Kubernetes.ResourceStatusCheck\"       = \"True\"
        \"Octopus.Action.KubernetesContainers.ServiceNameType\" = \"External\"
        \"Octopus.Action.KubernetesContainers.ServiceType\"     = \"ClusterIP\"
      }
      container {
        feed_id = local.docker_hub_feed_id
        image   = \"octopuslabs/k8s-workertools\"
      }

      environments = [
        local.development_environment_id,
        local.test_environment_id,
        local.production_environment_id,
        local.featurebranch_environment_id,
      ]
      excluded_environments = []
      channels              = []
      tenant_tags           = []

      package {
        name                      = \"web\"
        package_id                = \"#{Kubernetes.Deployment.Image}\"
        acquisition_location      = \"NotAcquired\"
        extract_during_deployment = false
        feed_id                   = \"#{Kubernetes.Deployment.Feed}\"
        properties                = { Extract = \"False\", PackageParameterName = \"\", SelectionMode = \"immediate\" }
      }
      features = [
        \"\", \"Octopus.Features.KubernetesService\", \"Octopus.Features.KubernetesIngress\",
        \"Octopus.Features.KubernetesConfigMap\", \"Octopus.Features.KubernetesSecret\"
      ]
    }

    properties   = {}
    target_roles = [\"EKS_Reference_Cluster\"]
  }

  step {
    condition           = \"Success\"
    name                = \"Smoke Test\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.KubernetesRunScript\"
      name                               = \"Smoke Test\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"Octopus.Action.KubernetesContainers.Namespace\" = \"#{Kubernetes.Namespace}\"
        \"Octopus.Action.RunOnServer\"                    = \"true\"
        \"Octopus.Action.Script.ScriptSource\"            = \"Inline\"
        \"Octopus.Action.Script.Syntax\"                  = \"Bash\"
        \"Octopus.Action.Script.ScriptBody\"              = local.smoke_test
      }
      container {
        feed_id = local.docker_hub_feed_id
        image   = \"octopuslabs/k8s-workertools\"
      }
      environments = [
        local.development_environment_id,
        local.test_environment_id,
        local.production_environment_id,
        local.featurebranch_environment_id,
      ]
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = [\"EKS_Reference_Cluster\"]
  }

  step {
    condition           = \"Success\"
    name                = \"Security Scan\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.Script\"
      name                               = \"Security Scan\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = true
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"Octopus.Action.RunOnServer\"         = \"true\"
        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"
        \"Octopus.Action.Script.Syntax\"       = \"Bash\"
        \"Octopus.Action.Script.ScriptBody\"   = local.security_scan_script
      }
      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = []
  }

  step {
    condition           = \"Always\"
    name                = \"Feedback\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.Script\"
      name                               = \"Feedback\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"Octopus.Action.RunOnServer\"         = \"true\"
        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"
        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"
        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"
      }
      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = []
  }
}

resource \"octopusdeploy_runbook\" \"runbook_octopub_products_scale_to_zero\" {
  count             = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0
  name              = \"🌃 Scale Pods to Zero\"
  project_id        = octopusdeploy_project.project_octopub_products[0].id
  environment_scope = \"Specified\"
  environments      = [
    local.development_environment_id,
    local.test_environment_id,
    local.production_environment_id,
  ]
  force_package_download      = false
  default_guided_failure_mode = \"Off\"
  description                 = <<EOT
**WARNING**: This is a destructive operation. The service will no longer be available when scaled down.

**Action**: Scales the deployment down to zero pods.

**Affects**: The products service is effectively shut down.

This runbook is designed to be be run in non-production environments after hours to remove the Fargate nodes hosting
the service. This removes the cost of hosting the service out of hours.
EOT
  multi_tenancy_mode          = \"Untenanted\"

  retention_policy {
    quantity_to_keep    = 100
    should_keep_forever = false
  }

  connectivity_policy {
    allow_deployments_to_no_targets = true
    exclude_unhealthy_targets       = false
    skip_machine_behavior           = \"None\"
  }
}

resource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_products_scale_pods_to_zero\" {
  count      = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0
  runbook_id = octopusdeploy_runbook.runbook_octopub_products_scale_to_zero[0].id

  step {
    condition           = \"Success\"
    name                = \"Scale Pods to Zero\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.KubernetesRunScript\"
      name                               = \"Scale Pods to Zero\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = true
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      worker_pool_variable               = \"\"
      properties                         = {
        \"OctopusUseBundledTooling\"           = \"False\"
        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"
        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"
        \"Octopus.Action.Script.ScriptBody\"   = \"kubectl scale --replicas=0 deployment/#{Kubernetes.Deployment.Name}\"
        \"Octopus.Action.RunOnServer\"         = \"true\"
      }

      container {
        feed_id = local.docker_hub_feed_id
        image   = \"octopuslabs/k8s-workertools\"
      }

      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = [\"EKS_Reference_Cluster\"]
  }

  step {
    condition           = \"Always\"
    name                = \"Feedback\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.Script\"
      name                               = \"Feedback\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"Octopus.Action.RunOnServer\"         = \"true\"
        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"
        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"
        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"
      }
      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = []
  }
}

resource \"octopusdeploy_runbook\" \"runbook_octopub_products_scale_to_one\" {
  count             = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0
  name              = \"🌇 Scale Pods to One\"
  project_id        = octopusdeploy_project.project_octopub_products[0].id
  environment_scope = \"Specified\"
  environments      = [
    local.development_environment_id,
    local.test_environment_id,
    local.production_environment_id,
  ]
  force_package_download      = false
  default_guided_failure_mode = \"Off\"
  description                 = <<EOT
**Action**: Scales the deployment to one pod.

**Affects**: Products service - this will create new pods if the deployment has been scaled to zero.

This runbook is designed to be be run in non-production environments during office hours to recreate the pods after they
were shutdown after hours.
EOT
  multi_tenancy_mode          = \"Untenanted\"

  retention_policy {
    quantity_to_keep    = 100
    should_keep_forever = false
  }

  connectivity_policy {
    allow_deployments_to_no_targets = true
    exclude_unhealthy_targets       = false
    skip_machine_behavior           = \"None\"
  }
}

resource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_products_scale_pods_to_one\" {
  count      = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0
  runbook_id = octopusdeploy_runbook.runbook_octopub_products_scale_to_one[0].id

  step {
    condition           = \"Success\"
    name                = \"Scale Pods to One\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.KubernetesRunScript\"
      name                               = \"Scale Pods to One\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = true
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      worker_pool_variable               = \"\"
      properties                         = {
        \"OctopusUseBundledTooling\"           = \"False\"
        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"
        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"
        \"Octopus.Action.Script.ScriptBody\"   = \"kubectl scale --replicas=1 deployment/#{Kubernetes.Deployment.Name}\"
        \"Octopus.Action.RunOnServer\"         = \"true\"
      }

      container {
        feed_id = local.docker_hub_feed_id
        image   = \"octopuslabs/k8s-workertools\"
      }

      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = [\"EKS_Reference_Cluster\"]
  }

  step {
    condition           = \"Always\"
    name                = \"Feedback\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.Script\"
      name                               = \"Feedback\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"Octopus.Action.RunOnServer\"         = \"true\"
        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"
        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"
        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"
      }
      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = []
  }
}

resource \"octopusdeploy_runbook\" \"runbook_octopub_products_get_pod_logs\" {
  count             = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0
  name              = \"🛠️ Get Pod Logs\"
  project_id        = octopusdeploy_project.project_octopub_products[0].id
  environment_scope = \"Specified\"
  environments      = [
    local.development_environment_id,
    local.test_environment_id,
    local.production_environment_id,
  ]
  force_package_download      = false
  default_guided_failure_mode = \"Off\"
  description                 = <<EOT
**Action**: Returns the pod logs.

**Affects**: Nothing - this runbook makes no changes.
EOT
  multi_tenancy_mode          = \"Untenanted\"

  retention_policy {
    quantity_to_keep    = 100
    should_keep_forever = false
  }

  connectivity_policy {
    allow_deployments_to_no_targets = true
    exclude_unhealthy_targets       = false
    skip_machine_behavior           = \"None\"
  }
}

resource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_products_get_pod_logs\" {
  count      = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0
  runbook_id = octopusdeploy_runbook.runbook_octopub_products_get_pod_logs[0].id

  step {
    condition           = \"Success\"
    name                = \"Get Pod Logs\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.KubernetesRunScript\"
      name                               = \"Get Pod Logs\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      worker_pool_variable               = \"\"
      properties                         = {
        \"K8SInspectCreateArtifact\"                      = \"False\"
        \"Octopus.Action.Script.ScriptBody\"              = \"<#\
    This script provides a general purpose method for querying Kubernetes resources. It supports common operations\
    like get, describe, logs and output formats like yaml and json. Output can be captured as artifacts.\
#>\
\
<#\
.Description\
Execute an application, capturing the output. Based on https://stackoverflow.com/a/33652732/157605\
#>\
Function Execute-Command ($commandPath, $commandArguments)\
{\
  Write-Host \\\"Executing: $commandPath $($commandArguments -join \\\" \\\")\\\"\
  \
  Try {\
    $pinfo = New-Object System.Diagnostics.ProcessStartInfo\
    $pinfo.FileName = $commandPath\
    $pinfo.RedirectStandardError = $true\
    $pinfo.RedirectStandardOutput = $true\
    $pinfo.UseShellExecute = $false\
    $pinfo.Arguments = $commandArguments\
    $p = New-Object System.Diagnostics.Process\
    $p.StartInfo = $pinfo\
    $p.Start() | Out-Null\
    [pscustomobject]@{\
        stdout = $p.StandardOutput.ReadToEnd()\
        stderr = $p.StandardError.ReadToEnd()\
        ExitCode = $p.ExitCode\
    }\
    $p.WaitForExit()\
  }\
  Catch {\
     exit\
  }\
}\
\
<#\
.Description\
Find any resource names that match a wildcard input if one was specified\
#>\
function Get-Resources() \
{\
    $names = $OctopusParameters[\\\"K8SInspectNames\\\"] -Split \\\"`n\\\" | % {$_.Trim()}\
    \
    if ($OctopusParameters[\\\"K8SInspectNames\\\"] -match '\\\\*' )\
    {\
        return Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", $OctopusParameters[\\\"K8SInspectResource\\\"])) |\
            # Select the stdout property from the execution\
            Select-Object -ExpandProperty stdout |\
            # Convert the output from JSON\
            ConvertFrom-JSON | \
            # Get the items object from the kubectl response\
            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\
            # Extract the name\
            % {$_.metadata.name} |\
            # Find any matching resources\
            ? {$k8sName = $_; ($names | ? {$k8sName -like $_}).Count -ne 0}\
    }\
    else\
    {\
        return $names\
    }\
}\
\
<#\
.Description\
Get the kubectl arguments for a given action\
#>\
function Get-KubectlVerb() \
{\
    switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\
    {\
        \\\"get json\\\" {return ,@(\\\"-o\\\", \\\"json\\\", \\\"get\\\")}\
        \\\"get yaml\\\" {return ,@(\\\"-o\\\", \\\"yaml\\\", \\\"get\\\")}\
        \\\"describe\\\" {return ,@(\\\"describe\\\")}\
        \\\"logs\\\" {return ,@(\\\"logs\\\")}\
        \\\"logs tail\\\" {return ,@(\\\"logs\\\", \\\"--tail\\\", \\\"100\\\")}\
        \\\"previous logs\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\")}\
        \\\"previous logs tail\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\", \\\"--tail\\\", \\\"100\\\")}\
        default {return ,@(\\\"get\\\")}\
    }\
}\
\
<#\
.Description\
Get an appropiate file extension based on the selected action\
#>\
function Get-ArtifactExtension() \
{\
   switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\
    {\
        \\\"get json\\\" {\\\"json\\\"}\
        \\\"get yaml\\\" {\\\"yaml\\\"}\
        default {\\\"txt\\\"}\
    }\
}\
\
if ($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"] -like \\\"*logs*\\\") \
{\
    if ( -not @($OctopusParameters[\\\"K8SInspectResource\\\"]) -like \\\"pod*\\\")\
    {\
        Write-Error \\\"Logs can only be returned for pods, not $($OctopusParameters[\\\"K8SInspectResource\\\"])\\\"\
    }\
    else\
    {\
        Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", \\\"pods\\\") + (Get-Resources)) |\
            # Select the stdout property from the execution\
            Select-Object -ExpandProperty stdout |\
            # Convert the output from JSON\
            ConvertFrom-JSON | \
            # Get the items object from the kubectl response\
            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\
            # Get the pod logs for each container\
            % {\
                $podDetails = $_\
                @{\
                    logs=$podDetails.spec.containers | % {$logs=\\\"\\\"} {$logs += (Select-Object -InputObject (Execute-Command kubectl ((Get-KubectlVerb) + @($podDetails.metadata.name, \\\"-c\\\", $_.name))) -ExpandProperty stdout)} {$logs}; \
                    name=$podDetails.metadata.name\
                }                \
            } |\
            # Write the output\
            % {Write-Host $_.logs; $_} |\
            # Optionally capture the artifact\
            % {\
                if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \
                {\
                    Set-Content -Path \\\"$($_.name).$(Get-ArtifactExtension)\\\" -Value $_.logs\
                    New-OctopusArtifact \\\"$($_.name).$(Get-ArtifactExtension)\\\"\
                }\
            }\
    }      \
}\
else\
{\
    Execute-Command kubectl ((Get-KubectlVerb) + @($OctopusParameters[\\\"K8SInspectResource\\\"]) + (Get-Resources)) |\
        % {Select-Object -InputObject $_ -ExpandProperty stdout} |\
        % {Write-Host $_; $_} |\
        % {\
            if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \
            {\
                Set-Content -Path \\\"output.$(Get-ArtifactExtension)\\\" -Value $_\
                New-OctopusArtifact \\\"output.$(Get-ArtifactExtension)\\\"\
            }\
        }\
}\
\"
        \"Octopus.Action.Script.ScriptSource\"            = \"Inline\"
        \"K8SInspectResource\"                            = \"pod\"
        \"Octopus.Action.Script.Syntax\"                  = \"PowerShell\"
        \"Octopus.Action.KubernetesContainers.Namespace\" = \"#{if K8SInspectNamespace}#{K8SInspectNamespace}#{/if}#{unless K8SInspectNamespace}#{Octopus.Action.Kubernetes.Namespace}#{/unless}\"
        \"K8SInspectNames\"                               = \"#{Kubernetes.Deployment.Name}*\"
        \"K8SInspectKubectlVerb\"                         = \"logs\"
      }
      container {
        feed_id = local.docker_hub_feed_id
        image   = \"octopuslabs/k8s-workertools\"
      }
      environments = [
        local.development_environment_id,
        local.test_environment_id,
        local.production_environment_id,
      ]
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = [\"EKS_Reference_Cluster\"]
  }

  step {
    condition           = \"Always\"
    name                = \"Feedback\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.Script\"
      name                               = \"Feedback\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"Octopus.Action.RunOnServer\"         = \"true\"
        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"
        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"
        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"
      }
      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = []
  }
}

resource \"octopusdeploy_runbook\" \"runbook_octopub_products_get_pods\" {
  count             = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0
  name              = \"🛠️ Get Pods\"
  project_id        = octopusdeploy_project.project_octopub_products[0].id
  environment_scope = \"Specified\"
  environments      = [
    local.development_environment_id,
    local.test_environment_id,
    local.production_environment_id,
  ]
  force_package_download      = false
  default_guided_failure_mode = \"Off\"
  description                 = <<EOT
**Action**: Returns the pods.

**Affects**: Nothing - this runbook makes no changes.
EOT
  multi_tenancy_mode          = \"Untenanted\"

  retention_policy {
    quantity_to_keep    = 100
    should_keep_forever = false
  }

  connectivity_policy {
    allow_deployments_to_no_targets = true
    exclude_unhealthy_targets       = false
    skip_machine_behavior           = \"None\"
  }
}

resource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_products_get_pods\" {
  count      = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0
  runbook_id = octopusdeploy_runbook.runbook_octopub_products_get_pods[0].id

  step {
    condition           = \"Success\"
    name                = \"Get Pods\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.KubernetesRunScript\"
      name                               = \"Get Pods\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      worker_pool_variable               = \"\"
      properties                         = {
        \"K8SInspectCreateArtifact\"                      = \"False\"
        \"Octopus.Action.Script.ScriptBody\"              = \"<#\
    This script provides a general purpose method for querying Kubernetes resources. It supports common operations\
    like get, describe, logs and output formats like yaml and json. Output can be captured as artifacts.\
#>\
\
<#\
.Description\
Execute an application, capturing the output. Based on https://stackoverflow.com/a/33652732/157605\
#>\
Function Execute-Command ($commandPath, $commandArguments)\
{\
  Write-Host \\\"Executing: $commandPath $($commandArguments -join \\\" \\\")\\\"\
  \
  Try {\
    $pinfo = New-Object System.Diagnostics.ProcessStartInfo\
    $pinfo.FileName = $commandPath\
    $pinfo.RedirectStandardError = $true\
    $pinfo.RedirectStandardOutput = $true\
    $pinfo.UseShellExecute = $false\
    $pinfo.Arguments = $commandArguments\
    $p = New-Object System.Diagnostics.Process\
    $p.StartInfo = $pinfo\
    $p.Start() | Out-Null\
    [pscustomobject]@{\
        stdout = $p.StandardOutput.ReadToEnd()\
        stderr = $p.StandardError.ReadToEnd()\
        ExitCode = $p.ExitCode\
    }\
    $p.WaitForExit()\
  }\
  Catch {\
     exit\
  }\
}\
\
<#\
.Description\
Find any resource names that match a wildcard input if one was specified\
#>\
function Get-Resources() \
{\
    $names = $OctopusParameters[\\\"K8SInspectNames\\\"] -Split \\\"`n\\\" | % {$_.Trim()}\
    \
    if ($OctopusParameters[\\\"K8SInspectNames\\\"] -match '\\\\*' )\
    {\
        return Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", $OctopusParameters[\\\"K8SInspectResource\\\"])) |\
            # Select the stdout property from the execution\
            Select-Object -ExpandProperty stdout |\
            # Convert the output from JSON\
            ConvertFrom-JSON | \
            # Get the items object from the kubectl response\
            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\
            # Extract the name\
            % {$_.metadata.name} |\
            # Find any matching resources\
            ? {$k8sName = $_; ($names | ? {$k8sName -like $_}).Count -ne 0}\
    }\
    else\
    {\
        return $names\
    }\
}\
\
<#\
.Description\
Get the kubectl arguments for a given action\
#>\
function Get-KubectlVerb() \
{\
    switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\
    {\
        \\\"get json\\\" {return ,@(\\\"-o\\\", \\\"json\\\", \\\"get\\\")}\
        \\\"get yaml\\\" {return ,@(\\\"-o\\\", \\\"yaml\\\", \\\"get\\\")}\
        \\\"describe\\\" {return ,@(\\\"describe\\\")}\
        \\\"logs\\\" {return ,@(\\\"logs\\\")}\
        \\\"logs tail\\\" {return ,@(\\\"logs\\\", \\\"--tail\\\", \\\"100\\\")}\
        \\\"previous logs\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\")}\
        \\\"previous logs tail\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\", \\\"--tail\\\", \\\"100\\\")}\
        default {return ,@(\\\"get\\\")}\
    }\
}\
\
<#\
.Description\
Get an appropiate file extension based on the selected action\
#>\
function Get-ArtifactExtension() \
{\
   switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\
    {\
        \\\"get json\\\" {\\\"json\\\"}\
        \\\"get yaml\\\" {\\\"yaml\\\"}\
        default {\\\"txt\\\"}\
    }\
}\
\
if ($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"] -like \\\"*logs*\\\") \
{\
    if ( -not @($OctopusParameters[\\\"K8SInspectResource\\\"]) -like \\\"pod*\\\")\
    {\
        Write-Error \\\"Logs can only be returned for pods, not $($OctopusParameters[\\\"K8SInspectResource\\\"])\\\"\
    }\
    else\
    {\
        Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", \\\"pods\\\") + (Get-Resources)) |\
            # Select the stdout property from the execution\
            Select-Object -ExpandProperty stdout |\
            # Convert the output from JSON\
            ConvertFrom-JSON | \
            # Get the items object from the kubectl response\
            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\
            # Get the pod logs for each container\
            % {\
                $podDetails = $_\
                @{\
                    logs=$podDetails.spec.containers | % {$logs=\\\"\\\"} {$logs += (Select-Object -InputObject (Execute-Command kubectl ((Get-KubectlVerb) + @($podDetails.metadata.name, \\\"-c\\\", $_.name))) -ExpandProperty stdout)} {$logs}; \
                    name=$podDetails.metadata.name\
                }                \
            } |\
            # Write the output\
            % {Write-Host $_.logs; $_} |\
            # Optionally capture the artifact\
            % {\
                if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \
                {\
                    Set-Content -Path \\\"$($_.name).$(Get-ArtifactExtension)\\\" -Value $_.logs\
                    New-OctopusArtifact \\\"$($_.name).$(Get-ArtifactExtension)\\\"\
                }\
            }\
    }      \
}\
else\
{\
    Execute-Command kubectl ((Get-KubectlVerb) + @($OctopusParameters[\\\"K8SInspectResource\\\"]) + (Get-Resources)) |\
        % {Select-Object -InputObject $_ -ExpandProperty stdout} |\
        % {Write-Host $_; $_} |\
        % {\
            if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \
            {\
                Set-Content -Path \\\"output.$(Get-ArtifactExtension)\\\" -Value $_\
                New-OctopusArtifact \\\"output.$(Get-ArtifactExtension)\\\"\
            }\
        }\
}\
\"
        \"Octopus.Action.Script.ScriptSource\"            = \"Inline\"
        \"K8SInspectResource\"                            = \"pod\"
        \"Octopus.Action.Script.Syntax\"                  = \"PowerShell\"
        \"Octopus.Action.KubernetesContainers.Namespace\" = \"#{if K8SInspectNamespace}#{K8SInspectNamespace}#{/if}#{unless K8SInspectNamespace}#{Octopus.Action.Kubernetes.Namespace}#{/unless}\"
        \"K8SInspectNames\"                               = \"#{Kubernetes.Deployment.Name}*\"
        \"K8SInspectKubectlVerb\"                         = \"get\"
      }
      container {
        feed_id = local.docker_hub_feed_id
        image   = \"octopuslabs/k8s-workertools\"
      }
      environments = [
        local.development_environment_id,
        local.test_environment_id,
        local.production_environment_id,
      ]
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = [\"EKS_Reference_Cluster\"]
  }

  step {
    condition           = \"Always\"
    name                = \"Feedback\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.Script\"
      name                               = \"Feedback\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"Octopus.Action.RunOnServer\"         = \"true\"
        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"
        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"
        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"
      }
      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = []
  }
}

resource \"octopusdeploy_runbook\" \"runbook_octopub_products_describe_pods\" {
  count             = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0
  name              = \"🛠️ Describe Pods\"
  project_id        = octopusdeploy_project.project_octopub_products[0].id
  environment_scope = \"Specified\"
  environments      = [
    local.development_environment_id,
    local.test_environment_id,
    local.production_environment_id,
  ]
  force_package_download      = false
  default_guided_failure_mode = \"Off\"
  description                 = <<EOT
**Action**: Returns the pods.

**Affects**: Nothing - this runbook makes no changes.
EOT
  multi_tenancy_mode          = \"Untenanted\"

  retention_policy {
    quantity_to_keep    = 100
    should_keep_forever = false
  }

  connectivity_policy {
    allow_deployments_to_no_targets = true
    exclude_unhealthy_targets       = false
    skip_machine_behavior           = \"None\"
  }
}

resource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_products_describe_pods\" {
  count      = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0
  runbook_id = octopusdeploy_runbook.runbook_octopub_products_describe_pods[0].id

  step {
    condition           = \"Success\"
    name                = \"Describe Pods\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.KubernetesRunScript\"
      name                               = \"Describe Pods\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      worker_pool_variable               = \"\"
      properties                         = {
        \"K8SInspectCreateArtifact\"                      = \"False\"
        \"Octopus.Action.Script.ScriptBody\"              = \"<#\
    This script provides a general purpose method for querying Kubernetes resources. It supports common operations\
    like get, describe, logs and output formats like yaml and json. Output can be captured as artifacts.\
#>\
\
<#\
.Description\
Execute an application, capturing the output. Based on https://stackoverflow.com/a/33652732/157605\
#>\
Function Execute-Command ($commandPath, $commandArguments)\
{\
  Write-Host \\\"Executing: $commandPath $($commandArguments -join \\\" \\\")\\\"\
  \
  Try {\
    $pinfo = New-Object System.Diagnostics.ProcessStartInfo\
    $pinfo.FileName = $commandPath\
    $pinfo.RedirectStandardError = $true\
    $pinfo.RedirectStandardOutput = $true\
    $pinfo.UseShellExecute = $false\
    $pinfo.Arguments = $commandArguments\
    $p = New-Object System.Diagnostics.Process\
    $p.StartInfo = $pinfo\
    $p.Start() | Out-Null\
    [pscustomobject]@{\
        stdout = $p.StandardOutput.ReadToEnd()\
        stderr = $p.StandardError.ReadToEnd()\
        ExitCode = $p.ExitCode\
    }\
    $p.WaitForExit()\
  }\
  Catch {\
     exit\
  }\
}\
\
<#\
.Description\
Find any resource names that match a wildcard input if one was specified\
#>\
function Get-Resources() \
{\
    $names = $OctopusParameters[\\\"K8SInspectNames\\\"] -Split \\\"`n\\\" | % {$_.Trim()}\
    \
    if ($OctopusParameters[\\\"K8SInspectNames\\\"] -match '\\\\*' )\
    {\
        return Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", $OctopusParameters[\\\"K8SInspectResource\\\"])) |\
            # Select the stdout property from the execution\
            Select-Object -ExpandProperty stdout |\
            # Convert the output from JSON\
            ConvertFrom-JSON | \
            # Get the items object from the kubectl response\
            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\
            # Extract the name\
            % {$_.metadata.name} |\
            # Find any matching resources\
            ? {$k8sName = $_; ($names | ? {$k8sName -like $_}).Count -ne 0}\
    }\
    else\
    {\
        return $names\
    }\
}\
\
<#\
.Description\
Get the kubectl arguments for a given action\
#>\
function Get-KubectlVerb() \
{\
    switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\
    {\
        \\\"get json\\\" {return ,@(\\\"-o\\\", \\\"json\\\", \\\"get\\\")}\
        \\\"get yaml\\\" {return ,@(\\\"-o\\\", \\\"yaml\\\", \\\"get\\\")}\
        \\\"describe\\\" {return ,@(\\\"describe\\\")}\
        \\\"logs\\\" {return ,@(\\\"logs\\\")}\
        \\\"logs tail\\\" {return ,@(\\\"logs\\\", \\\"--tail\\\", \\\"100\\\")}\
        \\\"previous logs\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\")}\
        \\\"previous logs tail\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\", \\\"--tail\\\", \\\"100\\\")}\
        default {return ,@(\\\"get\\\")}\
    }\
}\
\
<#\
.Description\
Get an appropiate file extension based on the selected action\
#>\
function Get-ArtifactExtension() \
{\
   switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\
    {\
        \\\"get json\\\" {\\\"json\\\"}\
        \\\"get yaml\\\" {\\\"yaml\\\"}\
        default {\\\"txt\\\"}\
    }\
}\
\
if ($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"] -like \\\"*logs*\\\") \
{\
    if ( -not @($OctopusParameters[\\\"K8SInspectResource\\\"]) -like \\\"pod*\\\")\
    {\
        Write-Error \\\"Logs can only be returned for pods, not $($OctopusParameters[\\\"K8SInspectResource\\\"])\\\"\
    }\
    else\
    {\
        Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", \\\"pods\\\") + (Get-Resources)) |\
            # Select the stdout property from the execution\
            Select-Object -ExpandProperty stdout |\
            # Convert the output from JSON\
            ConvertFrom-JSON | \
            # Get the items object from the kubectl response\
            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\
            # Get the pod logs for each container\
            % {\
                $podDetails = $_\
                @{\
                    logs=$podDetails.spec.containers | % {$logs=\\\"\\\"} {$logs += (Select-Object -InputObject (Execute-Command kubectl ((Get-KubectlVerb) + @($podDetails.metadata.name, \\\"-c\\\", $_.name))) -ExpandProperty stdout)} {$logs}; \
                    name=$podDetails.metadata.name\
                }                \
            } |\
            # Write the output\
            % {Write-Host $_.logs; $_} |\
            # Optionally capture the artifact\
            % {\
                if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \
                {\
                    Set-Content -Path \\\"$($_.name).$(Get-ArtifactExtension)\\\" -Value $_.logs\
                    New-OctopusArtifact \\\"$($_.name).$(Get-ArtifactExtension)\\\"\
                }\
            }\
    }      \
}\
else\
{\
    Execute-Command kubectl ((Get-KubectlVerb) + @($OctopusParameters[\\\"K8SInspectResource\\\"]) + (Get-Resources)) |\
        % {Select-Object -InputObject $_ -ExpandProperty stdout} |\
        % {Write-Host $_; $_} |\
        % {\
            if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \
            {\
                Set-Content -Path \\\"output.$(Get-ArtifactExtension)\\\" -Value $_\
                New-OctopusArtifact \\\"output.$(Get-ArtifactExtension)\\\"\
            }\
        }\
}\
\"
        \"Octopus.Action.Script.ScriptSource\"            = \"Inline\"
        \"K8SInspectResource\"                            = \"pod\"
        \"Octopus.Action.Script.Syntax\"                  = \"PowerShell\"
        \"Octopus.Action.KubernetesContainers.Namespace\" = \"#{if K8SInspectNamespace}#{K8SInspectNamespace}#{/if}#{unless K8SInspectNamespace}#{Octopus.Action.Kubernetes.Namespace}#{/unless}\"
        \"K8SInspectNames\"                               = \"#{Kubernetes.Deployment.Name}*\"
        \"K8SInspectKubectlVerb\"                         = \"describe\"
      }
      container {
        feed_id = local.docker_hub_feed_id
        image   = \"octopuslabs/k8s-workertools\"
      }
      environments = [
        local.development_environment_id,
        local.test_environment_id,
        local.production_environment_id,
      ]
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = [\"EKS_Reference_Cluster\"]
  }

  step {
    condition           = \"Always\"
    name                = \"Feedback\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.Script\"
      name                               = \"Feedback\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"Octopus.Action.RunOnServer\"         = \"true\"
        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"
        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"
        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"
      }
      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = []
  }
}

resource \"octopusdeploy_runbook\" \"runbook_octopub_products_get_ingress\" {
  count             = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0
  name              = \"🛠️ Get Ingress\"
  project_id        = octopusdeploy_project.project_octopub_products[0].id
  environment_scope = \"Specified\"
  environments      = [
    local.development_environment_id,
    local.test_environment_id,
    local.production_environment_id,
  ]
  force_package_download      = false
  default_guided_failure_mode = \"Off\"
  description                 = <<EOT
**Action**: Returns the ingresses.

**Affects**: Nothing - this runbook makes no changes.

**Resolves**: Finding the public IP to access the deployed application.
EOT
  multi_tenancy_mode          = \"Untenanted\"

  retention_policy {
    quantity_to_keep    = 100
    should_keep_forever = false
  }

  connectivity_policy {
    allow_deployments_to_no_targets = true
    exclude_unhealthy_targets       = false
    skip_machine_behavior           = \"None\"
  }
}

resource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_products_get_ingress\" {
  count      = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0
  runbook_id = octopusdeploy_runbook.runbook_octopub_products_get_ingress[0].id

  step {
    condition           = \"Success\"
    name                = \"Get Ingress\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.KubernetesRunScript\"
      name                               = \"Get Ingress\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      worker_pool_variable               = \"\"
      properties                         = {
        \"K8SInspectCreateArtifact\"                      = \"False\"
        \"Octopus.Action.Script.ScriptBody\"              = \"<#\
    This script provides a general purpose method for querying Kubernetes resources. It supports common operations\
    like get, describe, logs and output formats like yaml and json. Output can be captured as artifacts.\
#>\
\
<#\
.Description\
Execute an application, capturing the output. Based on https://stackoverflow.com/a/33652732/157605\
#>\
Function Execute-Command ($commandPath, $commandArguments)\
{\
  Write-Host \\\"Executing: $commandPath $($commandArguments -join \\\" \\\")\\\"\
  \
  Try {\
    $pinfo = New-Object System.Diagnostics.ProcessStartInfo\
    $pinfo.FileName = $commandPath\
    $pinfo.RedirectStandardError = $true\
    $pinfo.RedirectStandardOutput = $true\
    $pinfo.UseShellExecute = $false\
    $pinfo.Arguments = $commandArguments\
    $p = New-Object System.Diagnostics.Process\
    $p.StartInfo = $pinfo\
    $p.Start() | Out-Null\
    [pscustomobject]@{\
        stdout = $p.StandardOutput.ReadToEnd()\
        stderr = $p.StandardError.ReadToEnd()\
        ExitCode = $p.ExitCode\
    }\
    $p.WaitForExit()\
  }\
  Catch {\
     exit\
  }\
}\
\
<#\
.Description\
Find any resource names that match a wildcard input if one was specified\
#>\
function Get-Resources() \
{\
    $names = $OctopusParameters[\\\"K8SInspectNames\\\"] -Split \\\"`n\\\" | % {$_.Trim()}\
    \
    if ($OctopusParameters[\\\"K8SInspectNames\\\"] -match '\\\\*' )\
    {\
        return Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", $OctopusParameters[\\\"K8SInspectResource\\\"])) |\
            # Select the stdout property from the execution\
            Select-Object -ExpandProperty stdout |\
            # Convert the output from JSON\
            ConvertFrom-JSON | \
            # Get the items object from the kubectl response\
            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\
            # Extract the name\
            % {$_.metadata.name} |\
            # Find any matching resources\
            ? {$k8sName = $_; ($names | ? {$k8sName -like $_}).Count -ne 0}\
    }\
    else\
    {\
        return $names\
    }\
}\
\
<#\
.Description\
Get the kubectl arguments for a given action\
#>\
function Get-KubectlVerb() \
{\
    switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\
    {\
        \\\"get json\\\" {return ,@(\\\"-o\\\", \\\"json\\\", \\\"get\\\")}\
        \\\"get yaml\\\" {return ,@(\\\"-o\\\", \\\"yaml\\\", \\\"get\\\")}\
        \\\"describe\\\" {return ,@(\\\"describe\\\")}\
        \\\"logs\\\" {return ,@(\\\"logs\\\")}\
        \\\"logs tail\\\" {return ,@(\\\"logs\\\", \\\"--tail\\\", \\\"100\\\")}\
        \\\"previous logs\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\")}\
        \\\"previous logs tail\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\", \\\"--tail\\\", \\\"100\\\")}\
        default {return ,@(\\\"get\\\")}\
    }\
}\
\
<#\
.Description\
Get an appropiate file extension based on the selected action\
#>\
function Get-ArtifactExtension() \
{\
   switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\
    {\
        \\\"get json\\\" {\\\"json\\\"}\
        \\\"get yaml\\\" {\\\"yaml\\\"}\
        default {\\\"txt\\\"}\
    }\
}\
\
if ($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"] -like \\\"*logs*\\\") \
{\
    if ( -not @($OctopusParameters[\\\"K8SInspectResource\\\"]) -like \\\"pod*\\\")\
    {\
        Write-Error \\\"Logs can only be returned for pods, not $($OctopusParameters[\\\"K8SInspectResource\\\"])\\\"\
    }\
    else\
    {\
        Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", \\\"pods\\\") + (Get-Resources)) |\
            # Select the stdout property from the execution\
            Select-Object -ExpandProperty stdout |\
            # Convert the output from JSON\
            ConvertFrom-JSON | \
            # Get the items object from the kubectl response\
            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\
            # Get the pod logs for each container\
            % {\
                $podDetails = $_\
                @{\
                    logs=$podDetails.spec.containers | % {$logs=\\\"\\\"} {$logs += (Select-Object -InputObject (Execute-Command kubectl ((Get-KubectlVerb) + @($podDetails.metadata.name, \\\"-c\\\", $_.name))) -ExpandProperty stdout)} {$logs}; \
                    name=$podDetails.metadata.name\
                }                \
            } |\
            # Write the output\
            % {Write-Host $_.logs; $_} |\
            # Optionally capture the artifact\
            % {\
                if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \
                {\
                    Set-Content -Path \\\"$($_.name).$(Get-ArtifactExtension)\\\" -Value $_.logs\
                    New-OctopusArtifact \\\"$($_.name).$(Get-ArtifactExtension)\\\"\
                }\
            }\
    }      \
}\
else\
{\
    Execute-Command kubectl ((Get-KubectlVerb) + @($OctopusParameters[\\\"K8SInspectResource\\\"]) + (Get-Resources)) |\
        % {Select-Object -InputObject $_ -ExpandProperty stdout} |\
        % {Write-Host $_; $_} |\
        % {\
            if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \
            {\
                Set-Content -Path \\\"output.$(Get-ArtifactExtension)\\\" -Value $_\
                New-OctopusArtifact \\\"output.$(Get-ArtifactExtension)\\\"\
            }\
        }\
}\
\"
        \"Octopus.Action.Script.ScriptSource\"            = \"Inline\"
        \"K8SInspectResource\"                            = \"ingress\"
        \"Octopus.Action.Script.Syntax\"                  = \"PowerShell\"
        \"Octopus.Action.KubernetesContainers.Namespace\" = \"#{if K8SInspectNamespace}#{K8SInspectNamespace}#{/if}#{unless K8SInspectNamespace}#{Octopus.Action.Kubernetes.Namespace}#{/unless}\"
        \"K8SInspectNames\"                               = \"#{Kubernetes.Ingress.Name}*\"
        \"K8SInspectKubectlVerb\"                         = \"get\"
      }
      container {
        feed_id = local.docker_hub_feed_id
        image   = \"octopuslabs/k8s-workertools\"
      }
      environments = [
        local.development_environment_id,
        local.test_environment_id,
        local.production_environment_id,
      ]
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = [\"EKS_Reference_Cluster\"]
  }

  step {
    condition           = \"Always\"
    name                = \"Feedback\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.Script\"
      name                               = \"Feedback\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"Octopus.Action.RunOnServer\"         = \"true\"
        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"
        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"
        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"
      }
      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = []
  }
}

resource \"octopusdeploy_runbook\" \"runbook_octopub_products_get_service\" {
  count             = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0
  name              = \"🛠️ Get Service\"
  project_id        = octopusdeploy_project.project_octopub_products[0].id
  environment_scope = \"Specified\"
  environments      = [
    local.development_environment_id,
    local.test_environment_id,
    local.production_environment_id,
  ]
  force_package_download      = false
  default_guided_failure_mode = \"Off\"
  description                 = <<EOT
**Action**: Returns the services.

**Affects**: Nothing - this runbook makes no changes.
EOT
  multi_tenancy_mode          = \"Untenanted\"

  retention_policy {
    quantity_to_keep    = 100
    should_keep_forever = false
  }

  connectivity_policy {
    allow_deployments_to_no_targets = true
    exclude_unhealthy_targets       = false
    skip_machine_behavior           = \"None\"
  }
}

resource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_products_get_service\" {
  count      = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0
  runbook_id = octopusdeploy_runbook.runbook_octopub_products_get_service[0].id

  step {
    condition           = \"Success\"
    name                = \"Get Service\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.KubernetesRunScript\"
      name                               = \"Get Service\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      worker_pool_variable               = \"\"
      properties                         = {
        \"K8SInspectCreateArtifact\"                      = \"False\"
        \"Octopus.Action.Script.ScriptBody\"              = \"<#\
    This script provides a general purpose method for querying Kubernetes resources. It supports common operations\
    like get, describe, logs and output formats like yaml and json. Output can be captured as artifacts.\
#>\
\
<#\
.Description\
Execute an application, capturing the output. Based on https://stackoverflow.com/a/33652732/157605\
#>\
Function Execute-Command ($commandPath, $commandArguments)\
{\
  Write-Host \\\"Executing: $commandPath $($commandArguments -join \\\" \\\")\\\"\
  \
  Try {\
    $pinfo = New-Object System.Diagnostics.ProcessStartInfo\
    $pinfo.FileName = $commandPath\
    $pinfo.RedirectStandardError = $true\
    $pinfo.RedirectStandardOutput = $true\
    $pinfo.UseShellExecute = $false\
    $pinfo.Arguments = $commandArguments\
    $p = New-Object System.Diagnostics.Process\
    $p.StartInfo = $pinfo\
    $p.Start() | Out-Null\
    [pscustomobject]@{\
        stdout = $p.StandardOutput.ReadToEnd()\
        stderr = $p.StandardError.ReadToEnd()\
        ExitCode = $p.ExitCode\
    }\
    $p.WaitForExit()\
  }\
  Catch {\
     exit\
  }\
}\
\
<#\
.Description\
Find any resource names that match a wildcard input if one was specified\
#>\
function Get-Resources() \
{\
    $names = $OctopusParameters[\\\"K8SInspectNames\\\"] -Split \\\"`n\\\" | % {$_.Trim()}\
    \
    if ($OctopusParameters[\\\"K8SInspectNames\\\"] -match '\\\\*' )\
    {\
        return Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", $OctopusParameters[\\\"K8SInspectResource\\\"])) |\
            # Select the stdout property from the execution\
            Select-Object -ExpandProperty stdout |\
            # Convert the output from JSON\
            ConvertFrom-JSON | \
            # Get the items object from the kubectl response\
            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\
            # Extract the name\
            % {$_.metadata.name} |\
            # Find any matching resources\
            ? {$k8sName = $_; ($names | ? {$k8sName -like $_}).Count -ne 0}\
    }\
    else\
    {\
        return $names\
    }\
}\
\
<#\
.Description\
Get the kubectl arguments for a given action\
#>\
function Get-KubectlVerb() \
{\
    switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\
    {\
        \\\"get json\\\" {return ,@(\\\"-o\\\", \\\"json\\\", \\\"get\\\")}\
        \\\"get yaml\\\" {return ,@(\\\"-o\\\", \\\"yaml\\\", \\\"get\\\")}\
        \\\"describe\\\" {return ,@(\\\"describe\\\")}\
        \\\"logs\\\" {return ,@(\\\"logs\\\")}\
        \\\"logs tail\\\" {return ,@(\\\"logs\\\", \\\"--tail\\\", \\\"100\\\")}\
        \\\"previous logs\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\")}\
        \\\"previous logs tail\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\", \\\"--tail\\\", \\\"100\\\")}\
        default {return ,@(\\\"get\\\")}\
    }\
}\
\
<#\
.Description\
Get an appropiate file extension based on the selected action\
#>\
function Get-ArtifactExtension() \
{\
   switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\
    {\
        \\\"get json\\\" {\\\"json\\\"}\
        \\\"get yaml\\\" {\\\"yaml\\\"}\
        default {\\\"txt\\\"}\
    }\
}\
\
if ($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"] -like \\\"*logs*\\\") \
{\
    if ( -not @($OctopusParameters[\\\"K8SInspectResource\\\"]) -like \\\"pod*\\\")\
    {\
        Write-Error \\\"Logs can only be returned for pods, not $($OctopusParameters[\\\"K8SInspectResource\\\"])\\\"\
    }\
    else\
    {\
        Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", \\\"pods\\\") + (Get-Resources)) |\
            # Select the stdout property from the execution\
            Select-Object -ExpandProperty stdout |\
            # Convert the output from JSON\
            ConvertFrom-JSON | \
            # Get the items object from the kubectl response\
            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\
            # Get the pod logs for each container\
            % {\
                $podDetails = $_\
                @{\
                    logs=$podDetails.spec.containers | % {$logs=\\\"\\\"} {$logs += (Select-Object -InputObject (Execute-Command kubectl ((Get-KubectlVerb) + @($podDetails.metadata.name, \\\"-c\\\", $_.name))) -ExpandProperty stdout)} {$logs}; \
                    name=$podDetails.metadata.name\
                }                \
            } |\
            # Write the output\
            % {Write-Host $_.logs; $_} |\
            # Optionally capture the artifact\
            % {\
                if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \
                {\
                    Set-Content -Path \\\"$($_.name).$(Get-ArtifactExtension)\\\" -Value $_.logs\
                    New-OctopusArtifact \\\"$($_.name).$(Get-ArtifactExtension)\\\"\
                }\
            }\
    }      \
}\
else\
{\
    Execute-Command kubectl ((Get-KubectlVerb) + @($OctopusParameters[\\\"K8SInspectResource\\\"]) + (Get-Resources)) |\
        % {Select-Object -InputObject $_ -ExpandProperty stdout} |\
        % {Write-Host $_; $_} |\
        % {\
            if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \
            {\
                Set-Content -Path \\\"output.$(Get-ArtifactExtension)\\\" -Value $_\
                New-OctopusArtifact \\\"output.$(Get-ArtifactExtension)\\\"\
            }\
        }\
}\
\"
        \"Octopus.Action.Script.ScriptSource\"            = \"Inline\"
        \"K8SInspectResource\"                            = \"service\"
        \"Octopus.Action.Script.Syntax\"                  = \"PowerShell\"
        \"Octopus.Action.KubernetesContainers.Namespace\" = \"#{if K8SInspectNamespace}#{K8SInspectNamespace}#{/if}#{unless K8SInspectNamespace}#{Octopus.Action.Kubernetes.Namespace}#{/unless}\"
        \"K8SInspectNames\"                               = \"#{Kubernetes.Service.Name}*\"
        \"K8SInspectKubectlVerb\"                         = \"get\"
      }
      container {
        feed_id = local.docker_hub_feed_id
        image   = \"octopuslabs/k8s-workertools\"
      }
      environments = [
        local.development_environment_id,
        local.test_environment_id,
        local.production_environment_id,
      ]
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = [\"EKS_Reference_Cluster\"]
  }

  step {
    condition           = \"Always\"
    name                = \"Feedback\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.Script\"
      name                               = \"Feedback\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"Octopus.Action.RunOnServer\"         = \"true\"
        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"
        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"
        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"
      }
      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = []
  }
}

resource \"octopusdeploy_runbook\" \"runbook_octopub_products_get_deployment\" {
  count             = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0
  name              = \"🛠️ Get Deployment\"
  project_id        = octopusdeploy_project.project_octopub_products[0].id
  environment_scope = \"Specified\"
  environments      = [
    local.development_environment_id,
    local.test_environment_id,
    local.production_environment_id,
  ]
  force_package_download      = false
  default_guided_failure_mode = \"Off\"
  description                 = <<EOT
**Action**: Returns the deployments.

**Affects**: Nothing - this runbook makes no changes.
EOT
  multi_tenancy_mode          = \"Untenanted\"

  retention_policy {
    quantity_to_keep    = 100
    should_keep_forever = false
  }

  connectivity_policy {
    allow_deployments_to_no_targets = true
    exclude_unhealthy_targets       = false
    skip_machine_behavior           = \"None\"
  }
}

resource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_products_get_deployment\" {
  count      = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0
  runbook_id = octopusdeploy_runbook.runbook_octopub_products_get_deployment[0].id

  step {
    condition           = \"Success\"
    name                = \"Get Deployment\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.KubernetesRunScript\"
      name                               = \"Get Deployment\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      worker_pool_variable               = \"\"
      properties                         = {
        \"K8SInspectCreateArtifact\"                      = \"False\"
        \"Octopus.Action.Script.ScriptBody\"              = \"<#\
    This script provides a general purpose method for querying Kubernetes resources. It supports common operations\
    like get, describe, logs and output formats like yaml and json. Output can be captured as artifacts.\
#>\
\
<#\
.Description\
Execute an application, capturing the output. Based on https://stackoverflow.com/a/33652732/157605\
#>\
Function Execute-Command ($commandPath, $commandArguments)\
{\
  Write-Host \\\"Executing: $commandPath $($commandArguments -join \\\" \\\")\\\"\
  \
  Try {\
    $pinfo = New-Object System.Diagnostics.ProcessStartInfo\
    $pinfo.FileName = $commandPath\
    $pinfo.RedirectStandardError = $true\
    $pinfo.RedirectStandardOutput = $true\
    $pinfo.UseShellExecute = $false\
    $pinfo.Arguments = $commandArguments\
    $p = New-Object System.Diagnostics.Process\
    $p.StartInfo = $pinfo\
    $p.Start() | Out-Null\
    [pscustomobject]@{\
        stdout = $p.StandardOutput.ReadToEnd()\
        stderr = $p.StandardError.ReadToEnd()\
        ExitCode = $p.ExitCode\
    }\
    $p.WaitForExit()\
  }\
  Catch {\
     exit\
  }\
}\
\
<#\
.Description\
Find any resource names that match a wildcard input if one was specified\
#>\
function Get-Resources() \
{\
    $names = $OctopusParameters[\\\"K8SInspectNames\\\"] -Split \\\"`n\\\" | % {$_.Trim()}\
    \
    if ($OctopusParameters[\\\"K8SInspectNames\\\"] -match '\\\\*' )\
    {\
        return Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", $OctopusParameters[\\\"K8SInspectResource\\\"])) |\
            # Select the stdout property from the execution\
            Select-Object -ExpandProperty stdout |\
            # Convert the output from JSON\
            ConvertFrom-JSON | \
            # Get the items object from the kubectl response\
            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\
            # Extract the name\
            % {$_.metadata.name} |\
            # Find any matching resources\
            ? {$k8sName = $_; ($names | ? {$k8sName -like $_}).Count -ne 0}\
    }\
    else\
    {\
        return $names\
    }\
}\
\
<#\
.Description\
Get the kubectl arguments for a given action\
#>\
function Get-KubectlVerb() \
{\
    switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\
    {\
        \\\"get json\\\" {return ,@(\\\"-o\\\", \\\"json\\\", \\\"get\\\")}\
        \\\"get yaml\\\" {return ,@(\\\"-o\\\", \\\"yaml\\\", \\\"get\\\")}\
        \\\"describe\\\" {return ,@(\\\"describe\\\")}\
        \\\"logs\\\" {return ,@(\\\"logs\\\")}\
        \\\"logs tail\\\" {return ,@(\\\"logs\\\", \\\"--tail\\\", \\\"100\\\")}\
        \\\"previous logs\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\")}\
        \\\"previous logs tail\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\", \\\"--tail\\\", \\\"100\\\")}\
        default {return ,@(\\\"get\\\")}\
    }\
}\
\
<#\
.Description\
Get an appropiate file extension based on the selected action\
#>\
function Get-ArtifactExtension() \
{\
   switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\
    {\
        \\\"get json\\\" {\\\"json\\\"}\
        \\\"get yaml\\\" {\\\"yaml\\\"}\
        default {\\\"txt\\\"}\
    }\
}\
\
if ($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"] -like \\\"*logs*\\\") \
{\
    if ( -not @($OctopusParameters[\\\"K8SInspectResource\\\"]) -like \\\"pod*\\\")\
    {\
        Write-Error \\\"Logs can only be returned for pods, not $($OctopusParameters[\\\"K8SInspectResource\\\"])\\\"\
    }\
    else\
    {\
        Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", \\\"pods\\\") + (Get-Resources)) |\
            # Select the stdout property from the execution\
            Select-Object -ExpandProperty stdout |\
            # Convert the output from JSON\
            ConvertFrom-JSON | \
            # Get the items object from the kubectl response\
            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\
            # Get the pod logs for each container\
            % {\
                $podDetails = $_\
                @{\
                    logs=$podDetails.spec.containers | % {$logs=\\\"\\\"} {$logs += (Select-Object -InputObject (Execute-Command kubectl ((Get-KubectlVerb) + @($podDetails.metadata.name, \\\"-c\\\", $_.name))) -ExpandProperty stdout)} {$logs}; \
                    name=$podDetails.metadata.name\
                }                \
            } |\
            # Write the output\
            % {Write-Host $_.logs; $_} |\
            # Optionally capture the artifact\
            % {\
                if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \
                {\
                    Set-Content -Path \\\"$($_.name).$(Get-ArtifactExtension)\\\" -Value $_.logs\
                    New-OctopusArtifact \\\"$($_.name).$(Get-ArtifactExtension)\\\"\
                }\
            }\
    }      \
}\
else\
{\
    Execute-Command kubectl ((Get-KubectlVerb) + @($OctopusParameters[\\\"K8SInspectResource\\\"]) + (Get-Resources)) |\
        % {Select-Object -InputObject $_ -ExpandProperty stdout} |\
        % {Write-Host $_; $_} |\
        % {\
            if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \
            {\
                Set-Content -Path \\\"output.$(Get-ArtifactExtension)\\\" -Value $_\
                New-OctopusArtifact \\\"output.$(Get-ArtifactExtension)\\\"\
            }\
        }\
}\
\"
        \"Octopus.Action.Script.ScriptSource\"            = \"Inline\"
        \"K8SInspectResource\"                            = \"deployment\"
        \"Octopus.Action.Script.Syntax\"                  = \"PowerShell\"
        \"Octopus.Action.KubernetesContainers.Namespace\" = \"#{if K8SInspectNamespace}#{K8SInspectNamespace}#{/if}#{unless K8SInspectNamespace}#{Octopus.Action.Kubernetes.Namespace}#{/unless}\"
        \"K8SInspectNames\"                               = \"#{Kubernetes.Deployment.Name}*\"
        \"K8SInspectKubectlVerb\"                         = \"get\"
      }
      container {
        feed_id = local.docker_hub_feed_id
        image   = \"octopuslabs/k8s-workertools\"
      }
      environments = [
        local.development_environment_id,
        local.test_environment_id,
        local.production_environment_id,
      ]
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = [\"EKS_Reference_Cluster\"]
  }

  step {
    condition           = \"Always\"
    name                = \"Feedback\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.Script\"
      name                               = \"Feedback\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"Octopus.Action.RunOnServer\"         = \"true\"
        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"
        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"
        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"
      }
      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = []
  }
}
#endregion

#region Audits
variable \"audits_project_name\" {
  type    = string
  default = \"\"
}

data \"octopusdeploy_projects\" \"octopub_audits\" {
  partial_name = var.audits_project_name == \"\" ? local.audits_project_name : var.audits_project_name
  skip         = 0
  take         = 1
}

resource \"octopusdeploy_variable\" \"audits_deployment_feed\" {
  count        = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0
  owner_id     = octopusdeploy_project.project_octopub_audits[0].id
  value        = local.docker_hub_feed_id
  name         = \"Kubernetes.Deployment.Feed\"
  type         = \"String\"
  description  = \"The feed ID hosting the image\"
  is_sensitive = false
}

resource \"octopusdeploy_variable\" \"audits_deployment_image\" {
  count        = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0
  owner_id     = octopusdeploy_project.project_octopub_audits[0].id
  value        = \"octopussamples/octopub-audit-microservice\"
  name         = \"Kubernetes.Deployment.Image\"
  type         = \"String\"
  description  = \"The image to deploy\"
  is_sensitive = false
}

resource \"octopusdeploy_variable\" \"audits_deployment_port\" {
  count        = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0
  owner_id     = octopusdeploy_project.project_octopub_audits[0].id
  value        = \"10000\"
  name         = \"Kubernetes.Deployment.Port\"
  type         = \"String\"
  description  = \"The port exposed by the web app\"
  is_sensitive = false
}

resource \"octopusdeploy_variable\" \"auditss_microservice_name\" {
  count        = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0
  owner_id     = octopusdeploy_project.project_octopub_audits[0].id
  value        = \"audits\"
  name         = \"Microservice.Name\"
  type         = \"String\"
  description  = \"The microservice name, which is used as the basis for K8s resources and networking paths\"
  is_sensitive = false
  depends_on   = []
}

resource \"octopusdeploy_variable\" \"audits_deployment_name\" {
  count        = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0
  owner_id     = octopusdeploy_project.project_octopub_audits[0].id
  value        = \"#{Microservice.Name}\"
  name         = \"Kubernetes.Deployment.Name\"
  type         = \"String\"
  description  = \"\"
  is_sensitive = false
  depends_on   = []
}

resource \"octopusdeploy_variable\" \"audits_service_name\" {
  count        = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0
  owner_id     = octopusdeploy_project.project_octopub_audits[0].id
  value        = \"#{Microservice.Name}\"
  name         = \"Kubernetes.Service.Name\"
  type         = \"String\"
  description  = \"\"
  is_sensitive = false
  depends_on   = []
}

resource \"octopusdeploy_variable\" \"audits_ingress_name\" {
  count        = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0
  owner_id     = octopusdeploy_project.project_octopub_audits[0].id
  value        = \"#{Microservice.Name}\"
  name         = \"Kubernetes.Ingress.Name\"
  type         = \"String\"
  description  = \"\"
  is_sensitive = false
  depends_on   = []
}

resource \"octopusdeploy_variable\" \"audits_ingress_path\" {
  count        = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0
  owner_id     = octopusdeploy_project.project_octopub_audits[0].id
  value        = \"/#{Kubernetes.Namespace}(/api/#{Microservice.Name})(/.*)?\"
  name         = \"Kubernetes.Ingress.Path\"
  type         = \"String\"
  description  = \"The path of the Kubernetes ingress resource\"
  is_sensitive = false
  depends_on   = []
}

resource \"octopusdeploy_variable\" \"audits_app_path\" {
  count        = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0
  owner_id     = octopusdeploy_project.project_octopub_audits[0].id
  value        = \"/#{Kubernetes.Namespace}/api/#{Microservice.Name}\"
  name         = \"Kubernetes.App.HealthCheck\"
  type         = \"String\"
  description  = \"The path to perform a health check on.\"
  is_sensitive = false
  depends_on   = []
}

resource \"octopusdeploy_variable\" \"audits_namespace_default\" {
  count        = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0
  owner_id     = octopusdeploy_project.project_octopub_audits[0].id
  value        = \"#{Octopus.Action.Kubernetes.Namespace}\"
  name         = \"Kubernetes.Namespace\"
  type         = \"String\"
  description  = \"The namespace to perform the deployments in.\"
  is_sensitive = false
  depends_on   = []
}

resource \"octopusdeploy_variable\" \"audits_namespace_featurebranch\" {
  count        = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0
  owner_id     = octopusdeploy_project.project_octopub_audits[0].id
  value        = \"\"
  name         = \"Kubernetes.Namespace\"
  type         = \"String\"
  description  = \"The custom namespace to use when deploying a feature branch\"
  is_sensitive = false

  scope {
    actions      = []
    channels     = []
    environments = [local.featurebranch_environment_id]
    machines     = []
    roles        = null
    tenant_tags  = null
  }

  prompt {
    description = \"Feature branch namespace\"
    label       = \"Namespace\"
    is_required = true
    display_settings {
      control_type = \"SingleLineText\"
    }
  }
}

resource \"octopusdeploy_channel\" \"audits_featurebranch\" {
  count        = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0
  name         = \"Feature Branch\"
  project_id   = octopusdeploy_project.project_octopub_audits[0].id
  description  = \"Deploy feature branch builds\"
  is_default   = false
  lifecycle_id = local.featurebranch_lifecycle_id
}

resource \"octopusdeploy_channel\" \"audits_mainline\" {
  count        = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0
  name         = \"Mainline\"
  project_id   = octopusdeploy_project.project_octopub_audits[0].id
  description  = \"Deploy mainline builds\"
  is_default   = true
  lifecycle_id = local.devops_lifecycle_id
  rule {
    tag = \"^$\"
    action_package {
      deployment_action = \"Deploy Container\"
      package_reference = \"web\"
    }
  }

  depends_on  = [octopusdeploy_deployment_process.deployment_process_octopub_audits]
}

resource \"octopusdeploy_project\" \"project_octopub_audits\" {
  count                                = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0
  name                                 = var.audits_project_name == \"\" ? local.audits_project_name : var.audits_project_name
  auto_create_release                  = false
  default_guided_failure_mode          = \"Off\"
  default_to_skip_if_already_installed = false
  discrete_channel_release             = false
  is_disabled                          = false
  is_version_controlled                = false
  lifecycle_id                         = local.devops_lifecycle_id
  project_group_id                     = local.eks_project_group_id
  included_library_variable_sets       = [local.this_instance_library_variable_set, local.github_library_variable_set]
  tenanted_deployment_participation    = \"Untenanted\"

  connectivity_policy {
    allow_deployments_to_no_targets = true
    exclude_unhealthy_targets       = false
    skip_machine_behavior           = \"None\"
  }

  versioning_strategy {
    template = \"#{Octopus.Version.LastMajor}.#{Octopus.Version.LastMinor}.#{Octopus.Version.NextPatch}\"
  }

  lifecycle {
    ignore_changes = []
  }
  description = <<EOT
Deploys the Octopub Audits Service

**Source**: [GitHub](https://github.com/OctopusSolutionsEngineering/Octopub)

**Build**: [GitHub Actions](https://github.com/OctopusSolutionsEngineering/Octopub/actions)

**Issues**: [GitHub Issues](https://github.com/OctopusSolutionsEngineering/Octopub/issues)
EOT
}

resource \"octopusdeploy_deployment_process\" \"deployment_process_octopub_audits\" {
  count      = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0
  project_id = octopusdeploy_project.project_octopub_audits[0].id

  step {
    condition           = \"Success\"
    name                = \"Generate Variables\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.Script\"
      name                               = \"Generate Variables\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"Octopus.Action.RunOnServer\"         = \"true\"
        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"
        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"
        \"Octopus.Action.Script.ScriptBody\"   = local.variable_script
      }
      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = []
  }

  step {
    condition           = \"Success\"
    name                = \"Deploy Container\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.KubernetesDeployContainers\"
      name                               = \"Deploy Container\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = true
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"Octopus.Action.KubernetesContainers.Namespace\"              = \"#{Kubernetes.Namespace}\"
        \"Octopus.Action.KubernetesContainers.Replicas\"               = \"1\"
        \"Octopus.Action.KubernetesContainers.DeploymentResourceType\" = \"Deployment\"
        \"Octopus.Action.KubernetesContainers.IngressAnnotations\"     = jsonencode([
          {
            \"optionError\"  = null
            \"option2\"      = \"\"
            \"option2Error\" = null
            \"key\"          = \"nginx.ingress.kubernetes.io/rewrite-target\"
            \"keyError\"     = null
            \"value\"        = \"$1$2\"
            \"valueError\"   = null
            \"option\"       = \"\"
          },
          {
            \"keyError\"     = null
            \"value\"        = \"true\"
            \"valueError\"   = null
            \"option\"       = \"\"
            \"optionError\"  = null
            \"option2\"      = \"\"
            \"option2Error\" = null
            \"key\"          = \"nginx.ingress.kubernetes.io/use-regex\"
          },
        ])
        \"Octopus.Action.KubernetesContainers.DeploymentStyle\" = \"RollingUpdate\"
        \"Octopus.Action.KubernetesContainers.IngressName\"     = \"#{Kubernetes.Ingress.Name}\"
        \"Octopus.Action.KubernetesContainers.DeploymentName\"  = \"#{Kubernetes.Deployment.Name}\"
        \"Octopus.Action.KubernetesContainers.IngressRules\"    = jsonencode([
          {
            \"host\" = \"\"
            \"http\" = {
              \"paths\" = [
                {
                  \"key\"     = \"#{Kubernetes.Ingress.Path}\"
                  \"value\"   = \"web\"
                  \"option\"  = \"\"
                  \"option2\" = \"ImplementationSpecific\"
                },
              ]
            }
          },
        ])
        \"OctopusUseBundledTooling\"                       = \"False\"
        \"Octopus.Action.KubernetesContainers.Containers\" = jsonencode([
          {
            \"Args\"                         = []
            \"FieldRefEnvironmentVariables\" = []
            \"SecretEnvFromSource\"          = []
            \"Command\"                      = []
            \"Ports\"                        = [
              {
                \"option2Error\" = null
                \"optionError\"  = null
                \"value\"        = \"#{Kubernetes.Deployment.Port}\"
                \"valueError\"   = null
                \"key\"          = \"web\"
                \"keyError\"     = null
                \"option\"       = \"TCP\"
                \"option2\"      = \"\"
              },
            ]
            \"Resources\" = {
              \"limits\" = {
                \"storage\"          = \"\"
                \"amdGpu\"           = \"\"
                \"cpu\"              = \"\"
                \"ephemeralStorage\" = \"\"
                \"memory\"           = \"\"
                \"nvidiaGpu\"        = \"\"
              }
              \"requests\" = {
                \"amdGpu\"           = \"\"
                \"cpu\"              = \"\"
                \"ephemeralStorage\" = \"\"
                \"memory\"           = \"\"
                \"nvidiaGpu\"        = \"\"
                \"storage\"          = \"\"
              }
            }
            \"SecretEnvironmentVariables\" = []
            \"SecurityContext\"            = {
              \"runAsNonRoot\"   = \"True\"
              \"runAsUser\"      = \"\"
              \"seLinuxOptions\" = {
                \"level\" = \"\"
                \"role\"  = \"\"
                \"type\"  = \"\"
                \"user\"  = \"\"
              }
              \"allowPrivilegeEscalation\" = \"\"
              \"capabilities\"             = {
                \"add\"  = []
                \"drop\" = [
                  \"ALL\",
                ]
              }
              \"privileged\"             = \"\"
              \"readOnlyRootFilesystem\" = \"\"
              \"runAsGroup\"             = \"\"
            }
            \"TerminationMessagePath\" = \"\"
            \"EnvironmentVariables\"   = [
              {
                \"key\"          = \"PORT\"
                \"keyError\"     = null
                \"value\"        = \"#{Kubernetes.Deployment.Port}\"
                \"valueError\"   = null
                \"option\"       = \"\"
                \"optionError\"  = null
                \"option2\"      = \"\"
                \"option2Error\" = null
              },
              {
                \"key\"          = \"COGNITO_DISABLE_AUTH\"
                \"keyError\"     = null
                \"value\"        = \"True\"
                \"valueError\"   = null
                \"option\"       = \"\"
                \"optionError\"  = null
                \"option2\"      = \"\"
                \"option2Error\" = null
              },
              {
                \"key\"          = \"MIGRATE_AT_START\"
                \"keyError\"     = null
                \"value\"        = \"True\"
                \"valueError\"   = null
                \"option\"       = \"\"
                \"optionError\"  = null
                \"option2\"      = \"\"
                \"option2Error\" = null
              },
            ]
            \"LivenessProbe\" = {
              \"successThreshold\" = \"\"
              \"tcpSocket\"        = {
                \"port\" = \"\"
                \"host\" = \"\"
              }
              \"exec\" = {
                \"command\" = []
              }
              \"failureThreshold\" = \"\"
              \"periodSeconds\"    = \"\"
              \"type\"             = \"\"
              \"httpGet\"          = {
                \"host\"        = \"\"
                \"httpHeaders\" = []
                \"path\"        = \"\"
                \"port\"        = \"\"
                \"scheme\"      = \"\"
              }
              \"initialDelaySeconds\" = \"\"
              \"timeoutSeconds\"      = \"\"
            }
            \"ReadinessProbe\" = {
              \"exec\" = {
                \"command\" = []
              }
              \"failureThreshold\" = \"\"
              \"timeoutSeconds\"   = \"\"
              \"successThreshold\" = \"\"
              \"tcpSocket\"        = {
                \"host\" = \"\"
                \"port\" = \"\"
              }
              \"type\"    = \"\"
              \"httpGet\" = {
                \"host\"        = \"\"
                \"httpHeaders\" = []
                \"path\"        = \"\"
                \"port\"        = \"\"
                \"scheme\"      = \"\"
              }
              \"initialDelaySeconds\" = \"\"
              \"periodSeconds\"       = \"\"
            }
            \"TerminationMessagePolicy\"      = \"\"
            \"VolumeMounts\"                  = []
            \"ConfigMapEnvFromSource\"        = []
            \"ConfigMapEnvironmentVariables\" = []
            \"CreateFeedSecrets\"             = \"False\"
            \"Lifecycle\"                     = {
              \"PostStart\" = null
              \"PreStop\"   = null
            }
            \"Name\"         = \"web\"
            \"StartupProbe\" = {
              \"successThreshold\" = \"\"
              \"tcpSocket\"        = {
                \"host\" = \"\"
                \"port\" = \"\"
              }
              \"failureThreshold\" = \"\"
              \"httpGet\"          = {
                \"host\"        = \"\"
                \"httpHeaders\" = []
                \"path\"        = \"\"
                \"port\"        = \"\"
                \"scheme\"      = \"\"
              }
              \"initialDelaySeconds\" = \"\"
              \"type\"                = \"\"
              \"exec\"                = {
                \"command\" = []
              }
              \"periodSeconds\"  = \"\"
              \"timeoutSeconds\" = \"\"
            }
          },
        ])
        \"Octopus.Action.KubernetesContainers.ServiceName\"         = \"#{Kubernetes.Service.Name}\"
        \"Octopus.Action.KubernetesContainers.PodManagementPolicy\" = \"OrderedReady\"
        \"Octopus.Action.Kubernetes.DeploymentTimeout\"             = \"180\"
        \"Octopus.Action.RunOnServer\"                              = \"true\"
        \"Octopus.Action.KubernetesContainers.IngressClassName\"    = \"nginx\"
        \"Octopus.Action.KubernetesContainers.ServicePorts\"        = jsonencode([
          {
            \"port\"       = \"80\"
            \"protocol\"   = \"TCP\"
            \"targetPort\" = \"web\"
            \"name\"       = \"web\"
            \"nodePort\"   = \"\"
          },
        ])
        \"Octopus.Action.Kubernetes.ResourceStatusCheck\"       = \"True\"
        \"Octopus.Action.KubernetesContainers.ServiceNameType\" = \"External\"
        \"Octopus.Action.KubernetesContainers.ServiceType\"     = \"ClusterIP\"
      }
      container {
        feed_id = local.docker_hub_feed_id
        image   = \"octopuslabs/k8s-workertools\"
      }

      environments = [
        local.development_environment_id,
        local.test_environment_id,
        local.production_environment_id,
        local.featurebranch_environment_id,
      ]
      excluded_environments = []
      channels              = []
      tenant_tags           = []

      package {
        name                      = \"web\"
        package_id                = \"#{Kubernetes.Deployment.Image}\"
        acquisition_location      = \"NotAcquired\"
        extract_during_deployment = false
        feed_id                   = \"#{Kubernetes.Deployment.Feed}\"
        properties                = { Extract = \"False\", PackageParameterName = \"\", SelectionMode = \"immediate\" }
      }
      features = [
        \"\", \"Octopus.Features.KubernetesService\", \"Octopus.Features.KubernetesIngress\",
        \"Octopus.Features.KubernetesConfigMap\", \"Octopus.Features.KubernetesSecret\"
      ]
    }

    properties   = {}
    target_roles = [\"EKS_Reference_Cluster\"]
  }

  step {
    condition           = \"Success\"
    name                = \"Smoke Test\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.KubernetesRunScript\"
      name                               = \"Smoke Test\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"Octopus.Action.KubernetesContainers.Namespace\" = \"#{Kubernetes.Namespace}\"
        \"Octopus.Action.RunOnServer\"                    = \"true\"
        \"Octopus.Action.Script.ScriptSource\"            = \"Inline\"
        \"Octopus.Action.Script.Syntax\"                  = \"Bash\"
        \"Octopus.Action.Script.ScriptBody\"              = local.smoke_test
      }
      container {
        feed_id = local.docker_hub_feed_id
        image   = \"octopuslabs/k8s-workertools\"
      }
      environments = [
        local.development_environment_id,
        local.test_environment_id,
        local.production_environment_id,
        local.featurebranch_environment_id,
      ]
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = [\"EKS_Reference_Cluster\"]
  }

  step {
    condition           = \"Success\"
    name                = \"Security Scan\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.Script\"
      name                               = \"Security Scan\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = true
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"Octopus.Action.RunOnServer\"         = \"true\"
        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"
        \"Octopus.Action.Script.Syntax\"       = \"Bash\"
        \"Octopus.Action.Script.ScriptBody\"   = local.security_scan_script
      }
      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = []
  }

  step {
    condition           = \"Always\"
    name                = \"Feedback\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.Script\"
      name                               = \"Feedback\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"Octopus.Action.RunOnServer\"         = \"true\"
        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"
        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"
        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"
      }
      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = []
  }
}

resource \"octopusdeploy_runbook\" \"runbook_octopub_audits_get_pod_logs\" {
  count             = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0
  name              = \"🛠️ Get Pod Logs\"
  project_id        = octopusdeploy_project.project_octopub_audits[0].id
  environment_scope = \"Specified\"
  environments      = [
    local.development_environment_id,
    local.test_environment_id,
    local.production_environment_id,
  ]
  force_package_download      = false
  default_guided_failure_mode = \"Off\"
  description                 = <<EOT
**Action**: Returns the pod logs.

**Affects**: Nothing - this runbook makes no changes.
EOT
  multi_tenancy_mode          = \"Untenanted\"

  retention_policy {
    quantity_to_keep    = 100
    should_keep_forever = false
  }

  connectivity_policy {
    allow_deployments_to_no_targets = true
    exclude_unhealthy_targets       = false
    skip_machine_behavior           = \"None\"
  }
}

resource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_audits_get_pod_logs\" {
  count      = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0
  runbook_id = octopusdeploy_runbook.runbook_octopub_audits_get_pod_logs[0].id

  step {
    condition           = \"Success\"
    name                = \"Get Pod Logs\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.KubernetesRunScript\"
      name                               = \"Get Pod Logs\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      worker_pool_variable               = \"\"
      properties                         = {
        \"K8SInspectCreateArtifact\"                      = \"False\"
        \"Octopus.Action.Script.ScriptBody\"              = \"<#\
    This script provides a general purpose method for querying Kubernetes resources. It supports common operations\
    like get, describe, logs and output formats like yaml and json. Output can be captured as artifacts.\
#>\
\
<#\
.Description\
Execute an application, capturing the output. Based on https://stackoverflow.com/a/33652732/157605\
#>\
Function Execute-Command ($commandPath, $commandArguments)\
{\
  Write-Host \\\"Executing: $commandPath $($commandArguments -join \\\" \\\")\\\"\
  \
  Try {\
    $pinfo = New-Object System.Diagnostics.ProcessStartInfo\
    $pinfo.FileName = $commandPath\
    $pinfo.RedirectStandardError = $true\
    $pinfo.RedirectStandardOutput = $true\
    $pinfo.UseShellExecute = $false\
    $pinfo.Arguments = $commandArguments\
    $p = New-Object System.Diagnostics.Process\
    $p.StartInfo = $pinfo\
    $p.Start() | Out-Null\
    [pscustomobject]@{\
        stdout = $p.StandardOutput.ReadToEnd()\
        stderr = $p.StandardError.ReadToEnd()\
        ExitCode = $p.ExitCode\
    }\
    $p.WaitForExit()\
  }\
  Catch {\
     exit\
  }\
}\
\
<#\
.Description\
Find any resource names that match a wildcard input if one was specified\
#>\
function Get-Resources() \
{\
    $names = $OctopusParameters[\\\"K8SInspectNames\\\"] -Split \\\"`n\\\" | % {$_.Trim()}\
    \
    if ($OctopusParameters[\\\"K8SInspectNames\\\"] -match '\\\\*' )\
    {\
        return Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", $OctopusParameters[\\\"K8SInspectResource\\\"])) |\
            # Select the stdout property from the execution\
            Select-Object -ExpandProperty stdout |\
            # Convert the output from JSON\
            ConvertFrom-JSON | \
            # Get the items object from the kubectl response\
            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\
            # Extract the name\
            % {$_.metadata.name} |\
            # Find any matching resources\
            ? {$k8sName = $_; ($names | ? {$k8sName -like $_}).Count -ne 0}\
    }\
    else\
    {\
        return $names\
    }\
}\
\
<#\
.Description\
Get the kubectl arguments for a given action\
#>\
function Get-KubectlVerb() \
{\
    switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\
    {\
        \\\"get json\\\" {return ,@(\\\"-o\\\", \\\"json\\\", \\\"get\\\")}\
        \\\"get yaml\\\" {return ,@(\\\"-o\\\", \\\"yaml\\\", \\\"get\\\")}\
        \\\"describe\\\" {return ,@(\\\"describe\\\")}\
        \\\"logs\\\" {return ,@(\\\"logs\\\")}\
        \\\"logs tail\\\" {return ,@(\\\"logs\\\", \\\"--tail\\\", \\\"100\\\")}\
        \\\"previous logs\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\")}\
        \\\"previous logs tail\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\", \\\"--tail\\\", \\\"100\\\")}\
        default {return ,@(\\\"get\\\")}\
    }\
}\
\
<#\
.Description\
Get an appropiate file extension based on the selected action\
#>\
function Get-ArtifactExtension() \
{\
   switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\
    {\
        \\\"get json\\\" {\\\"json\\\"}\
        \\\"get yaml\\\" {\\\"yaml\\\"}\
        default {\\\"txt\\\"}\
    }\
}\
\
if ($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"] -like \\\"*logs*\\\") \
{\
    if ( -not @($OctopusParameters[\\\"K8SInspectResource\\\"]) -like \\\"pod*\\\")\
    {\
        Write-Error \\\"Logs can only be returned for pods, not $($OctopusParameters[\\\"K8SInspectResource\\\"])\\\"\
    }\
    else\
    {\
        Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", \\\"pods\\\") + (Get-Resources)) |\
            # Select the stdout property from the execution\
            Select-Object -ExpandProperty stdout |\
            # Convert the output from JSON\
            ConvertFrom-JSON | \
            # Get the items object from the kubectl response\
            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\
            # Get the pod logs for each container\
            % {\
                $podDetails = $_\
                @{\
                    logs=$podDetails.spec.containers | % {$logs=\\\"\\\"} {$logs += (Select-Object -InputObject (Execute-Command kubectl ((Get-KubectlVerb) + @($podDetails.metadata.name, \\\"-c\\\", $_.name))) -ExpandProperty stdout)} {$logs}; \
                    name=$podDetails.metadata.name\
                }                \
            } |\
            # Write the output\
            % {Write-Host $_.logs; $_} |\
            # Optionally capture the artifact\
            % {\
                if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \
                {\
                    Set-Content -Path \\\"$($_.name).$(Get-ArtifactExtension)\\\" -Value $_.logs\
                    New-OctopusArtifact \\\"$($_.name).$(Get-ArtifactExtension)\\\"\
                }\
            }\
    }      \
}\
else\
{\
    Execute-Command kubectl ((Get-KubectlVerb) + @($OctopusParameters[\\\"K8SInspectResource\\\"]) + (Get-Resources)) |\
        % {Select-Object -InputObject $_ -ExpandProperty stdout} |\
        % {Write-Host $_; $_} |\
        % {\
            if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \
            {\
                Set-Content -Path \\\"output.$(Get-ArtifactExtension)\\\" -Value $_\
                New-OctopusArtifact \\\"output.$(Get-ArtifactExtension)\\\"\
            }\
        }\
}\
\"
        \"Octopus.Action.Script.ScriptSource\"            = \"Inline\"
        \"K8SInspectResource\"                            = \"pod\"
        \"Octopus.Action.Script.Syntax\"                  = \"PowerShell\"
        \"Octopus.Action.KubernetesContainers.Namespace\" = \"#{if K8SInspectNamespace}#{K8SInspectNamespace}#{/if}#{unless K8SInspectNamespace}#{Octopus.Action.Kubernetes.Namespace}#{/unless}\"
        \"K8SInspectNames\"                               = \"#{Kubernetes.Deployment.Name}*\"
        \"K8SInspectKubectlVerb\"                         = \"logs\"
      }
      container {
        feed_id = local.docker_hub_feed_id
        image   = \"octopuslabs/k8s-workertools\"
      }
      environments = [
        local.development_environment_id,
        local.test_environment_id,
        local.production_environment_id,
      ]
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = [\"EKS_Reference_Cluster\"]
  }

  step {
    condition           = \"Always\"
    name                = \"Feedback\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.Script\"
      name                               = \"Feedback\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"Octopus.Action.RunOnServer\"         = \"true\"
        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"
        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"
        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"
      }
      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = []
  }
}

resource \"octopusdeploy_runbook\" \"runbook_octopub_audits_get_pods\" {
  count             = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0
  name              = \"🛠️ Get Pods\"
  project_id        = octopusdeploy_project.project_octopub_audits[0].id
  environment_scope = \"Specified\"
  environments      = [
    local.development_environment_id,
    local.test_environment_id,
    local.production_environment_id,
  ]
  force_package_download      = false
  default_guided_failure_mode = \"Off\"
  description                 = <<EOT
**Action**: Returns the pods.

**Affects**: Nothing - this runbook makes no changes.
EOT
  multi_tenancy_mode          = \"Untenanted\"

  retention_policy {
    quantity_to_keep    = 100
    should_keep_forever = false
  }

  connectivity_policy {
    allow_deployments_to_no_targets = true
    exclude_unhealthy_targets       = false
    skip_machine_behavior           = \"None\"
  }
}

resource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_audits_get_pods\" {
  count      = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0
  runbook_id = octopusdeploy_runbook.runbook_octopub_audits_get_pods[0].id

  step {
    condition           = \"Success\"
    name                = \"Get Pods\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.KubernetesRunScript\"
      name                               = \"Get Pods\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      worker_pool_variable               = \"\"
      properties                         = {
        \"K8SInspectCreateArtifact\"                      = \"False\"
        \"Octopus.Action.Script.ScriptBody\"              = \"<#\
    This script provides a general purpose method for querying Kubernetes resources. It supports common operations\
    like get, describe, logs and output formats like yaml and json. Output can be captured as artifacts.\
#>\
\
<#\
.Description\
Execute an application, capturing the output. Based on https://stackoverflow.com/a/33652732/157605\
#>\
Function Execute-Command ($commandPath, $commandArguments)\
{\
  Write-Host \\\"Executing: $commandPath $($commandArguments -join \\\" \\\")\\\"\
  \
  Try {\
    $pinfo = New-Object System.Diagnostics.ProcessStartInfo\
    $pinfo.FileName = $commandPath\
    $pinfo.RedirectStandardError = $true\
    $pinfo.RedirectStandardOutput = $true\
    $pinfo.UseShellExecute = $false\
    $pinfo.Arguments = $commandArguments\
    $p = New-Object System.Diagnostics.Process\
    $p.StartInfo = $pinfo\
    $p.Start() | Out-Null\
    [pscustomobject]@{\
        stdout = $p.StandardOutput.ReadToEnd()\
        stderr = $p.StandardError.ReadToEnd()\
        ExitCode = $p.ExitCode\
    }\
    $p.WaitForExit()\
  }\
  Catch {\
     exit\
  }\
}\
\
<#\
.Description\
Find any resource names that match a wildcard input if one was specified\
#>\
function Get-Resources() \
{\
    $names = $OctopusParameters[\\\"K8SInspectNames\\\"] -Split \\\"`n\\\" | % {$_.Trim()}\
    \
    if ($OctopusParameters[\\\"K8SInspectNames\\\"] -match '\\\\*' )\
    {\
        return Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", $OctopusParameters[\\\"K8SInspectResource\\\"])) |\
            # Select the stdout property from the execution\
            Select-Object -ExpandProperty stdout |\
            # Convert the output from JSON\
            ConvertFrom-JSON | \
            # Get the items object from the kubectl response\
            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\
            # Extract the name\
            % {$_.metadata.name} |\
            # Find any matching resources\
            ? {$k8sName = $_; ($names | ? {$k8sName -like $_}).Count -ne 0}\
    }\
    else\
    {\
        return $names\
    }\
}\
\
<#\
.Description\
Get the kubectl arguments for a given action\
#>\
function Get-KubectlVerb() \
{\
    switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\
    {\
        \\\"get json\\\" {return ,@(\\\"-o\\\", \\\"json\\\", \\\"get\\\")}\
        \\\"get yaml\\\" {return ,@(\\\"-o\\\", \\\"yaml\\\", \\\"get\\\")}\
        \\\"describe\\\" {return ,@(\\\"describe\\\")}\
        \\\"logs\\\" {return ,@(\\\"logs\\\")}\
        \\\"logs tail\\\" {return ,@(\\\"logs\\\", \\\"--tail\\\", \\\"100\\\")}\
        \\\"previous logs\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\")}\
        \\\"previous logs tail\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\", \\\"--tail\\\", \\\"100\\\")}\
        default {return ,@(\\\"get\\\")}\
    }\
}\
\
<#\
.Description\
Get an appropiate file extension based on the selected action\
#>\
function Get-ArtifactExtension() \
{\
   switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\
    {\
        \\\"get json\\\" {\\\"json\\\"}\
        \\\"get yaml\\\" {\\\"yaml\\\"}\
        default {\\\"txt\\\"}\
    }\
}\
\
if ($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"] -like \\\"*logs*\\\") \
{\
    if ( -not @($OctopusParameters[\\\"K8SInspectResource\\\"]) -like \\\"pod*\\\")\
    {\
        Write-Error \\\"Logs can only be returned for pods, not $($OctopusParameters[\\\"K8SInspectResource\\\"])\\\"\
    }\
    else\
    {\
        Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", \\\"pods\\\") + (Get-Resources)) |\
            # Select the stdout property from the execution\
            Select-Object -ExpandProperty stdout |\
            # Convert the output from JSON\
            ConvertFrom-JSON | \
            # Get the items object from the kubectl response\
            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\
            # Get the pod logs for each container\
            % {\
                $podDetails = $_\
                @{\
                    logs=$podDetails.spec.containers | % {$logs=\\\"\\\"} {$logs += (Select-Object -InputObject (Execute-Command kubectl ((Get-KubectlVerb) + @($podDetails.metadata.name, \\\"-c\\\", $_.name))) -ExpandProperty stdout)} {$logs}; \
                    name=$podDetails.metadata.name\
                }                \
            } |\
            # Write the output\
            % {Write-Host $_.logs; $_} |\
            # Optionally capture the artifact\
            % {\
                if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \
                {\
                    Set-Content -Path \\\"$($_.name).$(Get-ArtifactExtension)\\\" -Value $_.logs\
                    New-OctopusArtifact \\\"$($_.name).$(Get-ArtifactExtension)\\\"\
                }\
            }\
    }      \
}\
else\
{\
    Execute-Command kubectl ((Get-KubectlVerb) + @($OctopusParameters[\\\"K8SInspectResource\\\"]) + (Get-Resources)) |\
        % {Select-Object -InputObject $_ -ExpandProperty stdout} |\
        % {Write-Host $_; $_} |\
        % {\
            if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \
            {\
                Set-Content -Path \\\"output.$(Get-ArtifactExtension)\\\" -Value $_\
                New-OctopusArtifact \\\"output.$(Get-ArtifactExtension)\\\"\
            }\
        }\
}\
\"
        \"Octopus.Action.Script.ScriptSource\"            = \"Inline\"
        \"K8SInspectResource\"                            = \"pod\"
        \"Octopus.Action.Script.Syntax\"                  = \"PowerShell\"
        \"Octopus.Action.KubernetesContainers.Namespace\" = \"#{if K8SInspectNamespace}#{K8SInspectNamespace}#{/if}#{unless K8SInspectNamespace}#{Octopus.Action.Kubernetes.Namespace}#{/unless}\"
        \"K8SInspectNames\"                               = \"#{Kubernetes.Deployment.Name}*\"
        \"K8SInspectKubectlVerb\"                         = \"get\"
      }
      container {
        feed_id = local.docker_hub_feed_id
        image   = \"octopuslabs/k8s-workertools\"
      }
      environments = [
        local.development_environment_id,
        local.test_environment_id,
        local.production_environment_id,
      ]
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = [\"EKS_Reference_Cluster\"]
  }

  step {
    condition           = \"Always\"
    name                = \"Feedback\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.Script\"
      name                               = \"Feedback\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"Octopus.Action.RunOnServer\"         = \"true\"
        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"
        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"
        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"
      }
      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = []
  }
}

resource \"octopusdeploy_runbook\" \"runbook_octopub_audits_describe_pods\" {
  count             = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0
  name              = \"🛠️ Describe Pods\"
  project_id        = octopusdeploy_project.project_octopub_audits[0].id
  environment_scope = \"Specified\"
  environments      = [
    local.development_environment_id,
    local.test_environment_id,
    local.production_environment_id,
  ]
  force_package_download      = false
  default_guided_failure_mode = \"Off\"
  description                 = <<EOT
**Action**: Returns the pods.

**Affects**: Nothing - this runbook makes no changes.
EOT
  multi_tenancy_mode          = \"Untenanted\"

  retention_policy {
    quantity_to_keep    = 100
    should_keep_forever = false
  }

  connectivity_policy {
    allow_deployments_to_no_targets = true
    exclude_unhealthy_targets       = false
    skip_machine_behavior           = \"None\"
  }
}

resource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_audits_describe_pods\" {
  count      = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0
  runbook_id = octopusdeploy_runbook.runbook_octopub_audits_describe_pods[0].id

  step {
    condition           = \"Success\"
    name                = \"Describe Pods\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.KubernetesRunScript\"
      name                               = \"Describe Pods\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      worker_pool_variable               = \"\"
      properties                         = {
        \"K8SInspectCreateArtifact\"                      = \"False\"
        \"Octopus.Action.Script.ScriptBody\"              = \"<#\
    This script provides a general purpose method for querying Kubernetes resources. It supports common operations\
    like get, describe, logs and output formats like yaml and json. Output can be captured as artifacts.\
#>\
\
<#\
.Description\
Execute an application, capturing the output. Based on https://stackoverflow.com/a/33652732/157605\
#>\
Function Execute-Command ($commandPath, $commandArguments)\
{\
  Write-Host \\\"Executing: $commandPath $($commandArguments -join \\\" \\\")\\\"\
  \
  Try {\
    $pinfo = New-Object System.Diagnostics.ProcessStartInfo\
    $pinfo.FileName = $commandPath\
    $pinfo.RedirectStandardError = $true\
    $pinfo.RedirectStandardOutput = $true\
    $pinfo.UseShellExecute = $false\
    $pinfo.Arguments = $commandArguments\
    $p = New-Object System.Diagnostics.Process\
    $p.StartInfo = $pinfo\
    $p.Start() | Out-Null\
    [pscustomobject]@{\
        stdout = $p.StandardOutput.ReadToEnd()\
        stderr = $p.StandardError.ReadToEnd()\
        ExitCode = $p.ExitCode\
    }\
    $p.WaitForExit()\
  }\
  Catch {\
     exit\
  }\
}\
\
<#\
.Description\
Find any resource names that match a wildcard input if one was specified\
#>\
function Get-Resources() \
{\
    $names = $OctopusParameters[\\\"K8SInspectNames\\\"] -Split \\\"`n\\\" | % {$_.Trim()}\
    \
    if ($OctopusParameters[\\\"K8SInspectNames\\\"] -match '\\\\*' )\
    {\
        return Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", $OctopusParameters[\\\"K8SInspectResource\\\"])) |\
            # Select the stdout property from the execution\
            Select-Object -ExpandProperty stdout |\
            # Convert the output from JSON\
            ConvertFrom-JSON | \
            # Get the items object from the kubectl response\
            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\
            # Extract the name\
            % {$_.metadata.name} |\
            # Find any matching resources\
            ? {$k8sName = $_; ($names | ? {$k8sName -like $_}).Count -ne 0}\
    }\
    else\
    {\
        return $names\
    }\
}\
\
<#\
.Description\
Get the kubectl arguments for a given action\
#>\
function Get-KubectlVerb() \
{\
    switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\
    {\
        \\\"get json\\\" {return ,@(\\\"-o\\\", \\\"json\\\", \\\"get\\\")}\
        \\\"get yaml\\\" {return ,@(\\\"-o\\\", \\\"yaml\\\", \\\"get\\\")}\
        \\\"describe\\\" {return ,@(\\\"describe\\\")}\
        \\\"logs\\\" {return ,@(\\\"logs\\\")}\
        \\\"logs tail\\\" {return ,@(\\\"logs\\\", \\\"--tail\\\", \\\"100\\\")}\
        \\\"previous logs\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\")}\
        \\\"previous logs tail\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\", \\\"--tail\\\", \\\"100\\\")}\
        default {return ,@(\\\"get\\\")}\
    }\
}\
\
<#\
.Description\
Get an appropiate file extension based on the selected action\
#>\
function Get-ArtifactExtension() \
{\
   switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\
    {\
        \\\"get json\\\" {\\\"json\\\"}\
        \\\"get yaml\\\" {\\\"yaml\\\"}\
        default {\\\"txt\\\"}\
    }\
}\
\
if ($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"] -like \\\"*logs*\\\") \
{\
    if ( -not @($OctopusParameters[\\\"K8SInspectResource\\\"]) -like \\\"pod*\\\")\
    {\
        Write-Error \\\"Logs can only be returned for pods, not $($OctopusParameters[\\\"K8SInspectResource\\\"])\\\"\
    }\
    else\
    {\
        Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", \\\"pods\\\") + (Get-Resources)) |\
            # Select the stdout property from the execution\
            Select-Object -ExpandProperty stdout |\
            # Convert the output from JSON\
            ConvertFrom-JSON | \
            # Get the items object from the kubectl response\
            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\
            # Get the pod logs for each container\
            % {\
                $podDetails = $_\
                @{\
                    logs=$podDetails.spec.containers | % {$logs=\\\"\\\"} {$logs += (Select-Object -InputObject (Execute-Command kubectl ((Get-KubectlVerb) + @($podDetails.metadata.name, \\\"-c\\\", $_.name))) -ExpandProperty stdout)} {$logs}; \
                    name=$podDetails.metadata.name\
                }                \
            } |\
            # Write the output\
            % {Write-Host $_.logs; $_} |\
            # Optionally capture the artifact\
            % {\
                if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \
                {\
                    Set-Content -Path \\\"$($_.name).$(Get-ArtifactExtension)\\\" -Value $_.logs\
                    New-OctopusArtifact \\\"$($_.name).$(Get-ArtifactExtension)\\\"\
                }\
            }\
    }      \
}\
else\
{\
    Execute-Command kubectl ((Get-KubectlVerb) + @($OctopusParameters[\\\"K8SInspectResource\\\"]) + (Get-Resources)) |\
        % {Select-Object -InputObject $_ -ExpandProperty stdout} |\
        % {Write-Host $_; $_} |\
        % {\
            if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \
            {\
                Set-Content -Path \\\"output.$(Get-ArtifactExtension)\\\" -Value $_\
                New-OctopusArtifact \\\"output.$(Get-ArtifactExtension)\\\"\
            }\
        }\
}\
\"
        \"Octopus.Action.Script.ScriptSource\"            = \"Inline\"
        \"K8SInspectResource\"                            = \"pod\"
        \"Octopus.Action.Script.Syntax\"                  = \"PowerShell\"
        \"Octopus.Action.KubernetesContainers.Namespace\" = \"#{if K8SInspectNamespace}#{K8SInspectNamespace}#{/if}#{unless K8SInspectNamespace}#{Octopus.Action.Kubernetes.Namespace}#{/unless}\"
        \"K8SInspectNames\"                               = \"#{Kubernetes.Deployment.Name}*\"
        \"K8SInspectKubectlVerb\"                         = \"describe\"
      }
      container {
        feed_id = local.docker_hub_feed_id
        image   = \"octopuslabs/k8s-workertools\"
      }
      environments = [
        local.development_environment_id,
        local.test_environment_id,
        local.production_environment_id,
      ]
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = [\"EKS_Reference_Cluster\"]
  }

  step {
    condition           = \"Always\"
    name                = \"Feedback\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.Script\"
      name                               = \"Feedback\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"Octopus.Action.RunOnServer\"         = \"true\"
        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"
        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"
        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"
      }
      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = []
  }
}

resource \"octopusdeploy_runbook\" \"runbook_octopub_audits_get_ingress\" {
  count             = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0
  name              = \"🛠️ Get Ingress\"
  project_id        = octopusdeploy_project.project_octopub_audits[0].id
  environment_scope = \"Specified\"
  environments      = [
    local.development_environment_id,
    local.test_environment_id,
    local.production_environment_id,
  ]
  force_package_download      = false
  default_guided_failure_mode = \"Off\"
  description                 = <<EOT
**Action**: Returns the ingresses.

**Affects**: Nothing - this runbook makes no changes.

**Resolves**: Finding the public IP to access the deployed application.
EOT
  multi_tenancy_mode          = \"Untenanted\"

  retention_policy {
    quantity_to_keep    = 100
    should_keep_forever = false
  }

  connectivity_policy {
    allow_deployments_to_no_targets = true
    exclude_unhealthy_targets       = false
    skip_machine_behavior           = \"None\"
  }
}

resource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_audits_get_ingress\" {
  count      = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0
  runbook_id = octopusdeploy_runbook.runbook_octopub_audits_get_ingress[0].id

  step {
    condition           = \"Success\"
    name                = \"Get Ingress\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.KubernetesRunScript\"
      name                               = \"Get Ingress\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      worker_pool_variable               = \"\"
      properties                         = {
        \"K8SInspectCreateArtifact\"                      = \"False\"
        \"Octopus.Action.Script.ScriptBody\"              = \"<#\
    This script provides a general purpose method for querying Kubernetes resources. It supports common operations\
    like get, describe, logs and output formats like yaml and json. Output can be captured as artifacts.\
#>\
\
<#\
.Description\
Execute an application, capturing the output. Based on https://stackoverflow.com/a/33652732/157605\
#>\
Function Execute-Command ($commandPath, $commandArguments)\
{\
  Write-Host \\\"Executing: $commandPath $($commandArguments -join \\\" \\\")\\\"\
  \
  Try {\
    $pinfo = New-Object System.Diagnostics.ProcessStartInfo\
    $pinfo.FileName = $commandPath\
    $pinfo.RedirectStandardError = $true\
    $pinfo.RedirectStandardOutput = $true\
    $pinfo.UseShellExecute = $false\
    $pinfo.Arguments = $commandArguments\
    $p = New-Object System.Diagnostics.Process\
    $p.StartInfo = $pinfo\
    $p.Start() | Out-Null\
    [pscustomobject]@{\
        stdout = $p.StandardOutput.ReadToEnd()\
        stderr = $p.StandardError.ReadToEnd()\
        ExitCode = $p.ExitCode\
    }\
    $p.WaitForExit()\
  }\
  Catch {\
     exit\
  }\
}\
\
<#\
.Description\
Find any resource names that match a wildcard input if one was specified\
#>\
function Get-Resources() \
{\
    $names = $OctopusParameters[\\\"K8SInspectNames\\\"] -Split \\\"`n\\\" | % {$_.Trim()}\
    \
    if ($OctopusParameters[\\\"K8SInspectNames\\\"] -match '\\\\*' )\
    {\
        return Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", $OctopusParameters[\\\"K8SInspectResource\\\"])) |\
            # Select the stdout property from the execution\
            Select-Object -ExpandProperty stdout |\
            # Convert the output from JSON\
            ConvertFrom-JSON | \
            # Get the items object from the kubectl response\
            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\
            # Extract the name\
            % {$_.metadata.name} |\
            # Find any matching resources\
            ? {$k8sName = $_; ($names | ? {$k8sName -like $_}).Count -ne 0}\
    }\
    else\
    {\
        return $names\
    }\
}\
\
<#\
.Description\
Get the kubectl arguments for a given action\
#>\
function Get-KubectlVerb() \
{\
    switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\
    {\
        \\\"get json\\\" {return ,@(\\\"-o\\\", \\\"json\\\", \\\"get\\\")}\
        \\\"get yaml\\\" {return ,@(\\\"-o\\\", \\\"yaml\\\", \\\"get\\\")}\
        \\\"describe\\\" {return ,@(\\\"describe\\\")}\
        \\\"logs\\\" {return ,@(\\\"logs\\\")}\
        \\\"logs tail\\\" {return ,@(\\\"logs\\\", \\\"--tail\\\", \\\"100\\\")}\
        \\\"previous logs\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\")}\
        \\\"previous logs tail\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\", \\\"--tail\\\", \\\"100\\\")}\
        default {return ,@(\\\"get\\\")}\
    }\
}\
\
<#\
.Description\
Get an appropiate file extension based on the selected action\
#>\
function Get-ArtifactExtension() \
{\
   switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\
    {\
        \\\"get json\\\" {\\\"json\\\"}\
        \\\"get yaml\\\" {\\\"yaml\\\"}\
        default {\\\"txt\\\"}\
    }\
}\
\
if ($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"] -like \\\"*logs*\\\") \
{\
    if ( -not @($OctopusParameters[\\\"K8SInspectResource\\\"]) -like \\\"pod*\\\")\
    {\
        Write-Error \\\"Logs can only be returned for pods, not $($OctopusParameters[\\\"K8SInspectResource\\\"])\\\"\
    }\
    else\
    {\
        Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", \\\"pods\\\") + (Get-Resources)) |\
            # Select the stdout property from the execution\
            Select-Object -ExpandProperty stdout |\
            # Convert the output from JSON\
            ConvertFrom-JSON | \
            # Get the items object from the kubectl response\
            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\
            # Get the pod logs for each container\
            % {\
                $podDetails = $_\
                @{\
                    logs=$podDetails.spec.containers | % {$logs=\\\"\\\"} {$logs += (Select-Object -InputObject (Execute-Command kubectl ((Get-KubectlVerb) + @($podDetails.metadata.name, \\\"-c\\\", $_.name))) -ExpandProperty stdout)} {$logs}; \
                    name=$podDetails.metadata.name\
                }                \
            } |\
            # Write the output\
            % {Write-Host $_.logs; $_} |\
            # Optionally capture the artifact\
            % {\
                if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \
                {\
                    Set-Content -Path \\\"$($_.name).$(Get-ArtifactExtension)\\\" -Value $_.logs\
                    New-OctopusArtifact \\\"$($_.name).$(Get-ArtifactExtension)\\\"\
                }\
            }\
    }      \
}\
else\
{\
    Execute-Command kubectl ((Get-KubectlVerb) + @($OctopusParameters[\\\"K8SInspectResource\\\"]) + (Get-Resources)) |\
        % {Select-Object -InputObject $_ -ExpandProperty stdout} |\
        % {Write-Host $_; $_} |\
        % {\
            if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \
            {\
                Set-Content -Path \\\"output.$(Get-ArtifactExtension)\\\" -Value $_\
                New-OctopusArtifact \\\"output.$(Get-ArtifactExtension)\\\"\
            }\
        }\
}\
\"
        \"Octopus.Action.Script.ScriptSource\"            = \"Inline\"
        \"K8SInspectResource\"                            = \"ingress\"
        \"Octopus.Action.Script.Syntax\"                  = \"PowerShell\"
        \"Octopus.Action.KubernetesContainers.Namespace\" = \"#{if K8SInspectNamespace}#{K8SInspectNamespace}#{/if}#{unless K8SInspectNamespace}#{Octopus.Action.Kubernetes.Namespace}#{/unless}\"
        \"K8SInspectNames\"                               = \"#{Kubernetes.Ingress.Name}*\"
        \"K8SInspectKubectlVerb\"                         = \"get\"
      }
      container {
        feed_id = local.docker_hub_feed_id
        image   = \"octopuslabs/k8s-workertools\"
      }
      environments = [
        local.development_environment_id,
        local.test_environment_id,
        local.production_environment_id,
      ]
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = [\"EKS_Reference_Cluster\"]
  }

  step {
    condition           = \"Always\"
    name                = \"Feedback\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.Script\"
      name                               = \"Feedback\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"Octopus.Action.RunOnServer\"         = \"true\"
        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"
        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"
        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"
      }
      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = []
  }
}

resource \"octopusdeploy_runbook\" \"runbook_octopub_audits_get_service\" {
  count             = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0
  name              = \"🛠️ Get Service\"
  project_id        = octopusdeploy_project.project_octopub_audits[0].id
  environment_scope = \"Specified\"
  environments      = [
    local.development_environment_id,
    local.test_environment_id,
    local.production_environment_id,
  ]
  force_package_download      = false
  default_guided_failure_mode = \"Off\"
  description                 = <<EOT
**Action**: Returns the services.

**Affects**: Nothing - this runbook makes no changes.
EOT
  multi_tenancy_mode          = \"Untenanted\"

  retention_policy {
    quantity_to_keep    = 100
    should_keep_forever = false
  }

  connectivity_policy {
    allow_deployments_to_no_targets = true
    exclude_unhealthy_targets       = false
    skip_machine_behavior           = \"None\"
  }
}

resource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_audits_get_service\" {
  count      = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0
  runbook_id = octopusdeploy_runbook.runbook_octopub_audits_get_service[0].id

  step {
    condition           = \"Success\"
    name                = \"Get Service\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.KubernetesRunScript\"
      name                               = \"Get Service\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      worker_pool_variable               = \"\"
      properties                         = {
        \"K8SInspectCreateArtifact\"                      = \"False\"
        \"Octopus.Action.Script.ScriptBody\"              = \"<#\
    This script provides a general purpose method for querying Kubernetes resources. It supports common operations\
    like get, describe, logs and output formats like yaml and json. Output can be captured as artifacts.\
#>\
\
<#\
.Description\
Execute an application, capturing the output. Based on https://stackoverflow.com/a/33652732/157605\
#>\
Function Execute-Command ($commandPath, $commandArguments)\
{\
  Write-Host \\\"Executing: $commandPath $($commandArguments -join \\\" \\\")\\\"\
  \
  Try {\
    $pinfo = New-Object System.Diagnostics.ProcessStartInfo\
    $pinfo.FileName = $commandPath\
    $pinfo.RedirectStandardError = $true\
    $pinfo.RedirectStandardOutput = $true\
    $pinfo.UseShellExecute = $false\
    $pinfo.Arguments = $commandArguments\
    $p = New-Object System.Diagnostics.Process\
    $p.StartInfo = $pinfo\
    $p.Start() | Out-Null\
    [pscustomobject]@{\
        stdout = $p.StandardOutput.ReadToEnd()\
        stderr = $p.StandardError.ReadToEnd()\
        ExitCode = $p.ExitCode\
    }\
    $p.WaitForExit()\
  }\
  Catch {\
     exit\
  }\
}\
\
<#\
.Description\
Find any resource names that match a wildcard input if one was specified\
#>\
function Get-Resources() \
{\
    $names = $OctopusParameters[\\\"K8SInspectNames\\\"] -Split \\\"`n\\\" | % {$_.Trim()}\
    \
    if ($OctopusParameters[\\\"K8SInspectNames\\\"] -match '\\\\*' )\
    {\
        return Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", $OctopusParameters[\\\"K8SInspectResource\\\"])) |\
            # Select the stdout property from the execution\
            Select-Object -ExpandProperty stdout |\
            # Convert the output from JSON\
            ConvertFrom-JSON | \
            # Get the items object from the kubectl response\
            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\
            # Extract the name\
            % {$_.metadata.name} |\
            # Find any matching resources\
            ? {$k8sName = $_; ($names | ? {$k8sName -like $_}).Count -ne 0}\
    }\
    else\
    {\
        return $names\
    }\
}\
\
<#\
.Description\
Get the kubectl arguments for a given action\
#>\
function Get-KubectlVerb() \
{\
    switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\
    {\
        \\\"get json\\\" {return ,@(\\\"-o\\\", \\\"json\\\", \\\"get\\\")}\
        \\\"get yaml\\\" {return ,@(\\\"-o\\\", \\\"yaml\\\", \\\"get\\\")}\
        \\\"describe\\\" {return ,@(\\\"describe\\\")}\
        \\\"logs\\\" {return ,@(\\\"logs\\\")}\
        \\\"logs tail\\\" {return ,@(\\\"logs\\\", \\\"--tail\\\", \\\"100\\\")}\
        \\\"previous logs\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\")}\
        \\\"previous logs tail\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\", \\\"--tail\\\", \\\"100\\\")}\
        default {return ,@(\\\"get\\\")}\
    }\
}\
\
<#\
.Description\
Get an appropiate file extension based on the selected action\
#>\
function Get-ArtifactExtension() \
{\
   switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\
    {\
        \\\"get json\\\" {\\\"json\\\"}\
        \\\"get yaml\\\" {\\\"yaml\\\"}\
        default {\\\"txt\\\"}\
    }\
}\
\
if ($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"] -like \\\"*logs*\\\") \
{\
    if ( -not @($OctopusParameters[\\\"K8SInspectResource\\\"]) -like \\\"pod*\\\")\
    {\
        Write-Error \\\"Logs can only be returned for pods, not $($OctopusParameters[\\\"K8SInspectResource\\\"])\\\"\
    }\
    else\
    {\
        Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", \\\"pods\\\") + (Get-Resources)) |\
            # Select the stdout property from the execution\
            Select-Object -ExpandProperty stdout |\
            # Convert the output from JSON\
            ConvertFrom-JSON | \
            # Get the items object from the kubectl response\
            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\
            # Get the pod logs for each container\
            % {\
                $podDetails = $_\
                @{\
                    logs=$podDetails.spec.containers | % {$logs=\\\"\\\"} {$logs += (Select-Object -InputObject (Execute-Command kubectl ((Get-KubectlVerb) + @($podDetails.metadata.name, \\\"-c\\\", $_.name))) -ExpandProperty stdout)} {$logs}; \
                    name=$podDetails.metadata.name\
                }                \
            } |\
            # Write the output\
            % {Write-Host $_.logs; $_} |\
            # Optionally capture the artifact\
            % {\
                if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \
                {\
                    Set-Content -Path \\\"$($_.name).$(Get-ArtifactExtension)\\\" -Value $_.logs\
                    New-OctopusArtifact \\\"$($_.name).$(Get-ArtifactExtension)\\\"\
                }\
            }\
    }      \
}\
else\
{\
    Execute-Command kubectl ((Get-KubectlVerb) + @($OctopusParameters[\\\"K8SInspectResource\\\"]) + (Get-Resources)) |\
        % {Select-Object -InputObject $_ -ExpandProperty stdout} |\
        % {Write-Host $_; $_} |\
        % {\
            if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \
            {\
                Set-Content -Path \\\"output.$(Get-ArtifactExtension)\\\" -Value $_\
                New-OctopusArtifact \\\"output.$(Get-ArtifactExtension)\\\"\
            }\
        }\
}\
\"
        \"Octopus.Action.Script.ScriptSource\"            = \"Inline\"
        \"K8SInspectResource\"                            = \"service\"
        \"Octopus.Action.Script.Syntax\"                  = \"PowerShell\"
        \"Octopus.Action.KubernetesContainers.Namespace\" = \"#{if K8SInspectNamespace}#{K8SInspectNamespace}#{/if}#{unless K8SInspectNamespace}#{Octopus.Action.Kubernetes.Namespace}#{/unless}\"
        \"K8SInspectNames\"                               = \"#{Kubernetes.Service.Name}*\"
        \"K8SInspectKubectlVerb\"                         = \"get\"
      }
      container {
        feed_id = local.docker_hub_feed_id
        image   = \"octopuslabs/k8s-workertools\"
      }
      environments = [
        local.development_environment_id,
        local.test_environment_id,
        local.production_environment_id,
      ]
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = [\"EKS_Reference_Cluster\"]
  }

  step {
    condition           = \"Always\"
    name                = \"Feedback\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.Script\"
      name                               = \"Feedback\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"Octopus.Action.RunOnServer\"         = \"true\"
        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"
        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"
        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"
      }
      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = []
  }
}

resource \"octopusdeploy_runbook\" \"runbook_octopub_audits_get_deployment\" {
  count             = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0
  name              = \"🛠️ Get Deployment\"
  project_id        = octopusdeploy_project.project_octopub_audits[0].id
  environment_scope = \"Specified\"
  environments      = [
    local.development_environment_id,
    local.test_environment_id,
    local.production_environment_id,
  ]
  force_package_download      = false
  default_guided_failure_mode = \"Off\"
  description                 = <<EOT
**Action**: Returns the deployments.

**Affects**: Nothing - this runbook makes no changes.
EOT
  multi_tenancy_mode          = \"Untenanted\"

  retention_policy {
    quantity_to_keep    = 100
    should_keep_forever = false
  }

  connectivity_policy {
    allow_deployments_to_no_targets = true
    exclude_unhealthy_targets       = false
    skip_machine_behavior           = \"None\"
  }
}

resource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_audits_get_deployment\" {
  count      = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0
  runbook_id = octopusdeploy_runbook.runbook_octopub_audits_get_deployment[0].id

  step {
    condition           = \"Success\"
    name                = \"Get Deployment\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.KubernetesRunScript\"
      name                               = \"Get Deployment\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      worker_pool_variable               = \"\"
      properties                         = {
        \"K8SInspectCreateArtifact\"                      = \"False\"
        \"Octopus.Action.Script.ScriptBody\"              = \"<#\
    This script provides a general purpose method for querying Kubernetes resources. It supports common operations\
    like get, describe, logs and output formats like yaml and json. Output can be captured as artifacts.\
#>\
\
<#\
.Description\
Execute an application, capturing the output. Based on https://stackoverflow.com/a/33652732/157605\
#>\
Function Execute-Command ($commandPath, $commandArguments)\
{\
  Write-Host \\\"Executing: $commandPath $($commandArguments -join \\\" \\\")\\\"\
  \
  Try {\
    $pinfo = New-Object System.Diagnostics.ProcessStartInfo\
    $pinfo.FileName = $commandPath\
    $pinfo.RedirectStandardError = $true\
    $pinfo.RedirectStandardOutput = $true\
    $pinfo.UseShellExecute = $false\
    $pinfo.Arguments = $commandArguments\
    $p = New-Object System.Diagnostics.Process\
    $p.StartInfo = $pinfo\
    $p.Start() | Out-Null\
    [pscustomobject]@{\
        stdout = $p.StandardOutput.ReadToEnd()\
        stderr = $p.StandardError.ReadToEnd()\
        ExitCode = $p.ExitCode\
    }\
    $p.WaitForExit()\
  }\
  Catch {\
     exit\
  }\
}\
\
<#\
.Description\
Find any resource names that match a wildcard input if one was specified\
#>\
function Get-Resources() \
{\
    $names = $OctopusParameters[\\\"K8SInspectNames\\\"] -Split \\\"`n\\\" | % {$_.Trim()}\
    \
    if ($OctopusParameters[\\\"K8SInspectNames\\\"] -match '\\\\*' )\
    {\
        return Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", $OctopusParameters[\\\"K8SInspectResource\\\"])) |\
            # Select the stdout property from the execution\
            Select-Object -ExpandProperty stdout |\
            # Convert the output from JSON\
            ConvertFrom-JSON | \
            # Get the items object from the kubectl response\
            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\
            # Extract the name\
            % {$_.metadata.name} |\
            # Find any matching resources\
            ? {$k8sName = $_; ($names | ? {$k8sName -like $_}).Count -ne 0}\
    }\
    else\
    {\
        return $names\
    }\
}\
\
<#\
.Description\
Get the kubectl arguments for a given action\
#>\
function Get-KubectlVerb() \
{\
    switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\
    {\
        \\\"get json\\\" {return ,@(\\\"-o\\\", \\\"json\\\", \\\"get\\\")}\
        \\\"get yaml\\\" {return ,@(\\\"-o\\\", \\\"yaml\\\", \\\"get\\\")}\
        \\\"describe\\\" {return ,@(\\\"describe\\\")}\
        \\\"logs\\\" {return ,@(\\\"logs\\\")}\
        \\\"logs tail\\\" {return ,@(\\\"logs\\\", \\\"--tail\\\", \\\"100\\\")}\
        \\\"previous logs\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\")}\
        \\\"previous logs tail\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\", \\\"--tail\\\", \\\"100\\\")}\
        default {return ,@(\\\"get\\\")}\
    }\
}\
\
<#\
.Description\
Get an appropiate file extension based on the selected action\
#>\
function Get-ArtifactExtension() \
{\
   switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\
    {\
        \\\"get json\\\" {\\\"json\\\"}\
        \\\"get yaml\\\" {\\\"yaml\\\"}\
        default {\\\"txt\\\"}\
    }\
}\
\
if ($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"] -like \\\"*logs*\\\") \
{\
    if ( -not @($OctopusParameters[\\\"K8SInspectResource\\\"]) -like \\\"pod*\\\")\
    {\
        Write-Error \\\"Logs can only be returned for pods, not $($OctopusParameters[\\\"K8SInspectResource\\\"])\\\"\
    }\
    else\
    {\
        Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", \\\"pods\\\") + (Get-Resources)) |\
            # Select the stdout property from the execution\
            Select-Object -ExpandProperty stdout |\
            # Convert the output from JSON\
            ConvertFrom-JSON | \
            # Get the items object from the kubectl response\
            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\
            # Get the pod logs for each container\
            % {\
                $podDetails = $_\
                @{\
                    logs=$podDetails.spec.containers | % {$logs=\\\"\\\"} {$logs += (Select-Object -InputObject (Execute-Command kubectl ((Get-KubectlVerb) + @($podDetails.metadata.name, \\\"-c\\\", $_.name))) -ExpandProperty stdout)} {$logs}; \
                    name=$podDetails.metadata.name\
                }                \
            } |\
            # Write the output\
            % {Write-Host $_.logs; $_} |\
            # Optionally capture the artifact\
            % {\
                if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \
                {\
                    Set-Content -Path \\\"$($_.name).$(Get-ArtifactExtension)\\\" -Value $_.logs\
                    New-OctopusArtifact \\\"$($_.name).$(Get-ArtifactExtension)\\\"\
                }\
            }\
    }      \
}\
else\
{\
    Execute-Command kubectl ((Get-KubectlVerb) + @($OctopusParameters[\\\"K8SInspectResource\\\"]) + (Get-Resources)) |\
        % {Select-Object -InputObject $_ -ExpandProperty stdout} |\
        % {Write-Host $_; $_} |\
        % {\
            if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \
            {\
                Set-Content -Path \\\"output.$(Get-ArtifactExtension)\\\" -Value $_\
                New-OctopusArtifact \\\"output.$(Get-ArtifactExtension)\\\"\
            }\
        }\
}\
\"
        \"Octopus.Action.Script.ScriptSource\"            = \"Inline\"
        \"K8SInspectResource\"                            = \"deployment\"
        \"Octopus.Action.Script.Syntax\"                  = \"PowerShell\"
        \"Octopus.Action.KubernetesContainers.Namespace\" = \"#{if K8SInspectNamespace}#{K8SInspectNamespace}#{/if}#{unless K8SInspectNamespace}#{Octopus.Action.Kubernetes.Namespace}#{/unless}\"
        \"K8SInspectNames\"                               = \"#{Kubernetes.Deployment.Name}*\"
        \"K8SInspectKubectlVerb\"                         = \"get\"
      }
      container {
        feed_id = local.docker_hub_feed_id
        image   = \"octopuslabs/k8s-workertools\"
      }
      environments = [
        local.development_environment_id,
        local.test_environment_id,
        local.production_environment_id,
      ]
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = [\"EKS_Reference_Cluster\"]
  }

  step {
    condition           = \"Always\"
    name                = \"Feedback\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.Script\"
      name                               = \"Feedback\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"Octopus.Action.RunOnServer\"         = \"true\"
        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"
        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"
        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"
      }
      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = []
  }
}

resource \"octopusdeploy_runbook\" \"runbook_octopub_audits_scale_to_zero\" {
  count             = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0
  name              = \"🌃 Scale Pods to Zero\"
  project_id        = octopusdeploy_project.project_octopub_audits[0].id
  environment_scope = \"Specified\"
  environments      = [
    local.development_environment_id,
    local.test_environment_id,
    local.production_environment_id,
  ]
  force_package_download      = false
  default_guided_failure_mode = \"Off\"
  description                 = <<EOT
**WARNING**: This is a destructive operation. The service will no longer be available when scaled down.

**Action**: Scales the deployment down to zero pods.

**Affects**: The audits service is effectively shut down.

This runbook is designed to be be run in non-production environments after hours to remove the Fargate nodes hosting
the service. This removes the cost of hosting the service out of hours.
EOT
  multi_tenancy_mode          = \"Untenanted\"

  retention_policy {
    quantity_to_keep    = 100
    should_keep_forever = false
  }

  connectivity_policy {
    allow_deployments_to_no_targets = true
    exclude_unhealthy_targets       = false
    skip_machine_behavior           = \"None\"
  }
}

resource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_audits_scale_pods_to_zero\" {
  count      = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0
  runbook_id = octopusdeploy_runbook.runbook_octopub_audits_scale_to_zero[0].id

  step {
    condition           = \"Success\"
    name                = \"Scale Pods to Zero\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.KubernetesRunScript\"
      name                               = \"Scale Pods to Zero\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = true
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      worker_pool_variable               = \"\"
      properties                         = {
        \"OctopusUseBundledTooling\"           = \"False\"
        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"
        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"
        \"Octopus.Action.Script.ScriptBody\"   = \"kubectl scale --replicas=0 deployment/#{Kubernetes.Deployment.Name}\"
        \"Octopus.Action.RunOnServer\"         = \"true\"
      }

      container {
        feed_id = local.docker_hub_feed_id
        image   = \"octopuslabs/k8s-workertools\"
      }

      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = [\"EKS_Reference_Cluster\"]
  }

  step {
    condition           = \"Always\"
    name                = \"Feedback\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.Script\"
      name                               = \"Feedback\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"Octopus.Action.RunOnServer\"         = \"true\"
        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"
        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"
        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"
      }
      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = []
  }
}

resource \"octopusdeploy_runbook\" \"runbook_octopub_audits_scale_to_one\" {
  count             = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0
  name              = \"🌇 Scale Pods to One\"
  project_id        = octopusdeploy_project.project_octopub_audits[0].id
  environment_scope = \"Specified\"
  environments      = [
    local.development_environment_id,
    local.test_environment_id,
    local.production_environment_id,
  ]
  force_package_download      = false
  default_guided_failure_mode = \"Off\"
  description                 = <<EOT
**Action**: Scales the deployment to one pod.

**Affects**: Audits service - this will create new pods if the deployment has been scaled to zero.

This runbook is designed to be be run in non-production environments during office hours to recreate the pods after they
were shutdown after hours.
EOT
  multi_tenancy_mode          = \"Untenanted\"

  retention_policy {
    quantity_to_keep    = 100
    should_keep_forever = false
  }

  connectivity_policy {
    allow_deployments_to_no_targets = true
    exclude_unhealthy_targets       = false
    skip_machine_behavior           = \"None\"
  }
}

resource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_audits_scale_pods_to_one\" {
  count      = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0
  runbook_id = octopusdeploy_runbook.runbook_octopub_audits_scale_to_one[0].id

  step {
    condition           = \"Success\"
    name                = \"Scale Pods to One\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.KubernetesRunScript\"
      name                               = \"Scale Pods to One\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = true
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      worker_pool_variable               = \"\"
      properties                         = {
        \"OctopusUseBundledTooling\"           = \"False\"
        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"
        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"
        \"Octopus.Action.Script.ScriptBody\"   = \"kubectl scale --replicas=1 deployment/#{Kubernetes.Deployment.Name}\"
        \"Octopus.Action.RunOnServer\"         = \"true\"
      }

      container {
        feed_id = local.docker_hub_feed_id
        image   = \"octopuslabs/k8s-workertools\"
      }

      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = [\"EKS_Reference_Cluster\"]
  }

  step {
    condition           = \"Always\"
    name                = \"Feedback\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.Script\"
      name                               = \"Feedback\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"Octopus.Action.RunOnServer\"         = \"true\"
        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"
        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"
        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"
      }
      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = []
  }
}

data \"octopusdeploy_projects\" \"octopub_stack\" {
  partial_name = \"_ Deploy EKS Octopub Stack\"
  skip         = 0
  take         = 1
}

resource \"octopusdeploy_variable\" \"stack_namespace_featurebranch\" {
  count        = length(data.octopusdeploy_projects.octopub_stack.projects) == 0 ? 1 : 0
  owner_id     = octopusdeploy_project.project___deploy_eks_octopub_stack[0].id
  value        = \"\"
  name         = \"Kubernetes.Namespace\"
  type         = \"String\"
  description  = \"The custom namespace to use when deploying a feature branch\"
  is_sensitive = false

  scope {
    actions      = []
    channels     = []
    environments = [local.featurebranch_environment_id]
    machines     = []
    roles        = null
    tenant_tags  = null
  }

  prompt {
    description = \"Feature branch namespace\"
    label       = \"Namespace\"
    is_required = true
    display_settings {
      control_type = \"SingleLineText\"
    }
  }
}

resource \"octopusdeploy_channel\" \"orchestration_channel_mainline\" {
  count       = length(data.octopusdeploy_projects.octopub_stack.projects) == 0 ? 1 : 0
  name        = \"Mainline\"
  description = \"\"
  project_id  = octopusdeploy_project.project___deploy_eks_octopub_stack[0].id
  is_default  = true

  rule {

    action_package {
      deployment_action = \"Deploy Frontend\"
    }
    action_package {
      deployment_action = \"Deploy Audits\"
    }
    action_package {
      deployment_action = \"Deploy Products\"
    }

    tag           = \"^$\"
    version_range = \"\"
  }

  tenant_tags = []
  depends_on  = [octopusdeploy_deployment_process.deployment_process___deploy_eks_octopub_stack]
}

resource \"octopusdeploy_project\" \"project___deploy_eks_octopub_stack\" {
  count                                = length(data.octopusdeploy_projects.octopub_stack.projects) == 0 ? 1 : 0
  name                                 = \"_ Deploy EKS Octopub Stack\"
  auto_create_release                  = false
  default_guided_failure_mode          = \"EnvironmentDefault\"
  default_to_skip_if_already_installed = false
  discrete_channel_release             = false
  is_disabled                          = false
  is_version_controlled                = false
  lifecycle_id                         = local.application_lifecycle_id
  project_group_id                     = local.eks_project_group_id
  included_library_variable_sets       = []
  tenanted_deployment_participation    = \"Untenanted\"

  connectivity_policy {
    allow_deployments_to_no_targets = true
    exclude_unhealthy_targets       = false
    skip_machine_behavior           = \"None\"
  }

  versioning_strategy {
    template = \"#{Octopus.Version.LastMajor}.#{Octopus.Version.LastMinor}.#{Octopus.Version.NextPatch}\"
  }

  lifecycle {
    ignore_changes = []
  }
  description = \"Deploys the full Octopus application stack\"
}

resource \"octopusdeploy_deployment_process\" \"deployment_process___deploy_eks_octopub_stack\" {
  count      = length(data.octopusdeploy_projects.octopub_stack.projects) == 0 ? 1 : 0
  project_id = octopusdeploy_project.project___deploy_eks_octopub_stack[0].id

  step {
    condition           = \"Success\"
    name                = \"Generate Variables\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.Script\"
      name                               = \"Generate Variables\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"Octopus.Action.RunOnServer\"         = \"true\"
        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"
        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"
        \"Octopus.Action.Script.ScriptBody\"   = local.orchestration_project_script
      }
      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = []
  }

  step {
    condition           = \"Success\"
    name                = \"Deploy Frontend\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.DeployRelease\"
      name                               = \"Deploy Frontend\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = true
      is_required                        = false
      worker_pool_id                     = \"\"
      worker_pool_variable               = \"\"
      properties                         = {
        \"Octopus.Action.DeployRelease.ProjectId\"           = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? octopusdeploy_project.project_octopub_frontend[0].id : data.octopusdeploy_projects.octopub_frontend.projects[0].id
        \"Octopus.Action.DeployRelease.DeploymentCondition\" = \"#{Octopus.Action[Generate Variables].Output.DeploymentCondition}\"
        \"Octopus.Action.DeployRelease.Variables\"           = jsonencode({
          \"Kubernetes.Namespace\" = \"#{Octopus.Action[Generate Variables].Output.KubernetesNamespaceValue}\"
        })
      }
      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []

      primary_package {
        package_id           = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? octopusdeploy_project.project_octopub_frontend[0].id : data.octopusdeploy_projects.octopub_frontend.projects[0].id
        acquisition_location = \"NotAcquired\"
        feed_id              = data.octopusdeploy_feeds.project.feeds[0].id
        properties           = {}
      }
    }

    properties   = {}
    target_roles = []
  }
  step {
    condition           = \"Success\"
    name                = \"Deploy Products\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.DeployRelease\"
      name                               = \"Deploy Products\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = true
      is_required                        = false
      worker_pool_id                     = \"\"
      worker_pool_variable               = \"\"
      properties                         = {
        \"Octopus.Action.DeployRelease.ProjectId\"           = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? octopusdeploy_project.project_octopub_products[0].id : data.octopusdeploy_projects.octopub_products.projects[0].id
        \"Octopus.Action.DeployRelease.DeploymentCondition\" = \"#{Octopus.Action[Generate Variables].Output.DeploymentCondition}\"
        \"Octopus.Action.DeployRelease.Variables\"           = jsonencode({
          \"Kubernetes.Namespace\" = \"#{Octopus.Action[Generate Variables].Output.KubernetesNamespaceValue}\"
        })
      }
      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []

      primary_package {
        package_id           = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? octopusdeploy_project.project_octopub_products[0].id : data.octopusdeploy_projects.octopub_products.projects[0].id
        acquisition_location = \"NotAcquired\"
        feed_id              = data.octopusdeploy_feeds.project.feeds[0].id
        properties           = {}
      }
    }

    properties   = {}
    target_roles = []
  }
  step {
    condition           = \"Success\"
    name                = \"Deploy Audits\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.DeployRelease\"
      name                               = \"Deploy Audits\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = true
      is_required                        = false
      worker_pool_id                     = \"\"
      worker_pool_variable               = \"\"
      properties                         = {
        \"Octopus.Action.DeployRelease.ProjectId\"           = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? octopusdeploy_project.project_octopub_audits[0].id : data.octopusdeploy_projects.octopub_audits.projects[0].id
        \"Octopus.Action.DeployRelease.DeploymentCondition\" = \"#{Octopus.Action[Generate Variables].Output.DeploymentCondition}\"
        \"Octopus.Action.DeployRelease.Variables\"           = jsonencode({
          \"Kubernetes.Namespace\" = \"#{Octopus.Action[Generate Variables].Output.KubernetesNamespaceValue}\"
        })
      }
      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []

      primary_package {
        package_id           = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? octopusdeploy_project.project_octopub_audits[0].id : data.octopusdeploy_projects.octopub_audits.projects[0].id
        acquisition_location = \"NotAcquired\"
        feed_id              = data.octopusdeploy_feeds.project.feeds[0].id
        properties           = {}
      }
    }

    properties   = {}
    target_roles = []
  }

  step {
    condition           = \"Always\"
    name                = \"Feedback\"
    package_requirement = \"LetOctopusDecide\"
    start_trigger       = \"StartAfterPrevious\"

    action {
      action_type                        = \"Octopus.Script\"
      name                               = \"Feedback\"
      condition                          = \"Success\"
      run_on_server                      = true
      is_disabled                        = false
      can_be_used_for_project_versioning = false
      is_required                        = false
      worker_pool_id                     = local.worker_pool_id
      properties                         = {
        \"Octopus.Action.RunOnServer\"         = \"true\"
        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"
        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"
        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"
      }
      environments          = []
      excluded_environments = []
      channels              = []
      tenant_tags           = []
      features              = []
    }

    properties   = {}
    target_roles = []
  }
}
#endregion

#endregion

",
    "Octopus.Action.Terraform.TemplateParameters": "{\"octopus_server\":\"#{ReferenceArchitecture.Eks.Octopus.ServerUrl}\",\"octopus_apikey\":\"#{ReferenceArchitecture.Eks.Octopus.ApiKey}\",\"octopus_space_id\":\"#{ReferenceArchitecture.Eks.Octopus.SpaceId}\",\"feed_docker_hub_username\":\"#{ReferenceArchitecture.Eks.Docker.Username}\",\"feed_docker_hub_password\":\"#{ReferenceArchitecture.Eks.Docker.Password}\",\"github_access_token\":\"#{ReferenceArchitecture.Eks.GitHub.AccessToken}\",\"account_aws_access_key\":\"#{ReferenceArchitecture.Eks.Aws.AccessKey}\",\"account_aws_secret_key\":\"#{ReferenceArchitecture.Eks.Aws.SecretKey}\"}",
    "Octopus.Action.RunOnServer": "true",
    "OctopusUseBundledTooling": "False",
    "Octopus.Action.Terraform.AdditionalInitParams": "#{if ReferenceArchitecture.Terraform.InitArgs}#{ReferenceArchitecture.Terraform.InitArgs}#{/if}",
    "Octopus.Action.Terraform.AdditionalActionParams": "#{if ReferenceArchitecture.Terraform.ApplyArgs}#{ReferenceArchitecture.Terraform.ApplyArgs}#{/if}"
  },
  "Parameters": [
    {
      "Id": "4b7395e1-97a2-4a5b-91a9-c82ac6e5c495",
      "Name": "ReferenceArchitecture.Eks.Aws.AccessKey",
      "Label": "AWS Access Key",
      "HelpText": "This is the AWS Access Key. See the [AWS docs](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_access-keys.html) for more information on creating access keys.",
      "DefaultValue": "",
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      }
    },
    {
      "Id": "bab9514f-4096-48ec-90b5-f55e42044e77",
      "Name": "ReferenceArchitecture.Eks.Aws.SecretKey",
      "Label": "AWS Secret Key",
      "HelpText": "This is the AWS Secret Key. See the [AWS docs](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_access-keys.html) for more information on creating access keys.",
      "DefaultValue": "",
      "DisplaySettings": {
        "Octopus.ControlType": "Sensitive"
      }
    },
    {
      "Id": "0c3fd236-398d-4dd9-a39a-442f877c59e8",
      "Name": "ReferenceArchitecture.Eks.Docker.Username",
      "Label": "Docker Hub Username",
      "HelpText": "The Docker Hub username. See the [Docker docs](https://docs.docker.com/docker-id/) for more information on creating a Docker Hub account.",
      "DefaultValue": "",
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      }
    },
    {
      "Id": "e865ed5a-c17d-40cd-86d1-8cfb102d5b26",
      "Name": "ReferenceArchitecture.Eks.Docker.Password",
      "Label": "Docker Hub Password",
      "HelpText": "The Docker Hub password. See the [Docker docs](https://docs.docker.com/docker-id/) for more information on creating a Docker Hub account.",
      "DefaultValue": "",
      "DisplaySettings": {
        "Octopus.ControlType": "Sensitive"
      }
    },
    {
      "Id": "2c8e5092-cb2b-4bcd-90f7-a1f969267497",
      "Name": "ReferenceArchitecture.Eks.GitHub.AccessToken",
      "Label": "GitHub Access Token",
      "HelpText": "The GitHub access token. Find more details in the [GitHub documentation](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens).


This value is used when populating GitHub repos with template projects. It can be left blank if you do not use the `Create Template Github <platform> Project` runbooks.",
      "DefaultValue": "",
      "DisplaySettings": {
        "Octopus.ControlType": "Sensitive"
      }
    },
    {
      "Id": "03759c5c-fce1-4770-8bcc-0ed3004a0d81",
      "Name": "ReferenceArchitecture.Eks.Octopus.ApiKey",
      "Label": "Octopus API Key",
      "HelpText": "The Octopus API key. See the [Octopus docs](https://octopus.com/docs/octopus-rest-api/how-to-create-an-api-key) for more details on creating an API Key.",
      "DefaultValue": "",
      "DisplaySettings": {
        "Octopus.ControlType": "Sensitive"
      }
    },
    {
      "Id": "003255fd-8bdb-4e5c-9646-5588eef5c524",
      "Name": "ReferenceArchitecture.Eks.Octopus.SpaceId",
      "Label": "Octopus Space ID",
      "HelpText": "The Octopus space ID.",
      "DefaultValue": "#{Octopus.Space.Id}",
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      }
    },
    {
      "Id": "cf35bbb0-eb2f-4dec-84bd-1cef24361d0d",
      "Name": "ReferenceArchitecture.Eks.Octopus.ServerUrl",
      "Label": "Octopus Server URL",
      "HelpText": "The Octopus server URL.",
      "DefaultValue": "#{Octopus.Web.ServerUri}",
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      }
    },
    {
      "Id": "e45078c1-d344-4315-a6f5-1295f6057d77",
      "Name": "ReferenceArchitecture.Terraform.ApplyArgs",
      "Label": "Optional Terraform Apply Args",
      "HelpText": "Optional arguments passed to the `terraform apply` command. See the [documentation](https://oc.to/wRvMoP) for details on any optional variables that can be defined here. Leave this field blank unless you have a specific reason to change it.",
      "DefaultValue": "",
      "DisplaySettings": {
        "Octopus.ControlType": "MultiLineText"
      }
    },
    {
      "Id": "d68e37c6-23d1-4224-a973-1edcfa55fa2f",
      "Name": "ReferenceArchitecture.Terraform.InitArgs",
      "Label": "Optional Terraform Init Args",
      "HelpText": "Optional arguments passed to the `terraform init` command. See the [documentation](https://oc.to/wRvMoP) for details on any optional variables that can be defined here. Leave this field blank unless you have a specific reason to change it.",
      "DefaultValue": "",
      "DisplaySettings": {
        "Octopus.ControlType": "MultiLineText"
      }
    }
  ],
  "StepPackageId": "Octopus.TerraformApply",
  "$Meta": {
    "ExportedAt": "2023-10-18T22:44:44.053Z",
    "OctopusVersion": "2023.4.6357",
    "Type": "ActionTemplate"
  },
  "LastModifiedBy": "mcasperson",
  "Category": "octopus"
}
