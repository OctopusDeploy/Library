{
  "Id": "4e3a1163-e157-4675-a60c-4dc569d14348",
  "Name": "Deploy SSRS Reports from a package",
  "Description": "Uploads SSRS reports to an SSRS server from a package.

The following Datasource properties can be overidden: ConnectionString, Username, Password, and CredentialRetrieval (valid values are: Integrated, Prompt, Store, or None).  To override the property, create a Variable using the syntax of DatasourceName.PropertyName.  For example: MyDatasource.Username 

To specify the Username and Password are Windows Credentials, create a variable called DatasourceName.WindowsCredentials and set the value to the string value 'true' (minus the quotes).",
  "ActionType": "Octopus.Script",
  "Version": 58,
  "Author": "twerthi",
  "Packages": [],
  "Properties": {
    "Octopus.Action.Script.ScriptBody": "$DeployedPath = $OctopusParameters[\"Octopus.Action[$NugetPackageStepName].Output.Package.InstallationDirectoryPath\"]
$ReleaseNumber = $OctopusParameters[\"Octopus.Release.Number\"]
$UseArchiveStructure = [Convert]::ToBoolean($OctopusParameters[\"UseArchiveStructure\"])

#region Upload-Item
Function Upload-Item 
{
    # parameters
    param ([string] $Item, [string]$ItemType, [string] $ItemFolder)

    Write-Host \"Loading data from $Item\"
    $ItemData = [System.IO.File]::ReadAllBytes($Item)

    # Create local variables
    $Warnings = $null
    $ItemName = $Item.SubString($Item.LastIndexOf(\"\\\") + 1)
    #$ItemName = $ItemName.SubString(0, $ItemName.IndexOf(\".\"))
    $ItemName = $ItemName.SubString(0, $ItemName.LastIndexOf(\".\"))
   
\t# upload item
    if ($IsReportService2005) {
        if($ItemType -eq \"Report\")
        {
\t        [void]$ReportServerProxy.CreateReport($ItemName, $ItemFolder, $true, $ItemData, $null)
        }
        else
        {
            # error
            Write-Error \"$ItemType is not supported in ReportService2005\"
        }
\t}
\telseif ($IsReportService2010) {
\t\t[void]$ReportServerProxy.CreateCatalogItem($ItemType, $ItemName, $ItemFolder, $true, $ItemData, $null, [ref] $Warnings);
\t}
\telse { Write-Warning 'Report Service Unknown in Upload-Item method. Use ReportService2005 or ReportService2010.' }
}
#endregion

#region Get-ItemDataSourceNames()
Function Get-ItemDataSourceNames
{
    # Parameters
    Param ($ItemFile, $DataSourceName)

    # declare working variables
    $DataSourceNames = @()
    
    # load the xml
    [xml]$Xml = Get-Content $ItemFile

    # retrieve the datasource nodes
    $DataSourceReferenceNodes = $Xml.GetElementsByTagName(\"DataSource\")

    # loop through returned results
    foreach($Node in $DataSourceReferenceNodes)
    {
        # check to see if we're looking for a specific one
        if($DataSourceName -ne $null)
        {
            # check to see if it's the current node
            if($DataSourceName -eq $Node.Name)
            {
                # add
                $DataSourceNames += $Node.DataSourceReference
            }
        }
        else
        {
            # store the name
            $DataSourceNames += $Node.DataSourceReference
        }
    }

    # return the results
    return ,$DataSourceNames # Apparently using the , in front of the variable is how you return explicit arrays in PowerShell ... could you be more obsure?
}
#endregion

#region Get-ItemDataSources()
Function Get-ItemDataSources
{
    # Parameters
    Param ($ItemFile)

    # declare working variables
    $DataSourceNames = @()
    
    # load the xml
    [xml]$Xml = Get-Content $ItemFile

    # retrieve the datasource nodes
    $DataSourceReferenceNodes = $Xml.GetElementsByTagName(\"DataSource\")

    # loop through returned results
    foreach($Node in $DataSourceReferenceNodes)
    {
        # store the name
        $DataSourceNames += $Node.Name
    }

    # return the results
    return ,$DataSourceNames # Apparently using the , in front of the variable is how you return explicit arrays in PowerShell ... could you be more obsure?
}
#endregion

#region Get-ItemDataSourceReferenceNames
Function Get-ItemDataSourceReferenceNames
{
    # Parameters
    Param ($ItemFile)

    # declare working variables
    $DataSourceNames = @()
    
    # load the xml
    [xml]$Xml = Get-Content $ItemFile

    # retrieve the datasource nodes
    $DataSourceReferenceNodes = $Xml.GetElementsByTagName(\"DataSourceReference\")

    # loop through returned results
    foreach($Node in $DataSourceReferenceNodes)
    {
        # get the data
        $DataSourceNames += $Node.InnerText
    }

    # return the results
    return ,$DataSourceNames # Apparently using the , in front of the variable is how you return explicit arrays in PowerShell ... could you be more obsure?
}
#endregion

#region Get-DataSetSharedReferenceName
Function Get-DataSetSharedReferenceName
{
    # parameters
    param($ReportFile, $DataSetName)

    # load the xml
    [xml]$ReportXml = Get-Content $ReportFile

    # Get the DataSet nodes
    $DataSetNode = $ReportXml.GetElementsByTagName(\"DataSet\") | Where-Object {$_.Name -eq $DataSetName}

    # return the name
    $DataSetNode.SharedDataSet.SharedDataSetReference
}
#endregion

#region Item-Exists()
Function Item-Exists($ItemFolderPath, $ItemName)
{
    # declare search condition
    $SearchCondition = New-Object \"$ReportServerProxyNamespace.SearchCondition\";

    # fill in properties
    $SearchCondition.Condition = Get-SpecificEnumValue -EnumNamespace \"$ReportServerProxyNamespace.ConditionEnum\" -EnumName \"Equals\"
    $SearchCondition.ConditionSpecified = $true
    $SearchCondition.Name = \"Name\"

\tif ($IsReportService2005) {
\t\t$SearchCondition.Value = $ItemName
\t\t# search
\t    $items = $ReportServerProxy.FindItems($ItemFolderPath, (Get-SpecificEnumValue -EnumNamespace \"$ReportServerProxyNamespace.BooleanOperatorEnum\" -EnumName \"And\"), $SearchCondition)
\t}
\telseif ($IsReportService2010) {
\t\t$SearchCondition.Values = @($ItemName)
\t\t# search
\t    $items = $ReportServerProxy.FindItems($ItemFolderPath, (Get-SpecificEnumValue -EnumNamespace \"$ReportServerProxyNamespace.BooleanOperatorEnum\" -EnumName \"And\"), $null, $SearchCondition)
\t}
\telse { Write-Warning 'Report Service Unknown in Item-Exists method. Use ReportService2005 or ReportService2010.' }    

    # check to see if anything was returned
    if($items.Length -gt 0)
    {
        # loop through returned items
        foreach($item in $items)
        {
            # check the path
            if($item.Path -eq \"$ItemFolderPath/$ItemName\")
            {
                # return true
                return $true
            }
            else
            {
                # warn
                Write-Warning \"Unexpected path for $($item.Name); path is $($item.Path) exepected $ItemFolderPath/$ItemName\"
            }
        }

        # items were found, but the path doesn't match
        
        return $false
    }
    else
    {
        return $false
    }
}
#endregion

Function Get-ItemPath
{
    # Define parameters
    param(
    $ItemName,
    $StartFolder,
    $CompareFolderPath)

    # declare search condition
    $SearchCondition = New-Object \"$ReportServerProxyNamespace.SearchCondition\";

    # fill in properties
    $SearchCondition.Condition = Get-SpecificEnumValue -EnumNamespace \"$ReportServerProxyNamespace.ConditionEnum\" -EnumName \"Equals\"
    $SearchCondition.ConditionSpecified = $true
    $SearchCondition.Name = \"Name\"

\tif ($IsReportService2005) {
\t\t$SearchCondition.Value = $ItemName
\t\t# search
\t    $items = $ReportServerProxy.FindItems($StartFolder, (Get-SpecificEnumValue -EnumNamespace \"$ReportServerProxyNamespace.BooleanOperatorEnum\" -EnumName \"And\"), $SearchCondition)
\t}
\telseif ($IsReportService2010) {
\t\t$SearchCondition.Values = @($ItemName)
\t\t# search
\t    $items = $ReportServerProxy.FindItems($StartFolder, (Get-SpecificEnumValue -EnumNamespace \"$ReportServerProxyNamespace.BooleanOperatorEnum\" -EnumName \"And\"), $null, $SearchCondition)
\t}
\telse { Write-Warning 'Report Service Unknown in Item-Exists method. Use ReportService2005 or ReportService2010.' }    

    # Check how many items were returned
    if ($items.Length -eq 1)
    {
        return $items[0].Path
    }
    else
    {
        # Loop through returned items
        foreach ($item in $items)
        {
            # compare folders
            if ($CompareFolderPath -eq ($item.Path.SubString(0, $item.Path.LastIndexOf(\"/\"))))
            {
                # Display message we're guessing
                Write-Host \"Multiple items were found with name $ItemName, assuming location is same folder as reference, $CompareFolderPath.\"
                return $item.Path
            }
        }

        # Display warning
        Write-Warning \"Multiple items were returned for $ItemName, unable to determine which one to return.\"
        return [string]::Empty
    }    
}

#region Set-ItemDataSources()
Function Set-ItemDataSources
{
    # parameters
    Param($ItemFile, $ItemFolder)

    # declare local variables
    $ItemName = $ItemFile.SubString($ItemFile.LastIndexOf(\"\\\") + 1)
    $ItemName = $ItemName.SubString(0, $ItemName.LastIndexOf(\".\"))
    $AllDataSourcesFound = $true
    
    # get the datasources
    $DataSources = $ReportServerProxy.GetItemDataSources([string]::Format(\"{0}/{1}\", $ItemFolder, $ItemName))

    #loop through retrieved datasources
    foreach($DataSource in $DataSources)
    {
        # check to see if it's a dataset
        if([System.IO.Path]::GetExtension($ItemFile).ToLower() -eq \".rsd\")
        {
            # datasets can have one and only one datasource
            # The method GetItemDataSources does not return the name of the datasource for datasets like it does for reports
            # instead, it alaways returns DataSetDataSource.  This made the call to Get-ItemDataSourceNames necessary,
            # otherwise it would not link correctly
            $DataSourceName = (Get-ItemDataSourceReferenceNames -ItemFile $ItemFile)[0]
        }
        else
        {
            # get the anme from teh source itself
            $DataSourceName = (Get-ItemDataSourceNames -ItemFile $ItemFile -DataSourceName $DataSource.Name)[0]
        }        

        if ([string]::IsNullOrWhiteSpace($DataSourceName))
        {
            Write-Host \"Datasource $($DataSource.Name) is not a shared datasource, skipping.\"
            $AllDataSourcesFound = $false
            continue
        }

        # Check to see if datasourcename contains the folder -- this can happen if the report was created by Report Builder
        if((![string]::IsNullOrEmpty($ReportDataSource)) -and ($DataSourceName.ToLower().Contains($ReportDatasourceFolder.ToLower())))
        {
            # Remove teh path from the item name
            $DataSourceName = $DataSourceName.ToLower().Replace(\"$($ReportDatasourceFolder.ToLower())/\",\"\")
        }

        $DatasourcePath = \"\"

        if ($UseArchiveStructure -eq $true)
        {
            $DatasourcePath = Get-ItemPath -ItemName $DataSourceName -StartFolder $RootFolder -CompareFolderPath $ItemFolder
            $DatasourcePath = $DatasourcePath.SubString(0, $DatasourcePath.LastIndexOf(\"/\"))
        }
        else
        {
            $DatasourcePath = $ReportDatasourceFolder
        }

        # check to make sure the datasource exists in the location specified
        if((Item-Exists -ItemFolderPath $DatasourcePath -ItemName $DataSourceName) -eq $true)
        {
            # create datasource reference variable
            $DataSourceReference = New-Object \"$ReportServerProxyNamespace.DataSourceReference\";

            # assign
            $DataSourceReference.Reference = \"$DatasourcePath/\" + $DataSourceName
            $DataSource.Item = $DataSourceReference            
        }
        else
        {
            # display warning
            Write-Warning \"Unable to find datasource $($DataSourceName) in $DatasourcePath\"

            # update to false
            $AllDataSourcesFound = $false
        }        
    }

    # check to see if found all datasources
    if($AllDataSourcesFound -eq $true)
    {
        Write-Host \"Linking datasources to $ItemFolder/$ItemName\"
        
        # save the references
        $ReportServerProxy.SetItemDataSources(\"$ItemFolder/$ItemName\", $DataSources)
    }
}
#endregion

#region Set-ReportDataSets()
Function Set-ReportDataSets
{
    # parameters
    param($ReportFile, $ReportFolderPath)

    # declare local variables
    $ReportName = $ReportFile.SubString($ReportFile.LastIndexOf(\"\\\") + 1)
    $ReportName = $ReportName.SubString(0, $ReportName.LastIndexOf(\".\"))
    $AllDataSetsFound = $true
    $DataSetFolder = \"\"

    # get the datasources
    $DataSets = $ReportServerProxy.GetItemReferences([string]::Format(\"{0}/{1}\", $ReportFolderPath, $ReportName), \"DataSet\")

    # loop through returned values
    foreach($DataSet in $DataSets)
    {
        # get the name of the shared data set reference
        $SharedDataSetReferenceName = Get-DataSetSharedReferenceName -ReportFile $ReportFile -DataSetName $DataSet.Name

        # Check to see if the SharedDataSetReferenceName contains the folder path -- this can happen if the report was built using Report Builder
        if((![string]::IsNullOrEmpty($ReportDataSetFolder)) -and ($SharedDataSetReferenceName.ToLower().Contains($ReportDataSetFolder.ToLower())))
        {
            # Remove the folder path from the name, it will cause issues when trying to set
            $SharedDataSetReferenceName = $SharedDataSetReferenceName.ToLower().Replace(\"$($ReportDataSetFolder.ToLower())/\", \"\")
        }
        
        # Check to see if we're using the archive folder structure
        if ($UseArchiveStructure -eq $true)
        {
            # Set dataset folder
            $DataSetFolder = Get-ItemPath -ItemName $SharedDataSetReferenceName -StartFolder $RootFolder -CompareFolderPath $ReportFolderPath
            $DataSetFolder = $DataSetFolder.SubString(0, $DataSetFolder.LastIndexOf(\"/\"))
        }
        else
        {
            $DataSetFolder = $ReportDataSetFolder
        }

        # check to make sure the datasource exists in the location specified
        if((Item-Exists -ItemFolderPath $DataSetFolder -ItemName $SharedDataSetReferenceName) -eq $true)
        {
            # create datasource reference variable
            $DataSetReference = New-Object \"$ReportServerProxyNamespace.ItemReference\";

            # assign
            $DataSetReference.Reference = \"$DataSetFolder/\" + $SharedDataSetReferenceName
            $DataSetReference.Name = $DataSet.Name

            # log
            Write-Host \"Linking Shared Data Set $($DataSet.Name) to $ReportName\"
            
            # update reference
            $ReportServerProxy.SetItemReferences(\"$ReportFolderPath/$ReportName\", @($DataSetReference))
        }
        else
        {
            # get the datasource name to include in warning message -- I know there must be a way to use the property in a string literal, but I wasn't able to figure it out while trying
            # to solve a reported bug so I took the easy way.
            $DataSetName = $DataSet.Name
            
            # display warning
            Write-Warning \"Unable to find dataset $DataSetName in $ReportDataSetFolder\"

            # update to false
            $AllDataSetsFound = $false
        }            
    }

    # check to see if all datsets were found
    if($AllDataSetsFound -eq $False)
    {
        Write-Warning \"Not all datasets found\"

        # save the references
        $ReportServerProxy.SetItemReferences(\"$ReportFolder/$ReportName\", @($DataSets))
    }
}

#endregion

#region Get-ObjectNamespace()
Function Get-ObjectNamespace($Object)
{
    # return the value
    ($Object).GetType().ToString().SubString(0, ($Object).GetType().ToString().LastIndexOf(\".\"))
}
#endregion

#region Get-SpecificEnumValue()
Function Get-SpecificEnumValue($EnumNamespace, $EnumName)
{
    # get the enum values
    $EnumValues = [Enum]::GetValues($EnumNamespace)

    # Loop through to find the specific value
    foreach($EnumValue in $EnumValues)
    {
        # check current
        if($EnumValue -eq $EnumName)
        {
            # return it
            return $EnumValue
        }
    }

    # nothing was found
    return $null
}
#endregion

#region Update-ReportParamters()
Function Update-ReportParameters($ReportFile, $ReportFolderPath)
{
    # declare local variables
    $ReportParameters = @();
    
    # necessary so that when attempting to use the report execution service, it doesn't puke on you when it can't find the data source
    $ReportData = (Remove-SharedReferences -ReportFile $ReportFile)

    # get just the report name
    $ReportName = $ReportFile.SubString($ReportFile.LastIndexOf(\"\\\") + 1)
    $ReportName = $ReportName.SubString(0, $ReportName.LastIndexOf(\".\"))
    
    # create warnings object
    $ReportExecutionWarnings = $null

    # set the report full path
    $ReportPath = \"$ReportFolderPath/$ReportName\" 

    # load the report definition
    $ExecutionInfo = $ReportExecutionProxy.LoadReportDefinition($ReportData, [ref] $ReportExecutionWarnings);

    # loop through the report execution parameters
    foreach($Parameter in $ExecutionInfo.Parameters)
    {
        # create new item parameter object
        $ItemParameter = New-Object \"$ReportServerProxyNamespace.ItemParameter\";

        # fill in the properties except valid values, that one needs special processing
        Copy-ObjectProperties -SourceObject $Parameter -TargetObject $ItemParameter;

        # fill in the valid values
        $ItemParameter.ValidValues = Convert-ValidValues -SourceValidValues $Parameter.ValidValues;

        # exclude if it's query based
        if($Parameter.DefaultValuesQueryBased -ne $true)
        {
            # add to list
            $ReportParameters += $ItemParameter;
        }
    }

    # force the parameters to update
    Write-Host \"Updating report parameters for $ReportFolderPath/$ReportName\"
\tif ($IsReportService2005) {
\t\t$ReportServerProxy.SetReportParameters(\"$ReportFolderPath/$ReportName\", $ReportParameters);
\t}
\telseif ($IsReportService2010) {
\t\t$ReportServerProxy.SetItemParameters(\"$ReportFolderPath/$ReportName\", $ReportParameters);
\t}
\telse { Write-Warning 'Report Service Unknown in Update-ReportParameters method. Use ReportService2005 or ReportService2010.' }
}
#endregion

#region Remove-ShareReferences()
Function Remove-SharedReferences($ReportFile)
{
    ######################################################################################################
    #You'll notice that I've used the keyword of [void] in front of some of these method calls, this is so
    #that the operation isn't captured as output of the function
    ######################################################################################################

    # read xml
    [xml]$ReportXml = Get-Content $ReportFile -Encoding UTF8;
    
    # create new memory stream object
    $MemoryStream = New-Object System.IO.MemoryStream

    try
    {

        # declare array of nodes to remove
        $NodesToRemove = @();

        # get datasource names
        $DataSourceNames = Get-ItemDataSources -ItemFile $ReportFile

        # check to see if report has datasourcenames
        if($DataSourceNames.Count -eq 0)
        {
            # Get reference to reportnode
            $ReportNode = $ReportXml.FirstChild.NextSibling # Kind of a funky way of getting it, but the SelectSingleNode(\"//Report\") wasn't working due to Namespaces in the node

            # create new DataSources node
            $DataSourcesNode = $ReportXml.CreateNode($ReportNode.NodeType, \"DataSources\", $null)

            # create new datasource node
            $DataSourceNode = $ReportXml.CreateNode($ReportNode.NodeType, \"DataSource\", $null)

            # create new datasourcereference node
            $DataSourceReferenceNode = $ReportXml.CreateNode($ReportNode.NodeType, \"DataSourceReference\", $null)

            # create new attribute
            $DataSourceNameAttribute = $ReportXml.CreateAttribute(\"Name\")
            $DataSourceNameAttribute.Value = \"DataSource1\"
            $dataSourceReferenceNode.InnerText = \"DataSource1\"

            # add attribute to datasource node
            [void]$DataSourceNode.Attributes.Append($DataSourceNameAttribute)
            [void]$DataSourceNode.AppendChild($DataSourceReferenceNode)

            # add nodes
            [void]$ReportNode.AppendChild($DataSourcesNode)
            [void]$DataSourcesNode.AppendChild($DataSourceNode)

            # add fake datasource name to array
            $DataSourceNames += \"DataSource1\"
        }

        # get all datasource nodes
        $DatasourceNodes = $ReportXml.GetElementsByTagName(\"DataSourceReference\");

        # loop through returned nodes
        foreach($DataSourceNode in $DatasourceNodes)
        {
            # create a new connection properties node
            $ConnectionProperties = $ReportXml.CreateNode($DataSourceNode.NodeType, \"ConnectionProperties\", $null);

            # create a new dataprovider node
            $DataProvider = $ReportXml.CreateNode($DataSourceNode.NodeType, \"DataProvider\", $null);
            $DataProvider.InnerText = \"SQL\";

            # create new connection string node
            $ConnectString = $ReportXml.CreateNode($DataSourceNode.NodeType, \"ConnectString\", $null);
            $ConnectString.InnerText = \"Data Source=Server Name Here;Initial Catalog=database name here\";

            # add new node to parent node
            [void] $DataSourceNode.ParentNode.AppendChild($ConnectionProperties);

            # append childeren
            [void] $ConnectionProperties.AppendChild($DataProvider);
            [void] $ConnectionProperties.AppendChild($ConnectString);

            # Add to remove list 
            $NodesToRemove += $DataSourceNode;
        }

        # get all shareddataset nodes
        $SharedDataSetNodes = $ReportXml.GetElementsByTagName(\"SharedDataSet\")

        #loop through the returned nodes
        foreach($SharedDataSetNode in $SharedDataSetNodes)
        {
            # create holder nodes so it won't error
            $QueryNode = $ReportXml.CreateNode($SharedDataSetNode.NodeType, \"Query\", $null);
            $DataSourceNameNode = $ReportXml.CreateNode($QueryNode.NodeType, \"DataSourceName\", $null);
            $CommandTextNode = $ReportXml.CreateNode($QueryNode.NodeType, \"CommandText\", $null);

            # add valid datasource name, just get the first in the list
            $DataSourceNameNode.InnerText = $DataSourceNames[0]
            
            # add node to parent
            [void] $SharedDataSetNode.ParentNode.Appendchild($QueryNode)
            
            # add datasourcename and commandtext to query node
            [void]$QueryNode.AppendChild($DataSourceNameNode)
            [void]$QueryNode.AppendChild($CommandTextNode)

            # add node to removelist
            $NodesToRemove += $SharedDataSetNode
        }


        # loop through nodes to remove
        foreach($Node in $NodesToRemove)
        {
            # remove from parent
            [void] $Node.ParentNode.RemoveChild($Node);
        }
    
        $ReportXml.InnerXml = $ReportXml.InnerXml.Replace(\"xmlns=`\"`\"\", \"\")

        # save altered xml to memory stream
        $ReportXml.Save($MemoryStream);

        # return the altered xml as byte array
        return $MemoryStream.ToArray();
    }
    finally
    {
        # close and dispose
        $MemoryStream.Close();
        $MemoryStream.Dispose();
    }
}
#endregion


#region Copy-ObjectProperties()
Function Copy-ObjectProperties($SourceObject, $TargetObject)
{
    # Get source object property array
    $SourcePropertyCollection = $SourceObject.GetType().GetProperties();

    # get the destination
    $TargetPropertyCollection = $TargetObject.GetType().GetProperties();

    # loop through source property collection
    for($i = 0; $i -lt $SourcePropertyCollection.Length; $i++)
    {
        # get the target property
        $TargetProperty = $TargetPropertyCollection | Where {$_.Name -eq $SourcePropertyCollection[$i].Name}
        
        # check to see if it's null
        if($TargetProperty -ne $null)
        {
            # check to see if it's the valid values property
            if($TargetProperty.Name -ne \"ValidValues\")
            {
                 # set the value
                $TargetProperty.SetValue($TargetObject, $SourcePropertyCollection[$i].GetValue($SourceObject));
            }
        }
    }
}
#endregion

#region ConvertValidValues()
Function Convert-ValidValues($SourceValidValues)
{
    # declare local values
    $TargetValidValues = @();
    
    # loop through source values
    foreach($SourceValidValue in $SourceValidValues)
    {
        # create target valid value object
        $TargetValidValue = New-Object \"$ReportServerProxyNamespace.ValidValue\";

        # copy properties
        Copy-ObjectProperties -SourceObject $SourceValidValue -TargetObject $TargetValidValue

        # add to list
        $TargetValidValues += $TargetValidValue
    }

    # return the values
    return ,$TargetValidValues
}
#endregion

#region Backup-ExistingItem()
Function Backup-ExistingItem
{
    # parameters
    Param($ItemFile, $ItemFolder)

    # declare local variables
    $ItemName = $ItemFile.SubString($ItemFile.LastIndexOf(\"\\\") + 1)
    $ItemName = $ItemName.SubString(0, $ItemName.LastIndexOf(\".\"))

    # check to see if the item exists
    if((Item-Exists -ItemFolderPath $ItemFolder -ItemName $ItemName) -eq $true)
    {
        # get file extension
        $FileExtension = [System.IO.Path]::GetExtension($ItemFile)
    
        # check backuplocation
        if($BackupLocation.EndsWith(\"\\\") -ne $true)
        {
            # append ending slash
            $BackupLocation = $BackupLocation + \"\\\"
        }
\t\t
\t\t# add the release number to the backup location
\t\t$BackupLocation = $BackupLocation + $ReleaseNumber + \"\\\"

        # ensure the backup location actually exists
        if((Test-Path $BackupLocation) -ne $true)
        {
            # create it
            New-Item -ItemType Directory -Path $BackupLocation
        }

        # download the item
        $Item = $ReportServerProxy.GetItemDefinition(\"$ItemFolder/$ItemName\")

        # form the backup path
        $BackupPath = \"{0}{1}{2}\" -f $BackupLocation, $ItemName, $FileExtension;

        # write to disk
        [System.IO.File]::WriteAllBytes(\"$BackupPath\", $Item);

        # write to screen
        Write-Host \"Backed up $ItemFolder/$ItemName to $BackupPath\";
    }
}
#endregion

#region Normalize-SSRSFolder()
function Normalize-SSRSFolder ([string]$Folder) {
    if (-not $Folder.StartsWith('/')) {
        $Folder = '/' + $Folder
    }
    
    return $Folder
}
#endregion

#region New-SSRSFolder()
function New-SSRSFolder ([string] $Name) {
    Write-Verbose \"New-SSRSFolder -Name $Name\"
 
    $Name = Normalize-SSRSFolder -Folder $Name
 
    if ($ReportServerProxy.GetItemType($Name) -ne 'Folder') {
        $Parts = $Name -split '/'
        $Leaf = $Parts[-1]
        $Parent = $Parts[0..($Parts.Length-2)] -join '/'
 
        if ($Parent) {
            New-SSRSFolder -Name $Parent
        } else {
            $Parent = '/'
        }
        
        $ReportServerProxy.CreateFolder($Leaf, $Parent, $null)
    }
}
#endregion

#region Clear-SSRSFolder()
function Clear-SSRSFolder ([string] $Name) {
    Write-Verbose \"Clear-SSRSFolder -Name $Name\"
    
    $Name = Normalize-SSRSFolder -Folder $Name
    
    if ($ReportServerProxy.GetItemType($Name) -eq 'Folder' -and $ClearReportFolder) {
        Write-Host (\"Clearing the {0} folder\" -f $Name)
        $ReportServerProxy.ListChildren($Name, $false) | ForEach-Object {
            Write-Verbose \"Deleting item: $($_.Path)\"
            $ReportServerProxy.DeleteItem($_.Path)
        }
    }
}
#endregion

#region New-SSRSDataSource()
function New-SSRSDataSource ([string]$RdsPath, [string]$Folder, [bool]$OverwriteDataSources) {
    Write-Verbose \"New-SSRSDataSource -RdsPath $RdsPath -Folder $Folder\"

    $Folder = Normalize-SSRSFolder -Folder $Folder
    
    [xml]$Rds = Get-Content -Path $RdsPath
    $dsName = $Rds.RptDataSource.Name
    $ConnProps = $Rds.RptDataSource.ConnectionProperties
    
\t$type = $ReportServerProxy.GetType().Namespace #Get proxy type
\t$DSDdatatype = ($type + '.DataSourceDefinition')
\t 
\t$Definition = new-object ($DSDdatatype)
\tif($Definition -eq $null){
\t Write-Error Failed to create data source definition object
\t}
\t
\t$dsConnectionString = $($OctopusParameters[\"$($dsName).ConnectionString\"])
    $dsUsername = $($OctopusParameters[\"$($dsName).Username\"])
    $dsPassword = $($OctopusParameters[\"$($dsName).Password\"])
    $dsCredentialRetrieval = $($OctopusParameters[\"$($dsName).CredentialRetrieval\"])
    
\t# replace the connection string variable that is configured in the octopus project
\tif ($dsConnectionString) {
\t    $Definition.ConnectString = $dsConnectionString
\t} else {
\t    $Definition.ConnectString = $ConnProps.ConnectString
\t}
\t
    $Definition.Extension = $ConnProps.Extension 

\t# Check to see if the credential retrieval is overridden
    if ($null -ne $dsCredentialRetrieval)
    {
    \tWrite-Host \"Forcing CredentialRetrieval property to: $dsCredentialRetrieval.\"
        $Definition.CredentialRetrieval = $dsCredentialRetrieval
    }
    else
    {
    \t# Set the Credential Retrieval method
    \tif ([Convert]::ToBoolean($ConnProps.IntegratedSecurity)) {
\t\t\t$Definition.CredentialRetrieval = 'Integrated'
\t\t}
        elseif (![string]::IsNullOrWhitespace($dsUsername) -and ![string]::IsNullOrWhitespace($dsPassword))
        {
        \t$Definition.CredentialRetrieval = 'Store'
        }
    }
       
\tif ($Definition.CredentialRetrieval -eq 'Store')
    {\t\t
\t\tWrite-Host \"$($dsName).Username = '$dsUsername'\"
\t\tWrite-Host \"$($dsName).Password = '$dsPassword'\"
\t\t
\t\t$Definition.UserName = $dsUsername;
        $Definition.Password = $dsPassword;
\t}
    
    # Check to see if this is supposed to be an Windows Authentication stored account
    if ($OctopusParameters[\"$($dsName).WindowsCredentials\"] -eq \"true\")
    {
\t    # Set the definition to Windows Credentials
    \t$Definition.WindowsCredentials = $true
    }
    

    $DataSource = New-Object -TypeName PSObject -Property @{
        Name = $Rds.RptDataSource.Name
        Path =  $Folder + '/' + $Rds.RptDataSource.Name
    }
    
    if ($OverwriteDataSources -or $ReportServerProxy.GetItemType($DataSource.Path) -eq 'Unknown') {
        Write-Host \"Overwriting datasource $($DataSource.Name)\"
        $ReportServerProxy.CreateDataSource($DataSource.Name, $Folder, $OverwriteDataSources, $Definition, $null)
    }
    
    return $DataSource 
}
#endregion

#region Main

try
{
    # declare array for reports
    $ReportFiles = @()
\t$ReportDataSourceFiles = @()
    $ReportDataSetFiles = @()
    $ReportPartFiles = @()
\t
\t$IsReportService2005 = $false
\t$IsReportService2010 = $false
\t
\tif ($ReportServiceUrl.ToLower().Contains('reportservice2005.asmx')) {
\t\t$IsReportService2005 = $true
\t\tWrite-Host \"2005 Report Service found.\"
\t}
\telseif ($ReportServiceUrl.ToLower().Contains('reportservice2010.asmx')) {
\t\t$IsReportService2010 = $true
\t\tWrite-Host \"2010 Report Service found.\"
\t}
\t
\tWrite-Host \"Deploy Path: $DeployedPath\"
\t
    # get all report files for deployment
    Write-Host \"Getting all .rdl files\"
    Get-ChildItem $DeployedPath -Recurse -Filter \"*.rdl\" | ForEach-Object { If(($ReportFiles -contains $_.FullName) -eq $false) {$ReportFiles += $_.FullName}}
    Write-Host \"# of rdl files found: $($ReportFiles.Count)\"

    # get all report datasource files for deployment
    Write-Host \"Getting all .rds files\"
    Get-ChildItem $DeployedPath -Recurse -Filter \"*.rds\" | ForEach-Object { If(($ReportDataSourceFiles -contains $_.FullName) -eq $false) {$ReportDataSourceFiles += $_.FullName}}
    Write-Host \"# of rds files found: $($ReportDataSourceFiles.Count)\"

    # get all report datset files for deployment
    Write-Host \"Getting all .rsd files\"
    Get-ChildItem $DeployedPath -Recurse -Filter \"*.rsd\" | ForEach-Object { If(($ReportDataSetFiles -contains $_.FullName) -eq $false) {$ReportDataSetFiles += $_.FullName}}
    Write-Host \"# of rsd files found: $($ReportDataSetFiles.Count)\"

    # get all report part files for deployment
    Write-Host \"Getting all .rsc files\"
    Get-ChildItem $DeployedPath -Recurse -Filter \"*.rsc\" | ForEach-Object { If(($ReportPartFiles -contains $_.FullName) -eq $false) {$ReportPartFiles += $_.FullName}}
    Write-Host \"# of rsc files found: $($ReportPartFiles.Count)\"

    # set the report proxies
    Write-Host \"Creating SSRS Web Service proxies\"

    # check to see if credentials were supplied for the services
    if(([string]::IsNullOrEmpty($ServiceUserDomain) -ne $true) -and ([string]::IsNullOrEmpty($ServiceUserName) -ne $true) -and ([string]::IsNullOrEmpty($ServicePassword) -ne $true))
    {
        # secure the password
        $secpasswd = ConvertTo-SecureString \"$ServicePassword\" -AsPlainText -Force

        # create credential object
        $ServiceCredential = New-Object System.Management.Automation.PSCredential (\"$ServiceUserDomain\\$ServiceUserName\", $secpasswd)

        # create proxies
        $ReportServerProxy = New-WebServiceProxy -Uri $ReportServiceUrl -Credential $ServiceCredential
        $ReportExecutionProxy = New-WebServiceProxy -Uri $ReportExecutionUrl -Credential $ServiceCredential
    }
    else
    {
        # create proxies using current identity
        $ReportServerProxy = New-WebServiceProxy -Uri $ReportServiceUrl -UseDefaultCredential 
        $ReportExecutionProxy = New-WebServiceProxy -Uri $ReportExecutionUrl -UseDefaultCredential 
    }



\t#Create folder information for DataSource and Report
    if ($UseArchiveStructure -eq $false)
    {
\t    New-SSRSFolder -Name $ReportFolder
\t    New-SSRSFolder -Name $ReportDatasourceFolder
        New-SSRSFolder -Name $ReportDataSetFolder
        New-SSRSFolder -Name $ReportPartsFolder
    }
    else
    {
        New-SSRSFolder -Name $RootFolder
    }
    
    #Clear destination folder if specified
    if([System.Convert]::ToBoolean(\"$ClearReportFolder\")) {
        Clear-SSRSFolder -Name $ReportFolder
    }
\t 
\t#Create DataSource
    foreach($RDSFile in $ReportDataSourceFiles) {
        Write-Host \"New-SSRSDataSource $RdsFile\"

        $DatasourceFolder = \"\"

        if ($UseArchiveStructure -eq $true)
        {
            # Adjust report folder to archive path
            $DatasourceFolder = $(if ($RootFolder -eq \"/\") { [string]::Empty} else { $RootFolder } ) + $RDSFile.Replace($DeployedPath, '').Replace('\\', '/').Replace((Split-Path $RDSFile -Leaf), '')

            # Remove final slash
            $DatasourceFolder = $DatasourceFolder.Substring(0, $DatasourceFolder.LastIndexOf('/'))    
            
            # Check if folder exists
            New-SSRSFolder -Name $DatasourceFolder                    
        }
        else
        {
            $DatasourceFolder = $ReportDatasourceFolder
        }
        
\t\t$DataSource = New-SSRSDataSource -RdsPath $RdsFile -Folder $DatasourceFolder -Overwrite ([System.Convert]::ToBoolean(\"$OverwriteDataSources\"))
\t}

    # get the service proxy namespaces - this is necessary because of a bug documented here http://stackoverflow.com/questions/7921040/error-calling-reportingservice2005-finditems-specifically-concerning-the-bool and http://www.vistax64.com/powershell/273120-bug-when-using-namespace-parameter-new-webserviceproxy.html
    $ReportServerProxyNamespace = Get-ObjectNamespace -Object $ReportServerProxy
    $ReportExecutionProxyNamespace = Get-ObjectNamespace -Object $ReportExecutionProxy

    # Create dat sets
    foreach($DataSet in $ReportDataSetFiles)
    {
        $DataSetPath = \"\"

        # Check to see if it's set to follow archive structure
        if ($UseArchiveStructure -eq $true)
        {
            # Adjust report folder to archive path
            $DataSetPath = $(if ($RootFolder -eq \"/\") { [string]::Empty} else { $RootFolder } ) + $DataSet.Replace($DeployedPath, '').Replace('\\', '/').Replace((Split-Path $DataSet -Leaf), '')

            # Remove final slash
            $DataSetPath = $DataSetPath.Substring(0, $DataSetPath.LastIndexOf('/'))

            # Check if folder exists
            New-SSRSFolder -Name $DataSetPath
        }
        else
        {
            $DataSetPath = $ReportDataSetFolder
        }

        # check to see if we need to back up
        if($BackupLocation -ne $null -and $BackupLocation -ne \"\")
        {
            # backup the item
            Backup-ExistingItem -ItemFile $DataSet -ItemFolder $DataSetPath
        }

        # upload the dataset
        Upload-Item -Item $DataSet -ItemType \"DataSet\" -ItemFolder $DataSetPath

        # update the dataset datasource
        Set-ItemDataSources -ItemFile $DataSet -ItemFolder $DataSetPath
    }

    # get the proxy auto generated name spaces

    # loop through array
    foreach($ReportFile in $ReportFiles)
    {
        $ReportPath = \"\"

        # Check to see if it's set to follow archive structure
        if ($UseArchiveStructure -eq $true)
        {
            # Adjust report folder to archive path
            $ReportPath = $(if ($RootFolder -eq \"/\") { [string]::Empty} else { $RootFolder } ) + $ReportFile.Replace($DeployedPath, '').Replace('\\', '/').Replace((Split-Path $ReportFile -Leaf), '')

            # Remove final slash
            $ReportPath = $ReportPath.Substring(0, $ReportPath.LastIndexOf('/'))

            # Check if folder exists
            New-SSRSFolder -Name $ReportPath
        }
        else
        {
            $ReportPath = $ReportFolder
        }

        # check to see if we need to back up
        if($BackupLocation -ne $null -and $BackupLocation -ne \"\")
        {
            # backup the item
            Backup-ExistingItem -ItemFile $ReportFile -ItemFolder $ReportPath
        }
        
        
        # upload report
        Upload-Item -Item $ReportFile -ItemType \"Report\" -ItemFolder $ReportPath

        # extract datasources
        #Write-Host \"Extracting datasource names for $ReportFile\"
        #$ReportDataSourceNames = Get-ReportDataSourceNames $ReportFile

        # set the datasources
        Set-ItemDataSources -ItemFile $ReportFile -ItemFolder $ReportPath

        # set the datasets
        Set-ReportDataSets -ReportFile $ReportFile -ReportFolderPath $ReportPath

        # update the report parameters
        Update-ReportParameters -ReportFile $ReportFile -ReportFolderPath $ReportPath
    }
    
    # loop through rsc files
    foreach($ReportPartFile in $ReportPartFiles)
    {
        # check to see if we need to back up
        if($BackupLocation -ne $null -and $BackupLocation -ne \"\")
        {
            # backup the item
            Backup-ExistingItem -ItemFile $ReportPartFile -ItemFolder $ReportPartsFolder
        }

\t\t# upload item
        Upload-Item -Item $ReportPartFile -ItemType \"Component\" -ItemFolder $ReportPartsFolder
    }
    
}
finally
{
    # check to see if the proxies are null
    if($ReportServerProxy -ne $null)
    {
        # dispose
        $ReportServerProxy.Dispose();
    }

    if($ReportExecutionProxy -ne $null)
    {
        # dispose
        $ReportExecutionProxy.Dispose();
    }
}

#endregion
",
    "Octopus.Action.Script.Syntax": "PowerShell",
    "Octopus.Action.Script.ScriptSource": "Inline",
    "Octopus.Action.RunOnServer": "false"
  },
  "Parameters": [
    {
      "Id": "92daa94e-73f3-466e-a8db-35149646df2b",
      "Name": "NugetPackageStepName",
      "Label": "SSRS package step",
      "HelpText": "Select the step in this project which downloads the SSRS package.",
      "DefaultValue": null,
      "DisplaySettings": {
        "Octopus.ControlType": "StepName"
      }
    },
    {
      "Id": "0bb2f003-fda9-4571-86aa-3bad13775874",
      "Name": "ReportServiceUrl",
      "Label": "Url of SSRS Server service",
      "HelpText": "The complete Url to the SSRS server.
Example: http://198.239.216.46/ReportServer_LOCALDEV/reportservice2010.asmx?wsdl",
      "DefaultValue": null,
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      }
    },
    {
      "Id": "feca8cfe-fe9e-4e8f-ac7e-b370b5ef3ef6",
      "Name": "ReportExecutionUrl",
      "Label": "Report Execution Url",
      "HelpText": "The complete Url to the Report Execution service.
Example: http://198.239.216.46/ReportServer_LOCALDEV/ReportExecution2005.asmx?wsdl",
      "DefaultValue": null,
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      }
    },
    {
      "Id": "1924b3a6-d5bf-4713-8bc7-6b77422a7944",
      "Name": "ReportFolder",
      "Label": "Report folder",
      "HelpText": "Relative Url to the folder in which the reports will be deployed.",
      "DefaultValue": null,
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      }
    },
    {
      "Id": "28cc63a0-5a3e-4d22-8406-574bdb332fe1",
      "Name": "ReportDatasourceFolder",
      "Label": "Report data source folder",
      "HelpText": "Relative Url where the data sources for the reports are located, starting with '/'",
      "DefaultValue": null,
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      }
    },
    {
      "Id": "b1cdc16e-c2db-41eb-9ae8-8df02b05f03d",
      "Name": "OverwriteDataSources",
      "Label": "Overwrite datasource(s)",
      "HelpText": "Tick if the existing report data source file needs to e replaced.",
      "DefaultValue": "False",
      "DisplaySettings": {
        "Octopus.ControlType": "Checkbox"
      }
    },
    {
      "Id": "b0e69f02-1f99-431a-852e-b0084ed23fd4",
      "Name": "BackupLocation",
      "Label": "Backup Location",
      "HelpText": "Directory path to take a backup of existing reports (.rdl) and data source (.rds) files.",
      "DefaultValue": null,
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      }
    },
    {
      "Id": "a736f0b8-aa27-45ae-b6a0-43a76e44d85a",
      "Name": "ReportDataSetFolder",
      "Label": "DataSet folder",
      "HelpText": "Relative Url where Shared Data Sets are stored",
      "DefaultValue": null,
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      }
    },
    {
      "Id": "c88b150a-9f70-4700-9981-ed1514dc5a2b",
      "Name": "ReportPartsFolder",
      "Label": "Report Parts Folder",
      "HelpText": "Relative folder where Report Parts are uploaded to.",
      "DefaultValue": null,
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      }
    },
    {
      "Id": "47575f66-9b1b-4cbb-a062-30d811e6159d",
      "Name": "ServiceUserDomain",
      "Label": "Service Domain",
      "HelpText": "(Optional - leave blank to use Tentacle identity) Name of the domain for the user account to execute as",
      "DefaultValue": null,
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      }
    },
    {
      "Id": "98b43d45-5a5a-456a-aac7-1f4cc6fe8e55",
      "Name": "ServiceUserName",
      "Label": "Service Username",
      "HelpText": "(Optional - leave blank to use Tentacle identity) Username of the user account to execute as",
      "DefaultValue": null,
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      }
    },
    {
      "Id": "fd48bde1-3874-45ea-ab99-b40c13b91d5a",
      "Name": "ServicePassword",
      "Label": "Service Password",
      "HelpText": "(Optional - leave blank to use Tentacle identity) Password of the user account to execute as",
      "DefaultValue": null,
      "DisplaySettings": {
        "Octopus.ControlType": "Sensitive"
      }
    },
    {
      "Id": "1310ffde-1f98-4ebf-bf6a-605bb83ea54e",
      "Name": "ClearReportFolder",
      "Label": "Clear the Report Folder",
      "HelpText": "Optional - This will delete all items in the Report Folder before adding items.",
      "DefaultValue": "false",
      "DisplaySettings": {
        "Octopus.ControlType": "Checkbox"
      }
    },
    {
      "Id": "9d64d192-b645-4aac-ba52-3c86aebe8d72",
      "Name": "UseArchiveStructure",
      "Label": "Use package folder structure",
      "HelpText": "Tick this box to create folders matching the package folder structure and upload items into their respective folders.  Ticking this box ignores all other folder specifications except Root folder",
      "DefaultValue": "false",
      "DisplaySettings": {
        "Octopus.ControlType": "Checkbox"
      }
    },
    {
      "Id": "ad0280e7-25a6-48cc-bc90-4e6ee3c8951b",
      "Name": "RootFolder",
      "Label": "Root folder",
      "HelpText": "Used only when 'Use package folder structure' is checked.  This specifies the root folder on SSRS to start in.  Value is relative so it begins with a /",
      "DefaultValue": null,
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      }
    }
  ],
  "LastModifiedBy": "twerthi",
  "$Meta": {
    "ExportedAt": "2021-03-11T19:19:00.102Z",
    "OctopusVersion": "2020.6.4671",
    "Type": "ActionTemplate"
  },
  "Category": "sql"
}
