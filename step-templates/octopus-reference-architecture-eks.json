{
  "Id": "87b2154a-5c8d-4c31-9680-575bb6df9789",
  "Name": "Octopus - EKS Reference Architecture",
  "Description": "This step populates an Octopus space with the environments, feeds, accounts, lifecycles, projects, and runbooks required to deploy a sample application to an AWS EKS Kubernetes cluster. These resources combine to form a reference architecture teams can use to bootstrap an Octopus space with best practices and example projects. It is recommended that you run this step with the `octopuslabs/terraform-workertools` [container image](https://octopus.com/docs/projects/steps/execution-containers-for-workers). \n\nThat this step assumes it is run on a cloud Octopus instance, or the default worker runs Linux, has Docker installed, and has PowerShell Core installed.\n\nThe step will not update existing projects, environments etc. If you wish to recreate these resource with the latest configuration, for example if this step is updated and you wish to see the latest settings, you must manually delete or rename the resources to be recreated.",
  "ActionType": "Octopus.TerraformApply",
  "Version": 5,
  "CommunityActionTemplateId": null,
  "Packages": [],
  "Properties": {
    "Octopus.Action.GoogleCloud.UseVMServiceAccount": "True",
    "Octopus.Action.GoogleCloud.ImpersonateServiceAccount": "False",
    "Octopus.Action.Terraform.GoogleCloudAccount": "False",
    "Octopus.Action.Terraform.AzureAccount": "False",
    "Octopus.Action.Terraform.ManagedAccount": "None",
    "Octopus.Action.Terraform.AllowPluginDownloads": "True",
    "Octopus.Action.Script.ScriptSource": "Inline",
    "Octopus.Action.Terraform.RunAutomaticFileSubstitution": "True",
    "Octopus.Action.Terraform.PlanJsonOutput": "False",
    "Octopus.Action.Terraform.Template": "terraform {\n  required_providers {\n    octopusdeploy = { source = \"OctopusDeployLabs/octopusdeploy\", version = \"0.12.7\" }\n  }\n}\n\n#region Locals\nlocals {\n  docker_hub_feed_id   = length(data.octopusdeploy_feeds.dockerhub.feeds) == 0 ? octopusdeploy_docker_container_registry.docker_hub[0].id : data.octopusdeploy_feeds.dockerhub.feeds[0].id\n  worker_pool_id = length(data.octopusdeploy_worker_pools.workerpool_hosted_ubuntu.worker_pools) == 0 ? \"\" : data.octopusdeploy_worker_pools.workerpool_hosted_ubuntu.worker_pools[0].id\n  security_scan_script = <<-EOT\n  echo \"Pulling Trivy Docker Image\"\n  echo \"##octopus[stdout-verbose]\"\n  docker pull aquasec/trivy\n  echo \"##octopus[stdout-default]\"\n\n  echo \"Installing umoci\"\n  echo \"##octopus[stdout-verbose]\"\n  # Install umoci\n  if ! which umoci\n  then\n    curl -o umoci -L https://github.com/opencontainers/umoci/releases/latest/download/umoci.amd64 2>&1\n    chmod +x umoci\n  fi\n  echo \"##octopus[stdout-default]\"\n\n  echo \"Extracting Application Docker Image\"\n  echo \"##octopus[stdout-verbose]\"\n  # Download and extract the docker image\n  # https://manpages.ubuntu.com/manpages/jammy/man1/umoci-raw-unpack.1.html\n  docker pull quay.io/skopeo/stable:latest 2>&1\n  docker run -v $(pwd):/output quay.io/skopeo/stable:latest copy docker://#{Octopus.Action[Deploy Container].Package[web].PackageId}:#{Octopus.Action[Deploy Container].Package[web].PackageVersion} oci:/output/image:latest 2>&1\n  ./umoci unpack --image image --rootless bundle 2>&1\n  echo \"##octopus[stdout-default]\"\n\n  TIMESTAMP=$(date +%s%3N)\n  SUCCESS=0\n  for x in $(find . -name bom.json -type f -print); do\n      echo \"Scanning $${x}\"\n\n      # Delete any existing report file\n      if [[ -f \"$PWD/depscan-bom.json\" ]]; then\n        rm \"$PWD/depscan-bom.json\"\n      fi\n\n      # Generate the report, capturing the output, and ensuring $? is set to the exit code\n      OUTPUT=$(bash -c \"docker run --rm -v \\\"$PWD:/app\\\" aquasec/trivy sbom \\\"/app/$${x}\\\"; exit \\$?\" 2>&1)\n\n      # Success is set to 1 if the exit code is not zero\n      if [[ $? -ne 0 ]]; then\n          SUCCESS=1\n      fi\n\n      # Print the output stripped of ANSI colour codes\n      echo -e \"$${OUTPUT}\" | sed 's/\\x1b\\[[0-9;]*m//g'\n  done\n\n  set_octopusvariable \"VerificationResult\" $SUCCESS\n\n  if [[ $SUCCESS -ne 0 ]]; then\n    >&2 echo \"Critical vulnerabilities were detected\"\n  fi\n\n  exit 0\n  EOT\n}\n#endregion\n\n#region Provider\nvariable \"octopus_server\" {\n  type        = string\n  nullable    = false\n  sensitive   = false\n  description = \"The URL of the Octopus server e.g. https://myinstance.octopus.app.\"\n  default     = \"#{Octopus.Web.ServerUri}\"\n}\n\nvariable \"octopus_apikey\" {\n  type        = string\n  nullable    = false\n  sensitive   = true\n  description = \"The API key used to access the Octopus server. See https://octopus.com/docs/octopus-rest-api/how-to-create-an-api-key for details on creating an API key.\"\n}\n\nvariable \"octopus_space_id\" {\n  type        = string\n  nullable    = false\n  sensitive   = false\n  description = \"The ID of the Octopus space to populate.\"\n  default     = \"#{Octopus.Space.Id}\"\n}\n\nprovider \"octopusdeploy\" {\n  address  = var.octopus_server\n  api_key  = var.octopus_apikey\n  space_id = var.octopus_space_id\n}\n#endregion\n\n#region Environments\ndata \"octopusdeploy_environments\" \"environment_development\" {\n  ids          = null\n  partial_name = \"Development\"\n  skip         = 0\n  take         = 1\n}\n\nresource \"octopusdeploy_environment\" \"environment_development\" {\n  count                        = length(data.octopusdeploy_environments.environment_development.environments) == 0 ? 1 : 0\n  name                         = \"Development\"\n  description                  = \"\"\n  allow_dynamic_infrastructure = true\n  use_guided_failure           = true\n  sort_order                   = 10\n\n  jira_extension_settings {\n    environment_type = \"development\"\n  }\n\n  jira_service_management_extension_settings {\n    is_enabled = false\n  }\n\n  servicenow_extension_settings {\n    is_enabled = false\n  }\n}\n\ndata \"octopusdeploy_environments\" \"environment_test\" {\n  ids          = null\n  partial_name = \"Test\"\n  skip         = 0\n  take         = 1\n}\n\nresource \"octopusdeploy_environment\" \"environment_test\" {\n  count                        = length(data.octopusdeploy_environments.environment_test.environments) == 0 ? 1 : 0\n  name                         = \"Test\"\n  description                  = \"\"\n  allow_dynamic_infrastructure = true\n  use_guided_failure           = true\n  sort_order                   = 11\n\n  jira_extension_settings {\n    environment_type = \"testing\"\n  }\n\n  jira_service_management_extension_settings {\n    is_enabled = false\n  }\n\n  servicenow_extension_settings {\n    is_enabled = false\n  }\n}\n\ndata \"octopusdeploy_environments\" \"environment_production\" {\n  ids          = null\n  partial_name = \"Production\"\n  skip         = 0\n  take         = 1\n}\n\nresource \"octopusdeploy_environment\" \"environment_production\" {\n  count                        = length(data.octopusdeploy_environments.environment_production.environments) == 0 ? 1 : 0\n  name                         = \"Production\"\n  description                  = \"\"\n  allow_dynamic_infrastructure = true\n  use_guided_failure           = true\n  sort_order                   = 12\n\n  jira_extension_settings {\n    environment_type = \"production\"\n  }\n\n  jira_service_management_extension_settings {\n    is_enabled = false\n  }\n\n  servicenow_extension_settings {\n    is_enabled = false\n  }\n}\n\ndata \"octopusdeploy_environments\" \"environment_security\" {\n  ids          = null\n  partial_name = \"Security\"\n  skip         = 0\n  take         = 1\n}\n\nresource \"octopusdeploy_environment\" \"environment_security\" {\n  count                        = length(data.octopusdeploy_environments.environment_security.environments) == 0 ? 1 : 0\n  name                         = \"Security\"\n  description                  = \"\"\n  allow_dynamic_infrastructure = true\n  use_guided_failure           = false\n  sort_order                   = 14\n\n  jira_extension_settings {\n    environment_type = \"production\"\n  }\n\n  jira_service_management_extension_settings {\n    is_enabled = false\n  }\n\n  servicenow_extension_settings {\n    is_enabled = false\n  }\n}\n\ndata \"octopusdeploy_environments\" \"environment_sync\" {\n  ids          = null\n  partial_name = \"Sync\"\n  skip         = 0\n  take         = 1\n}\n\nresource \"octopusdeploy_environment\" \"environment_sync\" {\n  count                        = length(data.octopusdeploy_environments.environment_sync.environments) == 0 ? 1 : 0\n  name                         = \"Sync\"\n  description                  = \"\"\n  allow_dynamic_infrastructure = true\n  use_guided_failure           = false\n  sort_order                   = 15\n\n  jira_extension_settings {\n    environment_type = \"development\"\n  }\n\n  jira_service_management_extension_settings {\n    is_enabled = false\n  }\n\n  servicenow_extension_settings {\n    is_enabled = false\n  }\n}\n\ndata \"octopusdeploy_lifecycles\" \"devsecops\" {\n  ids          = []\n  partial_name = \"DevSecOps\"\n  skip         = 0\n  take         = 1\n}\n\ndata \"octopusdeploy_lifecycles\" \"application\" {\n  ids          = []\n  partial_name = \"Application\"\n  skip         = 0\n  take         = 1\n}\n\nresource \"octopusdeploy_lifecycle\" \"lifecycle_devsecops\" {\n  count       = length(data.octopusdeploy_lifecycles.devsecops.lifecycles) == 0 ? 1 : 0\n  name        = \"DevSecOps\"\n  description = \"\"\n\n  phase {\n    automatic_deployment_targets = []\n    optional_deployment_targets  = [\n      length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id\n    ]\n    name                                  = \"Development\"\n    is_optional_phase                     = false\n    minimum_environments_before_promotion = 0\n  }\n  phase {\n    automatic_deployment_targets = []\n    optional_deployment_targets  = [\n      length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id\n    ]\n    name                                  = \"Test\"\n    is_optional_phase                     = false\n    minimum_environments_before_promotion = 0\n  }\n  phase {\n    automatic_deployment_targets = []\n    optional_deployment_targets  = [\n      length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id\n    ]\n    name                                  = \"Production\"\n    is_optional_phase                     = false\n    minimum_environments_before_promotion = 0\n  }\n  phase {\n    automatic_deployment_targets = [\n      length(data.octopusdeploy_environments.environment_security.environments) == 0 ? octopusdeploy_environment.environment_security[0].id : data.octopusdeploy_environments.environment_security.environments[0].id\n    ]\n    optional_deployment_targets           = []\n    name                                  = \"Security\"\n    is_optional_phase                     = false\n    minimum_environments_before_promotion = 0\n  }\n\n  release_retention_policy {\n    quantity_to_keep    = 3\n    should_keep_forever = false\n    unit                = \"Days\"\n  }\n\n  tentacle_retention_policy {\n    quantity_to_keep    = 3\n    should_keep_forever = false\n    unit                = \"Days\"\n  }\n}\n\nresource \"octopusdeploy_lifecycle\" \"lifecycle_application\" {\n  count       = length(data.octopusdeploy_lifecycles.application.lifecycles) == 0 ? 1 : 0\n  name        = \"Application\"\n  description = \"\"\n\n  phase {\n    automatic_deployment_targets = []\n    optional_deployment_targets  = [\n      length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id\n    ]\n    name                                  = \"Development\"\n    is_optional_phase                     = false\n    minimum_environments_before_promotion = 0\n  }\n  phase {\n    automatic_deployment_targets = []\n    optional_deployment_targets  = [\n      length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id\n    ]\n    name                                  = \"Test\"\n    is_optional_phase                     = false\n    minimum_environments_before_promotion = 0\n  }\n  phase {\n    automatic_deployment_targets = []\n    optional_deployment_targets  = [\n      length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id\n    ]\n    name                                  = \"Production\"\n    is_optional_phase                     = false\n    minimum_environments_before_promotion = 0\n  }\n\n  release_retention_policy {\n    quantity_to_keep    = 3\n    should_keep_forever = false\n    unit                = \"Days\"\n  }\n\n  tentacle_retention_policy {\n    quantity_to_keep    = 3\n    should_keep_forever = false\n    unit                = \"Days\"\n  }\n}\n#endregion\n\n#region Feeds\n\ndata \"octopusdeploy_feeds\" \"project\" {\n  feed_type = \"OctopusProject\"\n  ids       = []\n  skip      = 0\n  take      = 1\n}\n\ndata \"octopusdeploy_feeds\" \"bitnami\" {\n  feed_type    = \"Helm\"\n  ids          = []\n  partial_name = \"Bitnami\"\n  skip         = 0\n  take         = 1\n}\n\n\nresource \"octopusdeploy_helm_feed\" \"feed_helm\" {\n  count                                = length(data.octopusdeploy_feeds.bitnami.feeds) == 0 ? 1 : 0\n  name                                 = \"Bitnami\"\n  feed_uri                             = \"https://repo.vmware.com/bitnami-files/\"\n  package_acquisition_location_options = [\"ExecutionTarget\", \"NotAcquired\"]\n}\n\ndata \"octopusdeploy_feeds\" \"dockerhub\" {\n  feed_type    = \"Docker\"\n  ids          = []\n  partial_name = \"Docker Hub\"\n  skip         = 0\n  take         = 1\n}\n\nvariable \"feed_docker_hub_username\" {\n  type        = string\n  nullable    = false\n  sensitive   = true\n  description = \"The username used by the feed Docker Hub\"\n}\n\nvariable \"feed_docker_hub_password\" {\n  type        = string\n  nullable    = false\n  sensitive   = true\n  description = \"The password used by the feed Docker Hub\"\n}\n\nresource \"octopusdeploy_docker_container_registry\" \"docker_hub\" {\n  count                                = length(data.octopusdeploy_feeds.dockerhub.feeds) == 0 ? 1 : 0\n  name                                 = \"Docker Hub\"\n  password                             = var.feed_docker_hub_password\n  username                             = var.feed_docker_hub_username\n  api_version                          = \"v1\"\n  feed_uri                             = \"https://index.docker.io\"\n  package_acquisition_location_options = [\"ExecutionTarget\", \"NotAcquired\"]\n}\n\ndata \"octopusdeploy_feeds\" \"sales_maven_feed\" {\n  feed_type    = \"Maven\"\n  ids          = []\n  partial_name = \"Sales Maven Feed\"\n  skip         = 0\n  take         = 1\n}\n\nresource \"octopusdeploy_maven_feed\" \"feed_sales_maven_feed\" {\n  count                                = length(data.octopusdeploy_feeds.sales_maven_feed.feeds) == 0 ? 1 : 0\n  name                                 = \"Sales Maven Feed\"\n  feed_uri                             = \"https://octopus-sales-public-maven-repo.s3.ap-southeast-2.amazonaws.com/snapshot\"\n  package_acquisition_location_options = [\"Server\", \"ExecutionTarget\"]\n  download_attempts                    = 3\n  download_retry_backoff_seconds       = 20\n}\n#endregion\n\n#region Accounts\n\ndata \"octopusdeploy_accounts\" \"aws_account\" {\n  account_type = \"AmazonWebServicesAccount\"\n  ids          = []\n  partial_name = \"AWS Account\"\n  skip         = 0\n  take         = 1\n}\n\nvariable \"account_aws_access_key\" {\n  type        = string\n  nullable    = false\n  sensitive   = false\n  description = \"The AWS access key associated with the account AWS Account\"\n}\n\nvariable \"account_aws_secret_key\" {\n  type        = string\n  nullable    = false\n  sensitive   = true\n  description = \"The AWS secret key associated with the account AWS Account\"\n}\n\nresource \"octopusdeploy_aws_account\" \"aws_account\" {\n  count                             = length(data.octopusdeploy_accounts.aws_account.accounts) == 0 ? 1 : 0\n  name                              = \"AWS Account\"\n  description                       = \"\"\n  environments                      = []\n  tenant_tags                       = []\n  tenants                           = []\n  tenanted_deployment_participation = \"Untenanted\"\n  access_key                        = var.account_aws_access_key\n  secret_key                        = var.account_aws_secret_key\n}\n\n#endregion\n\n#region Project Groups\ndata \"octopusdeploy_project_groups\" \"eks\" {\n  ids          = []\n  partial_name = \"EKS\"\n  skip         = 0\n  take         = 1\n}\n\nresource \"octopusdeploy_project_group\" \"project_group_eks\" {\n  count       = length(data.octopusdeploy_project_groups.eks.project_groups) == 0 ? 1 : 0\n  name        = \"EKS\"\n  description = \"EKS projects.\"\n}\n#endregion\n\n#region Worker Pools\n\ndata \"octopusdeploy_worker_pools\" \"workerpool_hosted_ubuntu\" {\n  partial_name = \"Hosted Ubuntu\"\n  ids          = null\n  skip         = 0\n  take         = 1\n}\n#endregion\n\n#region Projects\n\n#region AWS Infrastructure\ndata \"octopusdeploy_projects\" \"aws_infrastructure\" {\n  cloned_from_project_id = \"\"\n  ids                    = []\n  is_clone               = true\n  partial_name           = \"_ AWS EKS Infrastructure\"\n  skip                   = 0\n  take                   = 1\n}\n\nresource \"octopusdeploy_project\" \"aws_infrastructure\" {\n  count                                = length(data.octopusdeploy_projects.aws_infrastructure.projects) == 0 ? 1 : 0\n  name                                 = \"_ AWS EKS Infrastructure\"\n  auto_create_release                  = false\n  default_guided_failure_mode          = \"EnvironmentDefault\"\n  default_to_skip_if_already_installed = false\n  discrete_channel_release             = false\n  is_disabled                          = false\n  is_version_controlled                = true\n  lifecycle_id                         = length(data.octopusdeploy_lifecycles.devsecops.lifecycles) == 0 ? octopusdeploy_lifecycle.lifecycle_devsecops[0].id : data.octopusdeploy_lifecycles.devsecops.lifecycles[0].id\n  project_group_id                     = length(data.octopusdeploy_project_groups.eks.project_groups) == 0 ? octopusdeploy_project_group.project_group_eks[0].id : data.octopusdeploy_project_groups.eks.project_groups[0].id\n  included_library_variable_sets       = []\n  tenanted_deployment_participation    = \"Untenanted\"\n\n  connectivity_policy {\n    allow_deployments_to_no_targets = false\n    exclude_unhealthy_targets       = false\n    skip_machine_behavior           = \"None\"\n  }\n\n  versioning_strategy {\n    template = \"\"\n  }\n\n  lifecycle {\n    ignore_changes = [\"connectivity_policy\"]\n  }\n  description = \"AWS infrastrucutre runbooks\"\n}\n\nresource \"octopusdeploy_variable\" \"library_variable_set_variables_octopub_aws_account_1\" {\n  count        = length(data.octopusdeploy_projects.aws_infrastructure.projects) == 0 ? 1 : 0\n  owner_id     = octopusdeploy_project.aws_infrastructure[0].id\n  value        = length(data.octopusdeploy_accounts.aws_account.accounts) == 0 ? octopusdeploy_aws_account.aws_account[0].id : data.octopusdeploy_accounts.aws_account.accounts[0].id\n  name         = \"AWS.Account\"\n  type         = \"AmazonWebServicesAccount\"\n  description  = \"\"\n  is_sensitive = false\n  depends_on   = []\n}\n\nresource \"octopusdeploy_variable\" \"aws_infrastructure_aws_eks_name_1\" {\n  count        = length(data.octopusdeploy_projects.aws_infrastructure.projects) == 0 ? 1 : 0\n  owner_id     = octopusdeploy_project.aws_infrastructure[0].id\n  value        = \"octopus\"\n  name         = \"AWS.EKS.Name\"\n  type         = \"String\"\n  is_sensitive = false\n\n  prompt {\n    description = \"EKS Cluster Name\"\n    label       = \"EKS Cluster Name\"\n    is_required = true\n    display_settings {\n      control_type = \"SingleLineText\"\n    }\n  }\n}\n\nresource \"octopusdeploy_variable\" \"aws_infrastructure_aws_eks_region_1\" {\n  count        = length(data.octopusdeploy_projects.aws_infrastructure.projects) == 0 ? 1 : 0\n  owner_id     = octopusdeploy_project.aws_infrastructure[0].id\n  value        = \"ap-southeast-2\"\n  name         = \"AWS.EKS.Region\"\n  type         = \"String\"\n  is_sensitive = false\n\n  prompt {\n    description = \"EKS Cluster Region\"\n    label       = \"EKS Cluster Region\"\n    is_required = true\n    display_settings {\n      control_type = \"SingleLineText\"\n    }\n  }\n}\n\nresource \"octopusdeploy_runbook\" \"runbook_create_eks_cluster\" {\n  count             = length(data.octopusdeploy_projects.aws_infrastructure.projects) == 0 ? 1 : 0\n  name              = \"\uD83D\uDEE0\uFE0F Create EKS Cluster\"\n  project_id        = octopusdeploy_project.aws_infrastructure[0].id\n  environment_scope = \"Specified\"\n  environments      = [\n    length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n    length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n    length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n  ]\n  force_package_download      = false\n  default_guided_failure_mode = \"EnvironmentDefault\"\n  description                 = <<EOT\n**Action**: Creates the EKS cluster.\n\n**Affects**: No existing resources are affected. If the cluster exists, it is not modified.\nEOT\n  multi_tenancy_mode          = \"Untenanted\"\n\n  retention_policy {\n    quantity_to_keep    = 100\n    should_keep_forever = false\n  }\n\n  connectivity_policy {\n    allow_deployments_to_no_targets = true\n    exclude_unhealthy_targets       = false\n    skip_machine_behavior           = \"None\"\n  }\n}\n\nresource \"octopusdeploy_runbook_process\" \"runbook_process_eks_create_eks_cluster\" {\n  count      = length(data.octopusdeploy_projects.aws_infrastructure.projects) == 0 ? 1 : 0\n  runbook_id = octopusdeploy_runbook.runbook_create_eks_cluster[0].id\n\n  step {\n    condition           = \"Success\"\n    name                = \"Create EKS Cluster\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.AwsRunScript\"\n      name                               = \"Create EKS Cluster\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      properties                         = {\n        \"Octopus.Action.RunOnServer\"                = \"true\"\n        \"Octopus.Action.Script.ScriptBody\"          = \"# Check to see if $IsWindows is available\\nif ($null -eq $IsWindows)\\n{\\n    Write-Host \\\"Determining Operating System...\\\"\\n    $IsWindows = ([System.Environment]::OSVersion.Platform -eq \\\"Win32NT\\\")\\n    $IsLinux = ([System.Environment]::OSVersion.Platform -eq \\\"Unix\\\")\\n}\\n\\nFunction Invoke-CustomCommand\\n{\\n    Param (\\n        $commandPath,\\n        $commandArguments,\\n        $workingDir = (Get-Location),\\n        $path = @()\\n    )\\n\\n    $path += $env:PATH\\n    $newPath = $path -join [IO.Path]::PathSeparator\\n\\n    $pinfo = New-Object System.Diagnostics.ProcessStartInfo\\n    $pinfo.FileName = $commandPath\\n    $pinfo.WorkingDirectory = $workingDir\\n    $pinfo.RedirectStandardError = $true\\n    $pinfo.RedirectStandardOutput = $true\\n    $pinfo.UseShellExecute = $false\\n    $pinfo.Arguments = $commandArguments\\n    $pinfo.EnvironmentVariables[\\\"PATH\\\"] = $newPath\\n    $p = New-Object System.Diagnostics.Process\\n    $p.StartInfo = $pinfo\\n    $p.Start() | Out-Null\\n    $p.WaitForExit()\\n    $executionResults = [pscustomobject]@{\\n        StdOut = $p.StandardOutput.ReadToEnd()\\n        StdErr = $p.StandardError.ReadToEnd()\\n        ExitCode = $p.ExitCode\\n    }\\n\\n    return $executionResults\\n\\n}\\n\\nfunction Write-Results\\n{\\n    param (\\n        $results\\n    )\\n\\n    if (![String]::IsNullOrWhiteSpace($results.StdOut))\\n    {\\n        Write-Verbose $results.StdOut\\n    }\\n    if (![String]::IsNullOrWhiteSpace($results.StdErr))\\n    {\\n        Write-Verbose $results.StdErr\\n    }\\n}\\n\\nfunction Install-App\\n{\\n    param (\\n        $app,\\n        $versionArgument,\\n        $download,\\n        $downloadFileName,\\n        $downloadBinary\\n    )\\n\\n    Try\\n    {\\n        if ($versionArgument -is [array])\\n        {\\n            $results = Invoke-CustomCommand $app $versionArgument\\n        } else {\\n            $results = Invoke-CustomCommand $app @($versionArgument)\\n        }\\n        if ($results.ExitCode -ne 0)\\n        {\\n            throw \\\"Exit code was \\\" + $results.ExitCode\\n        }\\n        return $app\\n    }\\n    Catch\\n    {\\n        # Ignore the error, we assume the app does not exist\\n    }\\n\\n    $fileWithoutExtenion = [System.IO.Path]::GetFileNameWithoutExtension($downloadFileName)\\n    $extension = [System.IO.Path]::GetExtension($downloadFileName)\\n\\n    Write-Host \\\"Downloading $download\\\"\\n    Invoke-WebRequest -Uri $download -OutFile $downloadFileName\\n\\n    if ($extension -eq \\\".zip\\\")\\n    {\\n        Write-Host \\\"Extracting $downloadFileName\\\"\\n        New-Item -ItemType Directory -Path $fileWithoutExtenion | Out-Null\\n        Expand-Archive -Path $downloadFileName -DestinationPath $fileWithoutExtenion\\n\\n        $binary = Join-Path -Path $fileWithoutExtenion -ChildPath $downloadBinary\\n        $results = Invoke-CustomCommand $binary @($versionArgument)\\n        Write-Results $results\\n        if ($results.ExitCode -ne 0)\\n        {\\n            throw \\\"Installed app failed to execute \\\" + $binary + \\\". Returned \\\" + $results.ExitCode\\n        }\\n        return $binary\\n    }\\n    elseif ($extension -eq \\\".gz\\\")\\n    {\\n        Write-Host \\\"Extracting $downloadFileName\\\"\\n        $extractedFile = [System.IO.Path]::GetFileNameWithoutExtension($downloadFileName)\\n        $extractedDir = [System.IO.Path]::GetFileNameWithoutExtension($extractedFile)\\n        New-Item -ItemType Directory -Path $extractedDir | Out-Null\\n\\n        $results = Invoke-CustomCommand \\\"tar\\\" @(\\\"xzf\\\", $downloadFileName, \\\"-C\\\", $extractedDir)\\n        Write-Results $results\\n        if ($results.ExitCode -ne 0)\\n        {\\n            throw \\\"Failed to extract file \\\" + $results.ExitCode\\n        }\\n\\n        $binary = Join-Path -Path $extractedDir -ChildPath $downloadBinary\\n        $results = Invoke-CustomCommand $binary @($versionArgument)\\n        Write-Results $results\\n        if ($results.ExitCode -ne 0)\\n        {\\n            throw \\\"Installed app failed to execute \\\" + $binary + \\\". Returned \\\" + $results.ExitCode\\n        }\\n        return $binary\\n    }\\n    else\\n    {\\n        # We likely have to make a downloaded binary executable\\n        if ($IsLinux)\\n        {\\n            $results = Invoke-CustomCommand \\\"chmod\\\" @(\\\"+x\\\", $downloadFileName)\\n            Write-Results $results\\n            if ($results.ExitCode -ne 0)\\n            {\\n                throw \\\"Failed to make download executable\\\"\\n            }\\n        }\\n\\n        $results = Invoke-CustomCommand $downloadFileName @($versionArgument)\\n        Write-Results $results\\n        if ($results.ExitCode -ne 0)\\n        {\\n            throw \\\"Installed app failed to execute \\\" + $downloadFileName + \\\". Returned \\\" + $results.ExitCode\\n        }\\n        return $downloadFileName\\n    }\\n}\\n\\nfunction Install-CustomModule\\n{\\n    param (\\n        $module\\n    )\\n\\n    if (!(Get-Module -ListAvailable -Name $module))\\n    {\\n        Install-Module -Scope CurrentUser -Force $module\\n    }\\n}\\n\\nfunction Install-Eksctl\\n{\\n    if ($IsWindows)\\n    {\\n        return Install-App \\\"eksctl.exe\\\" \\\"version\\\" \\\"https://github.com/eksctl-io/eksctl/releases/latest/download/eksctl_Windows_amd64.zip\\\" \\\"eksctl.zip\\\" \\\"eksctl.exe\\\"\\n    }\\n    elseif ($IsLinux)\\n    {\\n        return Install-App \\\"eksctl\\\" \\\"version\\\" \\\"https://github.com/eksctl-io/eksctl/releases/latest/download/eksctl_Linux_amd64.tar.gz\\\" \\\"eksctl.tar.gz\\\" \\\"eksctl\\\"\\n    }\\n\\n    throw \\\"Unexpected operation system\\\"\\n}\\n\\nfunction Install-IamAuthenticator\\n{\\n    if ($IsWindows)\\n    {\\n        return Install-App \\\"aws-iam-authenticator.exe\\\" \\\"version\\\" \\\"https://github.com/kubernetes-sigs/aws-iam-authenticator/releases/download/v0.5.9/aws-iam-authenticator_0.5.9_windows_amd64.exe\\\" \\\"aws-iam-authenticator.exe\\\" \\\"aws-iam-authenticator.exe\\\"\\n    }\\n    elseif ($IsLinux)\\n    {\\n        return Install-App \\\"aws-iam-authenticator\\\" \\\"version\\\" \\\"https://github.com/kubernetes-sigs/aws-iam-authenticator/releases/download/v0.5.9/aws-iam-authenticator_0.5.9_linux_amd64\\\" \\\"aws-iam-authenticator\\\" \\\"aws-iam-authenticator\\\"\\n    }\\n\\n    throw \\\"Unexpected operation system\\\"\\n}\\n\\nfunction Install-Helm\\n{\\n    if ($IsWindows)\\n    {\\n        return Install-App \\\"helm\\\" \\\"version\\\" \\\"https://get.helm.sh/helm-v3.12.3-windows-amd64.zip\\\" \\\"helm.zip\\\" \\\"windows-amd64/helm.exe\\\"\\n    }\\n    elseif ($IsLinux)\\n    {\\n        return Install-App \\\"helm\\\" \\\"version\\\" \\\"https://get.helm.sh/helm-v3.12.3-linux-amd64.tar.gz\\\" \\\"helm.tar.gz\\\" \\\"linux-amd64/helm\\\"\\n    }\\n\\n    throw \\\"Unexpected operation system\\\"\\n}\\n\\nfunction Install-Kubectl\\n{\\n    if ($IsWindows)\\n    {\\n        return Install-App \\\"kubectl\\\" @(\\\"version\\\", \\\"--client=true\\\") \\\"https://dl.k8s.io/release/v1.28.2/bin/windows/amd64/kubectl.exe\\\" \\\"kubectl.exe\\\" \\\"kubectl.exe\\\"\\n    }\\n    elseif ($IsLinux)\\n    {\\n        return Install-App \\\"kubectl\\\" @(\\\"version\\\", \\\"--client=true\\\") \\\"https://dl.k8s.io/release/v1.28.2/bin/linux/amd64/kubectl\\\" \\\"kubectl\\\" \\\"kubectl\\\"\\n    }\\n\\n    throw \\\"Unexpected operation system\\\"\\n}\\n\\nfunction Write-EksConfig\\n{\\n    param (\\n        $clusterName,\\n        $clusterRegion\\n    )\\n\\n    Set-Content -Path \\\"cluster.yaml\\\" -Value @\\\"\\napiVersion: eksctl.io/v1alpha5\\nkind: ClusterConfig\\n\\nmetadata:\\n  name: $clusterName\\n  region: $clusterRegion\\n\\n# A regular node group is required for NGINX\\nnodeGroups:\\n  - name: ng-1\\n    instanceType: t3a.small\\n    desiredCapacity: 1\\n    volumeSize: 80\\n\\nfargateProfiles:\\n  - name: fp-default\\n    selectors:\\n      # All workloads in the \\\"default\\\" Kubernetes namespace will be\\n      # scheduled onto Fargate:\\n      - namespace: default\\n      # All workloads in the \\\"kube-system\\\" Kubernetes namespace will be\\n      # scheduled onto Fargate:\\n      - namespace: kube-system\\n  - name: fp-development\\n    selectors:\\n      - namespace: development\\n  - name: fp-test\\n    selectors:\\n      - namespace: test\\n  - name: fp-production\\n    selectors:\\n      - namespace: production\\n\\\"@\\n}\\n\\nInstall-CustomModule powershell-yaml\\n\\n$clusterName = $OctopusParameters[\\\"AWS.EKS.Name\\\"]\\n$clusterRegion = $OctopusParameters[\\\"AWS.EKS.Region\\\"]\\n$awsAccountVariable = $OctopusParameters[\\\"Octopus.Action.AwsAccount.Variable\\\"]\\n$awsAccount = $OctopusParameters[$awsAccountVariable]\\n$environment = $OctopusParameters[\\\"Octopus.Environment.Name\\\"]\\n$sortOrder = $OctopusParameters[\\\"Octopus.Environment.SortOrder\\\"]\\n\\n# When multiple environments share a cluster, we want to make sure eksctl doesn't attempt to\\n# create the same cluster at the same time.\\n$sleep = [int]$sortOrder * 10\\nWrite-Host \\\"Sleeping for $sleep seconds\\\"\\nStart-Sleep -Seconds $sleep\\n\\nInstall-IamAuthenticator | Out-Null\\n$helm = Install-Helm\\n$kubectl = Install-Kubectl\\n$eksctl = Install-Eksctl\\nWrite-EksConfig $clusterName $clusterRegion\\n$results = Invoke-CustomCommand $eksctl @(\\\"get\\\", \\\"cluster\\\", \\\"--name\\\", $clusterName, \\\"--region\\\", $clusterRegion) -Path @((Get-Location))\\nif ($results.ExitCode -eq 0)\\n{\\n    Write-Host \\\"Getting cluster details\\\"\\n    $result = Invoke-CustomCommand $eksctl @(\\\"utils\\\", \\\"write-kubeconfig\\\", \\\"--cluster\\\", $clusterName, \\\"--region\\\", $clusterRegion, \\\"--kubeconfig\\\", \\\"eks-config.yaml\\\") -Path @((Get-Location))\\n    Write-Results $result\\n}\\nelse\\n{\\n    Write-Host \\\"Creating cluster - this can take a while\\\"\\n    $result = Invoke-CustomCommand $eksctl @(\\\"create\\\", \\\"cluster\\\", \\\"-f\\\", \\\"cluster.yaml\\\", \\\"--kubeconfig\\\", 'eks-config.yaml') -Path @((Get-Location))\\n    Write-Results $result\\n}\\n\\n# https://kubernetes.github.io/ingress-nginx/deploy/#aws\\n$result = Invoke-CustomCommand $kubectl @(\\\"apply\\\", \\\"-f\\\", \\\"https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.8.2/deploy/static/provider/aws/deploy.yaml\\\", \\\"--kubeconfig\\\", \\\"eks-config.yaml\\\") -Path @((Get-Location))\\n\\nWrite-Results $result\\n\\n$kubeConfig = ConvertFrom-Yaml (Get-Content eks-config.yaml -Raw)\\n\\nNew-OctopusKubernetesTarget `\\n    -name \\\"$clusterName $($environment.ToLower())\\\" `\\n    -octopusRoles \\\"EKS_Reference_Cluster,Kubernetes\\\" `\\n    -clusterUrl $kubeConfig.clusters[0].cluster.server `\\n    -octopusAccountIdOrName $awsAccount `\\n    -clusterName $clusterName `\\n    -namespace $environment.ToLower() `\\n    -updateIfExisting `\\n    -skipTlsVerification True\"\n        \"Octopus.Action.AwsAccount.UseInstanceRole\" = \"False\"\n        \"Octopus.Action.AwsAccount.Variable\"        = \"AWS.Account\"\n        \"Octopus.Action.Aws.Region\"                 = \"#{AWS.EKS.Region}\"\n        \"Octopus.Action.Script.ScriptSource\"        = \"Inline\"\n        \"Octopus.Action.Aws.AssumeRole\"             = \"False\"\n        \"Octopus.Action.Script.Syntax\"              = \"PowerShell\"\n        \"OctopusUseBundledTooling\"                  = \"False\"\n      }\n      environments = [\n        length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n        length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n        length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n      ]\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n\n      container {\n        feed_id = local.docker_hub_feed_id\n        image   = \"octopuslabs/aws-workertools\"\n      }\n    }\n\n    properties   = {}\n    target_roles = []\n  }\n\n  step {\n    condition           = \"Always\"\n    name                = \"Feedback\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.Script\"\n      name                               = \"Feedback\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      properties                         = {\n        \"Octopus.Action.RunOnServer\"         = \"true\"\n        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"\n        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"\n        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"\n      }\n      environments          = []\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = []\n  }\n}\n\nresource \"octopusdeploy_runbook\" \"runbook_octopub_get_nodes\" {\n  count             = length(data.octopusdeploy_projects.aws_infrastructure.projects) == 0 ? 1 : 0\n  project_id        = octopusdeploy_project.aws_infrastructure[0].id\n  name              = \"\uD83D\uDEE0\uFE0F Get Nodes\"\n  environment_scope = \"Specified\"\n  environments      = [\n    length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n    length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n    length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n  ]\n  force_package_download      = false\n  default_guided_failure_mode = \"Off\"\n  description                 = <<EOT\n**Action**: Returns the cluster nodes.\n\n**Affects**: Nothing - this runbook makes no changes.\nEOT\n  multi_tenancy_mode          = \"Untenanted\"\n\n  retention_policy {\n    quantity_to_keep    = 100\n    should_keep_forever = false\n  }\n\n  connectivity_policy {\n    allow_deployments_to_no_targets = true\n    exclude_unhealthy_targets       = false\n    skip_machine_behavior           = \"None\"\n  }\n}\n\nresource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_get_nodes\" {\n  count      = length(data.octopusdeploy_projects.aws_infrastructure.projects) == 0 ? 1 : 0\n  runbook_id = octopusdeploy_runbook.runbook_octopub_get_nodes[0].id\n\n  step {\n    condition           = \"Success\"\n    name                = \"Get Nodes\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.KubernetesRunScript\"\n      name                               = \"Get Nodes\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      worker_pool_variable               = \"\"\n      properties                         = {\n        \"K8SInspectCreateArtifact\"                      = \"False\"\n        \"Octopus.Action.Script.ScriptBody\"              = \"\\u003c#\\n    This script provides a general purpose method for querying Kubernetes resources. It supports common operations\\n    like get, describe, logs and output formats like yaml and json. Output can be captured as artifacts.\\n#\\u003e\\n\\n\\u003c#\\n.Description\\nExecute an application, capturing the output. Based on https://stackoverflow.com/a/33652732/157605\\n#\\u003e\\nFunction Execute-Command ($commandPath, $commandArguments)\\n{\\n  Write-Host \\\"Executing: $commandPath $($commandArguments -join \\\" \\\")\\\"\\n  \\n  Try {\\n    $pinfo = New-Object System.Diagnostics.ProcessStartInfo\\n    $pinfo.FileName = $commandPath\\n    $pinfo.RedirectStandardError = $true\\n    $pinfo.RedirectStandardOutput = $true\\n    $pinfo.UseShellExecute = $false\\n    $pinfo.Arguments = $commandArguments\\n    $p = New-Object System.Diagnostics.Process\\n    $p.StartInfo = $pinfo\\n    $p.Start() | Out-Null\\n    [pscustomobject]@{\\n        stdout = $p.StandardOutput.ReadToEnd()\\n        stderr = $p.StandardError.ReadToEnd()\\n        ExitCode = $p.ExitCode\\n    }\\n    $p.WaitForExit()\\n  }\\n  Catch {\\n     exit\\n  }\\n}\\n\\n\\u003c#\\n.Description\\nFind any resource names that match a wildcard input if one was specified\\n#\\u003e\\nfunction Get-Resources() \\n{\\n    $names = $OctopusParameters[\\\"K8SInspectNames\\\"] -Split \\\"`n\\\" | % {$_.Trim()}\\n    \\n    if ($OctopusParameters[\\\"K8SInspectNames\\\"] -match '\\\\*' )\\n    {\\n        return Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", $OctopusParameters[\\\"K8SInspectResource\\\"])) |\\n            # Select the stdout property from the execution\\n            Select-Object -ExpandProperty stdout |\\n            # Convert the output from JSON\\n            ConvertFrom-JSON | \\n            # Get the items object from the kubectl response\\n            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\\n            # Extract the name\\n            % {$_.metadata.name} |\\n            # Find any matching resources\\n            ? {$k8sName = $_; ($names | ? {$k8sName -like $_}).Count -ne 0}\\n    }\\n    else\\n    {\\n        return $names\\n    }\\n}\\n\\n\\u003c#\\n.Description\\nGet the kubectl arguments for a given action\\n#\\u003e\\nfunction Get-KubectlVerb() \\n{\\n    switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\\n    {\\n        \\\"get json\\\" {return ,@(\\\"-o\\\", \\\"json\\\", \\\"get\\\")}\\n        \\\"get yaml\\\" {return ,@(\\\"-o\\\", \\\"yaml\\\", \\\"get\\\")}\\n        \\\"describe\\\" {return ,@(\\\"describe\\\")}\\n        \\\"logs\\\" {return ,@(\\\"logs\\\")}\\n        \\\"logs tail\\\" {return ,@(\\\"logs\\\", \\\"--tail\\\", \\\"100\\\")}\\n        \\\"previous logs\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\")}\\n        \\\"previous logs tail\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\", \\\"--tail\\\", \\\"100\\\")}\\n        default {return ,@(\\\"get\\\")}\\n    }\\n}\\n\\n\\u003c#\\n.Description\\nGet an appropiate file extension based on the selected action\\n#\\u003e\\nfunction Get-ArtifactExtension() \\n{\\n   switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\\n    {\\n        \\\"get json\\\" {\\\"json\\\"}\\n        \\\"get yaml\\\" {\\\"yaml\\\"}\\n        default {\\\"txt\\\"}\\n    }\\n}\\n\\nif ($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"] -like \\\"*logs*\\\") \\n{\\n    if ( -not @($OctopusParameters[\\\"K8SInspectResource\\\"]) -like \\\"pod*\\\")\\n    {\\n        Write-Error \\\"Logs can only be returned for pods, not $($OctopusParameters[\\\"K8SInspectResource\\\"])\\\"\\n    }\\n    else\\n    {\\n        Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", \\\"pods\\\") + (Get-Resources)) |\\n            # Select the stdout property from the execution\\n            Select-Object -ExpandProperty stdout |\\n            # Convert the output from JSON\\n            ConvertFrom-JSON | \\n            # Get the items object from the kubectl response\\n            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\\n            # Get the pod logs for each container\\n            % {\\n                $podDetails = $_\\n                @{\\n                    logs=$podDetails.spec.containers | % {$logs=\\\"\\\"} {$logs += (Select-Object -InputObject (Execute-Command kubectl ((Get-KubectlVerb) + @($podDetails.metadata.name, \\\"-c\\\", $_.name))) -ExpandProperty stdout)} {$logs}; \\n                    name=$podDetails.metadata.name\\n                }                \\n            } |\\n            # Write the output\\n            % {Write-Host $_.logs; $_} |\\n            # Optionally capture the artifact\\n            % {\\n                if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \\n                {\\n                    Set-Content -Path \\\"$($_.name).$(Get-ArtifactExtension)\\\" -Value $_.logs\\n                    New-OctopusArtifact \\\"$($_.name).$(Get-ArtifactExtension)\\\"\\n                }\\n            }\\n    }      \\n}\\nelse\\n{\\n    Execute-Command kubectl ((Get-KubectlVerb) + @($OctopusParameters[\\\"K8SInspectResource\\\"]) + (Get-Resources)) |\\n        % {Select-Object -InputObject $_ -ExpandProperty stdout} |\\n        % {Write-Host $_; $_} |\\n        % {\\n            if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \\n            {\\n                Set-Content -Path \\\"output.$(Get-ArtifactExtension)\\\" -Value $_\\n                New-OctopusArtifact \\\"output.$(Get-ArtifactExtension)\\\"\\n            }\\n        }\\n}\\n\"\n        \"Octopus.Action.Script.ScriptSource\"            = \"Inline\"\n        \"K8SInspectResource\"                            = \"node\"\n        \"Octopus.Action.Script.Syntax\"                  = \"PowerShell\"\n        \"Octopus.Action.KubernetesContainers.Namespace\" = \"#{if K8SInspectNamespace}#{K8SInspectNamespace}#{/if}#{unless K8SInspectNamespace}#{Octopus.Action.Kubernetes.Namespace}#{/unless}\"\n        \"K8SInspectNames\"                               = \"*\"\n        \"K8SInspectKubectlVerb\"                         = \"get\"\n      }\n      container {\n        feed_id = local.docker_hub_feed_id\n        image   = \"octopuslabs/k8s-workertools\"\n      }\n      environments = [\n        length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n        length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n        length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n      ]\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = [\"EKS_Reference_Cluster\"]\n  }\n\n  step {\n    condition           = \"Always\"\n    name                = \"Feedback\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.Script\"\n      name                               = \"Feedback\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      properties                         = {\n        \"Octopus.Action.RunOnServer\"         = \"true\"\n        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"\n        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"\n        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"\n      }\n      environments          = []\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = []\n  }\n}\n\nresource \"octopusdeploy_runbook\" \"runbook_delete_eks_cluster\" {\n  count             = length(data.octopusdeploy_projects.aws_infrastructure.projects) == 0 ? 1 : 0\n  name              = \"\uD83D\uDDD1\uFE0F Delete EKS Cluster\"\n  project_id        = octopusdeploy_project.aws_infrastructure[0].id\n  environment_scope = \"Specified\"\n  environments      = [\n    length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n    length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n    length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n  ]\n  force_package_download      = false\n  default_guided_failure_mode = \"EnvironmentDefault\"\n  description                 = <<EOT\n**WARNING**: This is a destructive operation. All applications will are deleted, and the cluster is destroyed.\n\n**Action**: Deletes the EKS cluster.\n\n**Affects**: All applications installed into the Kubernetes cluster.\nEOT\n  multi_tenancy_mode          = \"Untenanted\"\n\n  retention_policy {\n    quantity_to_keep    = 100\n    should_keep_forever = false\n  }\n\n  connectivity_policy {\n    allow_deployments_to_no_targets = true\n    exclude_unhealthy_targets       = false\n    skip_machine_behavior           = \"None\"\n  }\n}\n\nresource \"octopusdeploy_runbook_process\" \"runbook_process_aws_infrastructure_destroy_eks_cluster\" {\n  count      = length(data.octopusdeploy_projects.aws_infrastructure.projects) == 0 ? 1 : 0\n  runbook_id = octopusdeploy_runbook.runbook_delete_eks_cluster[0].id\n\n  step {\n    condition           = \"Success\"\n    name                = \"Delete EKS Cluster\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.AwsRunScript\"\n      name                               = \"Delete EKS Cluster\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = true\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      properties                         = {\n        \"Octopus.Action.Aws.AssumeRole\"             = \"False\"\n        \"OctopusUseBundledTooling\"                  = \"False\"\n        \"Octopus.Action.Script.Syntax\"              = \"PowerShell\"\n        \"Octopus.Action.AwsAccount.UseInstanceRole\" = \"False\"\n        \"Octopus.Action.Script.ScriptBody\"          = \"eksctl delete cluster --name $OctopusParameters[\\\"AWS.EKS.Name\\\"]\"\n        \"Octopus.Action.Aws.Region\"                 = \"#{AWS.EKS.Region}\"\n        \"Octopus.Action.AwsAccount.Variable\"        = \"AWS.Account\"\n        \"Octopus.Action.Script.ScriptSource\"        = \"Inline\"\n        \"Octopus.Action.RunOnServer\"                = \"true\"\n      }\n\n      container {\n        feed_id = local.docker_hub_feed_id\n        image   = \"octopuslabs/aws-workertools\"\n      }\n\n      environments = [\n        length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n        length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n        length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n      ]\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = []\n  }\n\n  step {\n    condition           = \"Always\"\n    name                = \"Feedback\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.Script\"\n      name                               = \"Feedback\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      properties                         = {\n        \"Octopus.Action.RunOnServer\"         = \"true\"\n        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"\n        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"\n        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"\n      }\n      environments          = []\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = []\n  }\n}\n#endregion\n\n#region Frontend\ndata \"octopusdeploy_projects\" \"octopub_frontend\" {\n  partial_name = \"EKS Octopub Frontend\"\n  skip         = 0\n  take         = 1\n}\n\nresource \"octopusdeploy_variable\" \"frontend_deployment_feed\" {\n  count        = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0\n  owner_id     = octopusdeploy_project.project_octopub_frontend[0].id\n  value        = local.docker_hub_feed_id\n  name         = \"Kubernetes.Deployment.Feed\"\n  type         = \"String\"\n  description  = \"The feed ID hosting the image\"\n  is_sensitive = false\n}\n\nresource \"octopusdeploy_variable\" \"frontend_deployment_image\" {\n  count        = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0\n  owner_id     = octopusdeploy_project.project_octopub_frontend[0].id\n  value        = \"octopussamples/octopub-frontend\"\n  name         = \"Kubernetes.Deployment.Image\"\n  type         = \"String\"\n  description  = \"The image to deploy\"\n  is_sensitive = false\n}\n\nresource \"octopusdeploy_variable\" \"frontend_deployment_port\" {\n  count        = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0\n  owner_id     = octopusdeploy_project.project_octopub_frontend[0].id\n  value        = \"8080\"\n  name         = \"Kubernetes.Deployment.Port\"\n  type         = \"String\"\n  description  = \"The port exposed by the web app\"\n  is_sensitive = false\n}\n\nresource \"octopusdeploy_variable\" \"frontend_deployment_name\" {\n  count        = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0\n  owner_id     = octopusdeploy_project.project_octopub_frontend[0].id\n  value        = \"frontend\"\n  name         = \"Kubernetes.Deployment.Name\"\n  type         = \"String\"\n  description  = \"The name of the Kubernetes deployment resource\"\n  is_sensitive = false\n  depends_on   = []\n}\n\nresource \"octopusdeploy_variable\" \"frontend_service_name\" {\n  count        = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0\n  owner_id     = octopusdeploy_project.project_octopub_frontend[0].id\n  value        = \"frontend\"\n  name         = \"Kubernetes.Service.Name\"\n  type         = \"String\"\n  description  = \"The name of the Kubernetes service resource\"\n  is_sensitive = false\n  depends_on   = []\n}\n\nresource \"octopusdeploy_variable\" \"frontend_ingress_name\" {\n  count        = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0\n  owner_id     = octopusdeploy_project.project_octopub_frontend[0].id\n  value        = \"frontend\"\n  name         = \"Kubernetes.Ingress.Name\"\n  type         = \"String\"\n  description  = \"The name of the Kubernetes ingress resource\"\n  is_sensitive = false\n  depends_on   = []\n}\n\nresource \"octopusdeploy_project\" \"project_octopub_frontend\" {\n  count                                = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0\n  name                                 = \"EKS Octopub Frontend\"\n  auto_create_release                  = false\n  default_guided_failure_mode          = \"Off\"\n  default_to_skip_if_already_installed = false\n  discrete_channel_release             = false\n  is_disabled                          = false\n  is_version_controlled                = false\n  lifecycle_id                         = length(data.octopusdeploy_lifecycles.devsecops.lifecycles) == 0 ? octopusdeploy_lifecycle.lifecycle_devsecops[0].id : data.octopusdeploy_lifecycles.devsecops.lifecycles[0].id\n  project_group_id                     = length(data.octopusdeploy_project_groups.eks.project_groups) == 0 ? octopusdeploy_project_group.project_group_eks[0].id : data.octopusdeploy_project_groups.eks.project_groups[0].id\n  included_library_variable_sets       = []\n  tenanted_deployment_participation    = \"Untenanted\"\n\n  connectivity_policy {\n    allow_deployments_to_no_targets = true\n    exclude_unhealthy_targets       = false\n    skip_machine_behavior           = \"None\"\n  }\n\n  versioning_strategy {\n    template = \"#{Octopus.Version.LastMajor}.#{Octopus.Version.LastMinor}.#{Octopus.Version.NextPatch}\"\n  }\n\n  lifecycle {\n    ignore_changes = []\n  }\n  description = <<EOT\nDeploys the Octopub Frontend\n\n**Source**: [GitHub](https://github.com/OctopusSolutionsEngineering/Octopub)\n\n**Build**: [GitHub Actions](https://github.com/OctopusSolutionsEngineering/Octopub/actions)\n\n**Issues**: [GitHub Issues](https://github.com/OctopusSolutionsEngineering/Octopub/issues)\nEOT\n}\n\nresource \"octopusdeploy_deployment_process\" \"deployment_process_octopub_frontend\" {\n  count      = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0\n  project_id = octopusdeploy_project.project_octopub_frontend[0].id\n\n  step {\n    condition           = \"Success\"\n    name                = \"Deploy Container\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.KubernetesDeployContainers\"\n      name                               = \"Deploy Container\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = true\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      worker_pool_variable               = \"\"\n      properties                         = {\n        \"Octopus.Action.KubernetesContainers.Replicas\"               = \"1\"\n        \"Octopus.Action.KubernetesContainers.DeploymentResourceType\" = \"Deployment\"\n        \"Octopus.Action.KubernetesContainers.IngressAnnotations\"     = jsonencode([\n          {\n            \"optionError\"  = null\n            \"option2\"      = \"\"\n            \"option2Error\" = null\n            \"key\"          = \"nginx.ingress.kubernetes.io/rewrite-target\"\n            \"keyError\"     = null\n            \"value\"        = \"$1\"\n            \"valueError\"   = null\n            \"option\"       = \"\"\n          },\n          {\n            \"keyError\"     = null\n            \"value\"        = \"true\"\n            \"valueError\"   = null\n            \"option\"       = \"\"\n            \"optionError\"  = null\n            \"option2\"      = \"\"\n            \"option2Error\" = null\n            \"key\"          = \"nginx.ingress.kubernetes.io/use-regex\"\n          },\n        ])\n        \"Octopus.Action.KubernetesContainers.DeploymentStyle\" = \"RollingUpdate\"\n        \"Octopus.Action.KubernetesContainers.IngressName\"     = \"#{Kubernetes.Ingress.Name}\"\n        \"Octopus.Action.KubernetesContainers.DeploymentName\"  = \"#{Kubernetes.Deployment.Name}\"\n        \"Octopus.Action.KubernetesContainers.IngressRules\"    = jsonencode([\n          {\n            \"host\" = \"\"\n            \"http\" = {\n              \"paths\" = [\n                {\n                  \"key\"     = \"/#{Octopus.Action.Kubernetes.Namespace}(/.*)?\"\n                  \"value\"   = \"web\"\n                  \"option\"  = \"\"\n                  \"option2\" = \"ImplementationSpecific\"\n                },\n              ]\n            }\n          },\n        ])\n        \"OctopusUseBundledTooling\"                       = \"False\"\n        \"Octopus.Action.KubernetesContainers.Containers\" = jsonencode([\n          {\n            \"Args\"                         = []\n            \"FieldRefEnvironmentVariables\" = []\n            \"SecretEnvFromSource\"          = []\n            \"Command\"                      = []\n            \"Ports\"                        = [\n              {\n                \"option2Error\" = null\n                \"optionError\"  = null\n                \"value\"        = \"#{Kubernetes.Deployment.Port}\"\n                \"valueError\"   = null\n                \"key\"          = \"web\"\n                \"keyError\"     = null\n                \"option\"       = \"TCP\"\n                \"option2\"      = \"\"\n              },\n            ]\n            \"Resources\" = {\n              \"limits\" = {\n                \"storage\"          = \"\"\n                \"amdGpu\"           = \"\"\n                \"cpu\"              = \"\"\n                \"ephemeralStorage\" = \"\"\n                \"memory\"           = \"\"\n                \"nvidiaGpu\"        = \"\"\n              }\n              \"requests\" = {\n                \"amdGpu\"           = \"\"\n                \"cpu\"              = \"\"\n                \"ephemeralStorage\" = \"\"\n                \"memory\"           = \"\"\n                \"nvidiaGpu\"        = \"\"\n                \"storage\"          = \"\"\n              }\n            }\n            \"SecretEnvironmentVariables\" = []\n            \"SecurityContext\"            = {\n              \"runAsNonRoot\"   = \"True\"\n              \"runAsUser\"      = \"\"\n              \"seLinuxOptions\" = {\n                \"level\" = \"\"\n                \"role\"  = \"\"\n                \"type\"  = \"\"\n                \"user\"  = \"\"\n              }\n              \"allowPrivilegeEscalation\" = \"\"\n              \"capabilities\"             = {\n                \"add\"  = []\n                \"drop\" = [\n                  \"ALL\",\n                ]\n              }\n              \"privileged\"             = \"\"\n              \"readOnlyRootFilesystem\" = \"\"\n              \"runAsGroup\"             = \"\"\n            }\n            \"TerminationMessagePath\" = \"\"\n            \"EnvironmentVariables\"   = [\n              {\n                \"key\"          = \"UDL_SETVALUE_1\"\n                \"keyError\"     = null\n                \"value\"        = \"[/usr/share/nginx/html/config.json][productEndpoint]/#{Octopus.Action.Kubernetes.Namespace}/api/products\"\n                \"valueError\"   = null\n                \"option\"       = \"\"\n                \"optionError\"  = null\n                \"option2\"      = \"\"\n                \"option2Error\" = null\n              },\n              {\n                \"key\"          = \"UDL_SETVALUE_2\"\n                \"keyError\"     = null\n                \"value\"        = \"[/usr/share/nginx/html/config.json][productHealthEndpoint]/#{Octopus.Action.Kubernetes.Namespace}/health/products\"\n                \"valueError\"   = null\n                \"option\"       = \"\"\n                \"optionError\"  = null\n                \"option2\"      = \"\"\n                \"option2Error\" = null\n              },\n              {\n                \"key\"          = \"UDL_SETVALUE_3\"\n                \"keyError\"     = null\n                \"value\"        = \"[/usr/share/nginx/html/config.json][auditEndpoint]/#{Octopus.Action.Kubernetes.Namespace}/api/audits\"\n                \"valueError\"   = null\n                \"option\"       = \"\"\n                \"optionError\"  = null\n                \"option2\"      = \"\"\n                \"option2Error\" = null\n              },\n              {\n                \"key\"          = \"UDL_SETVALUE_4\"\n                \"keyError\"     = null\n                \"value\"        = \"[/usr/share/nginx/html/config.json][auditHealthEndpoint]/#{Octopus.Action.Kubernetes.Namespace}/health/audits\"\n                \"valueError\"   = null\n                \"option\"       = \"\"\n                \"optionError\"  = null\n                \"option2\"      = \"\"\n                \"option2Error\" = null\n              },\n            ]\n            \"LivenessProbe\" = {\n              \"successThreshold\" = \"\"\n              \"tcpSocket\"        = {\n                \"port\" = \"\"\n                \"host\" = \"\"\n              }\n              \"exec\" = {\n                \"command\" = []\n              }\n              \"failureThreshold\" = \"\"\n              \"periodSeconds\"    = \"\"\n              \"type\"             = \"\"\n              \"httpGet\"          = {\n                \"host\"        = \"\"\n                \"httpHeaders\" = []\n                \"path\"        = \"\"\n                \"port\"        = \"\"\n                \"scheme\"      = \"\"\n              }\n              \"initialDelaySeconds\" = \"\"\n              \"timeoutSeconds\"      = \"\"\n            }\n            \"ReadinessProbe\" = {\n              \"exec\" = {\n                \"command\" = []\n              }\n              \"failureThreshold\" = \"\"\n              \"timeoutSeconds\"   = \"\"\n              \"successThreshold\" = \"\"\n              \"tcpSocket\"        = {\n                \"host\" = \"\"\n                \"port\" = \"\"\n              }\n              \"type\"    = \"\"\n              \"httpGet\" = {\n                \"host\"        = \"\"\n                \"httpHeaders\" = []\n                \"path\"        = \"\"\n                \"port\"        = \"\"\n                \"scheme\"      = \"\"\n              }\n              \"initialDelaySeconds\" = \"\"\n              \"periodSeconds\"       = \"\"\n            }\n            \"TerminationMessagePolicy\"      = \"\"\n            \"VolumeMounts\"                  = []\n            \"ConfigMapEnvFromSource\"        = []\n            \"ConfigMapEnvironmentVariables\" = []\n            \"CreateFeedSecrets\"             = \"False\"\n            \"Lifecycle\"                     = {\n              \"PostStart\" = null\n              \"PreStop\"   = null\n            }\n            \"Name\"         = \"web\"\n            \"StartupProbe\" = {\n              \"successThreshold\" = \"\"\n              \"tcpSocket\"        = {\n                \"host\" = \"\"\n                \"port\" = \"\"\n              }\n              \"failureThreshold\" = \"\"\n              \"httpGet\"          = {\n                \"host\"        = \"\"\n                \"httpHeaders\" = []\n                \"path\"        = \"\"\n                \"port\"        = \"\"\n                \"scheme\"      = \"\"\n              }\n              \"initialDelaySeconds\" = \"\"\n              \"type\"                = \"\"\n              \"exec\"                = {\n                \"command\" = []\n              }\n              \"periodSeconds\"  = \"\"\n              \"timeoutSeconds\" = \"\"\n            }\n          },\n        ])\n        \"Octopus.Action.KubernetesContainers.ServiceName\"         = \"#{Kubernetes.Service.Name}\"\n        \"Octopus.Action.KubernetesContainers.PodManagementPolicy\" = \"OrderedReady\"\n        \"Octopus.Action.Kubernetes.DeploymentTimeout\"             = \"180\"\n        \"Octopus.Action.RunOnServer\"                              = \"true\"\n        \"Octopus.Action.KubernetesContainers.IngressClassName\"    = \"nginx\"\n        \"Octopus.Action.KubernetesContainers.ServicePorts\"        = jsonencode([\n          {\n            \"port\"       = \"80\"\n            \"protocol\"   = \"TCP\"\n            \"targetPort\" = \"web\"\n            \"name\"       = \"web\"\n            \"nodePort\"   = \"\"\n          },\n        ])\n        \"Octopus.Action.Kubernetes.ResourceStatusCheck\"       = \"True\"\n        \"Octopus.Action.KubernetesContainers.ServiceNameType\" = \"External\"\n        \"Octopus.Action.KubernetesContainers.ServiceType\"     = \"ClusterIP\"\n      }\n      container {\n        feed_id = local.docker_hub_feed_id\n        image   = \"octopuslabs/k8s-workertools\"\n      }\n\n      environments = [\n        length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n        length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n        length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n      ]\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n\n      package {\n        name                      = \"web\"\n        package_id                = \"#{Kubernetes.Deployment.Image}\"\n        acquisition_location      = \"NotAcquired\"\n        extract_during_deployment = false\n        feed_id                   = \"#{Kubernetes.Deployment.Feed}\"\n        properties                = { Extract = \"False\", PackageParameterName = \"\", SelectionMode = \"immediate\" }\n      }\n      features = [\n        \"\", \"Octopus.Features.KubernetesService\", \"Octopus.Features.KubernetesIngress\",\n        \"Octopus.Features.KubernetesConfigMap\", \"Octopus.Features.KubernetesSecret\"\n      ]\n    }\n\n    properties   = {}\n    target_roles = [\"EKS_Reference_Cluster\"]\n  }\n\n  step {\n    condition           = \"Success\"\n    name                = \"Smoke Test\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.KubernetesRunScript\"\n      name                               = \"Smoke Test\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      properties                         = {\n        \"Octopus.Action.RunOnServer\"         = \"true\"\n        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"\n        \"Octopus.Action.Script.Syntax\"       = \"Bash\"\n        \"Octopus.Action.Script.ScriptBody\"   = \"for i in {1..30}\\ndo\\n\\tHOSTNAME=$(kubectl get ingress #{Kubernetes.Ingress.Name} -o json -n development | jq -r '.status.loadBalancer.ingress[0].hostname')\\n    if [[ -n \\\"$${HOSTNAME}\\\" ]]\\n  \\tthen\\n    \\tbreak\\n  \\tfi\\n  \\techo \\\"Waiting for ingress hostname\\\"\\n  \\tsleep 10\\ndone\\n    \\n\\n# Load balancers can take a minute or so before their DNS is propagated.\\n# A status code of 000 means curl could not resolve the DNS name, so we wait for a bit until DNS is updated.\\necho \\\"Testing http://$${HOSTNAME}/#{Octopus.Action.Kubernetes.Namespace}/index.html\\\"\\necho \\\"Waiting for DNS to propagate. This can take a while for a new load balancer.\\\"\\nfor i in {1..30}\\ndo\\n  CODE=$(curl -o /dev/null -s -w \\\"%%{http_code}\\\\n\\\" http://$${HOSTNAME}/#{Octopus.Action.Kubernetes.Namespace}/index.html)\\n  if [[ \\\"$${CODE}\\\" == \\\"200\\\" ]]\\n  then\\n    break\\n  fi\\n  echo \\\"Waiting for DNS name to be resolvable and for service to respond\\\"\\n  sleep 10\\ndone\\n\\necho \\\"response code: $${CODE}\\\"\\nif [[ \\\"$${CODE}\\\" == \\\"200\\\" ]]\\nthen\\n    echo \\\"success\\\"\\n    exit 0\\nelse\\n    echo \\\"error\\\"\\n    exit 1\\nfi\"\n      }\n      container {\n        feed_id = local.docker_hub_feed_id\n        image   = \"octopuslabs/k8s-workertools\"\n      }\n      environments = [\n        length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n        length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n        length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n      ]\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = [\"EKS_Reference_Cluster\"]\n  }\n\n  step {\n    condition           = \"Success\"\n    name                = \"Security Scan\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.Script\"\n      name                               = \"Security Scan\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = true\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      properties                         = {\n        \"Octopus.Action.RunOnServer\"         = \"true\"\n        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"\n        \"Octopus.Action.Script.Syntax\"       = \"Bash\"\n        \"Octopus.Action.Script.ScriptBody\"   = local.security_scan_script\n      }\n      environments          = []\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features = []\n    }\n\n    properties   = {}\n    target_roles = []\n  }\n\n  step {\n    condition           = \"Always\"\n    name                = \"Feedback\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.Script\"\n      name                               = \"Feedback\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      properties                         = {\n        \"Octopus.Action.RunOnServer\"         = \"true\"\n        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"\n        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"\n        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"\n      }\n      environments          = []\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = []\n  }\n}\n\nresource \"octopusdeploy_runbook\" \"runbook_octopub_frontend_scale_to_zero\" {\n  count             = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0\n  name              = \"\uD83C\uDF03 Scale Pods to Zero\"\n  project_id        = octopusdeploy_project.project_octopub_frontend[0].id\n  environment_scope = \"Specified\"\n  environments      = [\n    length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n    length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n    length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n  ]\n  force_package_download      = false\n  default_guided_failure_mode = \"Off\"\n  description                 = <<EOT\n**WARNING**: This is a destructive operation. The service will no longer be available when scaled down.\n\n**Action**: Scales the deployment down to zero pods.\n\n**Affects**: The frontend service is effectively shut down.\n\nThis runbook is designed to be be run in non-production environments after hours to remove the Fargate nodes hosting\nthe service. This removes the cost of hosting the service out of hours.\nEOT\n  multi_tenancy_mode          = \"Untenanted\"\n\n  retention_policy {\n    quantity_to_keep    = 100\n    should_keep_forever = false\n  }\n\n  connectivity_policy {\n    allow_deployments_to_no_targets = true\n    exclude_unhealthy_targets       = false\n    skip_machine_behavior           = \"None\"\n  }\n}\n\nresource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_frontend_scale_pods_to_zero\" {\n  count      = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0\n  runbook_id = octopusdeploy_runbook.runbook_octopub_frontend_scale_to_zero[0].id\n\n  step {\n    condition           = \"Success\"\n    name                = \"Scale Pods to Zero\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.KubernetesRunScript\"\n      name                               = \"Scale Pods to Zero\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = true\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      worker_pool_variable               = \"\"\n      properties                         = {\n        \"OctopusUseBundledTooling\"           = \"False\"\n        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"\n        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"\n        \"Octopus.Action.Script.ScriptBody\"   = \"kubectl scale --replicas=0 deployment/#{Kubernetes.Deployment.Name}\"\n        \"Octopus.Action.RunOnServer\"         = \"true\"\n      }\n\n      container {\n        feed_id = local.docker_hub_feed_id\n        image   = \"octopuslabs/k8s-workertools\"\n      }\n\n      environments          = []\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = [\"EKS_Reference_Cluster\"]\n  }\n\n  step {\n    condition           = \"Always\"\n    name                = \"Feedback\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.Script\"\n      name                               = \"Feedback\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      properties                         = {\n        \"Octopus.Action.RunOnServer\"         = \"true\"\n        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"\n        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"\n        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"\n      }\n      environments          = []\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = []\n  }\n}\n\nresource \"octopusdeploy_runbook\" \"runbook_octopub_frontend_scale_to_one\" {\n  count             = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0\n  name              = \"\uD83C\uDF07 Scale Pods to One\"\n  project_id        = octopusdeploy_project.project_octopub_frontend[0].id\n  environment_scope = \"Specified\"\n  environments      = [\n    length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n    length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n    length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n  ]\n  force_package_download      = false\n  default_guided_failure_mode = \"Off\"\n  description                 = <<EOT\n**Action**: Scales the deployment to one pod.\n\n**Affects**: Frontend service - this will create new pods if the deployment has been scaled to zero.\n\nThis runbook is designed to be be run in non-production environments during office hours to recreate the pods after they\nwere shutdown after hours.\nEOT\n  multi_tenancy_mode          = \"Untenanted\"\n\n  retention_policy {\n    quantity_to_keep    = 100\n    should_keep_forever = false\n  }\n\n  connectivity_policy {\n    allow_deployments_to_no_targets = true\n    exclude_unhealthy_targets       = false\n    skip_machine_behavior           = \"None\"\n  }\n}\n\nresource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_frontend_scale_pods_to_one\" {\n  count      = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0\n  runbook_id = octopusdeploy_runbook.runbook_octopub_frontend_scale_to_one[0].id\n\n  step {\n    condition           = \"Success\"\n    name                = \"Scale Pods to One\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.KubernetesRunScript\"\n      name                               = \"Scale Pods to One\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = true\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      worker_pool_variable               = \"\"\n      properties                         = {\n        \"OctopusUseBundledTooling\"           = \"False\"\n        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"\n        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"\n        \"Octopus.Action.Script.ScriptBody\"   = \"kubectl scale --replicas=1 deployment/#{Kubernetes.Deployment.Name}\"\n        \"Octopus.Action.RunOnServer\"         = \"true\"\n      }\n\n      container {\n        feed_id = local.docker_hub_feed_id\n        image   = \"octopuslabs/k8s-workertools\"\n      }\n\n      environments          = []\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = [\"EKS_Reference_Cluster\"]\n  }\n\n  step {\n    condition           = \"Always\"\n    name                = \"Feedback\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.Script\"\n      name                               = \"Feedback\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      properties                         = {\n        \"Octopus.Action.RunOnServer\"         = \"true\"\n        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"\n        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"\n        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"\n      }\n      environments          = []\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = []\n  }\n}\n\nresource \"octopusdeploy_runbook\" \"runbook_octopub_frontend_get_pod_logs\" {\n  count             = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0\n  name              = \"\uD83D\uDEE0\uFE0F Get Pod Logs\"\n  project_id        = octopusdeploy_project.project_octopub_frontend[0].id\n  environment_scope = \"Specified\"\n  environments      = [\n    length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n    length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n    length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n  ]\n  force_package_download      = false\n  default_guided_failure_mode = \"Off\"\n  description                 = <<EOT\n**Action**: Returns the pod logs.\n\n**Affects**: Nothing - this runbook makes no changes.\nEOT\n  multi_tenancy_mode          = \"Untenanted\"\n\n  retention_policy {\n    quantity_to_keep    = 100\n    should_keep_forever = false\n  }\n\n  connectivity_policy {\n    allow_deployments_to_no_targets = true\n    exclude_unhealthy_targets       = false\n    skip_machine_behavior           = \"None\"\n  }\n}\n\nresource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_frontend_get_pod_logs\" {\n  count      = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0\n  runbook_id = octopusdeploy_runbook.runbook_octopub_frontend_get_pod_logs[0].id\n\n  step {\n    condition           = \"Success\"\n    name                = \"Get Pod Logs\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.KubernetesRunScript\"\n      name                               = \"Get Pod Logs\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      worker_pool_variable               = \"\"\n      properties                         = {\n        \"K8SInspectCreateArtifact\"                      = \"False\"\n        \"Octopus.Action.Script.ScriptBody\"              = \"\\u003c#\\n    This script provides a general purpose method for querying Kubernetes resources. It supports common operations\\n    like get, describe, logs and output formats like yaml and json. Output can be captured as artifacts.\\n#\\u003e\\n\\n\\u003c#\\n.Description\\nExecute an application, capturing the output. Based on https://stackoverflow.com/a/33652732/157605\\n#\\u003e\\nFunction Execute-Command ($commandPath, $commandArguments)\\n{\\n  Write-Host \\\"Executing: $commandPath $($commandArguments -join \\\" \\\")\\\"\\n  \\n  Try {\\n    $pinfo = New-Object System.Diagnostics.ProcessStartInfo\\n    $pinfo.FileName = $commandPath\\n    $pinfo.RedirectStandardError = $true\\n    $pinfo.RedirectStandardOutput = $true\\n    $pinfo.UseShellExecute = $false\\n    $pinfo.Arguments = $commandArguments\\n    $p = New-Object System.Diagnostics.Process\\n    $p.StartInfo = $pinfo\\n    $p.Start() | Out-Null\\n    [pscustomobject]@{\\n        stdout = $p.StandardOutput.ReadToEnd()\\n        stderr = $p.StandardError.ReadToEnd()\\n        ExitCode = $p.ExitCode\\n    }\\n    $p.WaitForExit()\\n  }\\n  Catch {\\n     exit\\n  }\\n}\\n\\n\\u003c#\\n.Description\\nFind any resource names that match a wildcard input if one was specified\\n#\\u003e\\nfunction Get-Resources() \\n{\\n    $names = $OctopusParameters[\\\"K8SInspectNames\\\"] -Split \\\"`n\\\" | % {$_.Trim()}\\n    \\n    if ($OctopusParameters[\\\"K8SInspectNames\\\"] -match '\\\\*' )\\n    {\\n        return Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", $OctopusParameters[\\\"K8SInspectResource\\\"])) |\\n            # Select the stdout property from the execution\\n            Select-Object -ExpandProperty stdout |\\n            # Convert the output from JSON\\n            ConvertFrom-JSON | \\n            # Get the items object from the kubectl response\\n            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\\n            # Extract the name\\n            % {$_.metadata.name} |\\n            # Find any matching resources\\n            ? {$k8sName = $_; ($names | ? {$k8sName -like $_}).Count -ne 0}\\n    }\\n    else\\n    {\\n        return $names\\n    }\\n}\\n\\n\\u003c#\\n.Description\\nGet the kubectl arguments for a given action\\n#\\u003e\\nfunction Get-KubectlVerb() \\n{\\n    switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\\n    {\\n        \\\"get json\\\" {return ,@(\\\"-o\\\", \\\"json\\\", \\\"get\\\")}\\n        \\\"get yaml\\\" {return ,@(\\\"-o\\\", \\\"yaml\\\", \\\"get\\\")}\\n        \\\"describe\\\" {return ,@(\\\"describe\\\")}\\n        \\\"logs\\\" {return ,@(\\\"logs\\\")}\\n        \\\"logs tail\\\" {return ,@(\\\"logs\\\", \\\"--tail\\\", \\\"100\\\")}\\n        \\\"previous logs\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\")}\\n        \\\"previous logs tail\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\", \\\"--tail\\\", \\\"100\\\")}\\n        default {return ,@(\\\"get\\\")}\\n    }\\n}\\n\\n\\u003c#\\n.Description\\nGet an appropiate file extension based on the selected action\\n#\\u003e\\nfunction Get-ArtifactExtension() \\n{\\n   switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\\n    {\\n        \\\"get json\\\" {\\\"json\\\"}\\n        \\\"get yaml\\\" {\\\"yaml\\\"}\\n        default {\\\"txt\\\"}\\n    }\\n}\\n\\nif ($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"] -like \\\"*logs*\\\") \\n{\\n    if ( -not @($OctopusParameters[\\\"K8SInspectResource\\\"]) -like \\\"pod*\\\")\\n    {\\n        Write-Error \\\"Logs can only be returned for pods, not $($OctopusParameters[\\\"K8SInspectResource\\\"])\\\"\\n    }\\n    else\\n    {\\n        Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", \\\"pods\\\") + (Get-Resources)) |\\n            # Select the stdout property from the execution\\n            Select-Object -ExpandProperty stdout |\\n            # Convert the output from JSON\\n            ConvertFrom-JSON | \\n            # Get the items object from the kubectl response\\n            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\\n            # Get the pod logs for each container\\n            % {\\n                $podDetails = $_\\n                @{\\n                    logs=$podDetails.spec.containers | % {$logs=\\\"\\\"} {$logs += (Select-Object -InputObject (Execute-Command kubectl ((Get-KubectlVerb) + @($podDetails.metadata.name, \\\"-c\\\", $_.name))) -ExpandProperty stdout)} {$logs}; \\n                    name=$podDetails.metadata.name\\n                }                \\n            } |\\n            # Write the output\\n            % {Write-Host $_.logs; $_} |\\n            # Optionally capture the artifact\\n            % {\\n                if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \\n                {\\n                    Set-Content -Path \\\"$($_.name).$(Get-ArtifactExtension)\\\" -Value $_.logs\\n                    New-OctopusArtifact \\\"$($_.name).$(Get-ArtifactExtension)\\\"\\n                }\\n            }\\n    }      \\n}\\nelse\\n{\\n    Execute-Command kubectl ((Get-KubectlVerb) + @($OctopusParameters[\\\"K8SInspectResource\\\"]) + (Get-Resources)) |\\n        % {Select-Object -InputObject $_ -ExpandProperty stdout} |\\n        % {Write-Host $_; $_} |\\n        % {\\n            if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \\n            {\\n                Set-Content -Path \\\"output.$(Get-ArtifactExtension)\\\" -Value $_\\n                New-OctopusArtifact \\\"output.$(Get-ArtifactExtension)\\\"\\n            }\\n        }\\n}\\n\"\n        \"Octopus.Action.Script.ScriptSource\"            = \"Inline\"\n        \"K8SInspectResource\"                            = \"pod\"\n        \"Octopus.Action.Script.Syntax\"                  = \"PowerShell\"\n        \"Octopus.Action.KubernetesContainers.Namespace\" = \"#{if K8SInspectNamespace}#{K8SInspectNamespace}#{/if}#{unless K8SInspectNamespace}#{Octopus.Action.Kubernetes.Namespace}#{/unless}\"\n        \"K8SInspectNames\"                               = \"#{Kubernetes.Deployment.Name}*\"\n        \"K8SInspectKubectlVerb\"                         = \"logs\"\n      }\n      container {\n        feed_id = local.docker_hub_feed_id\n        image   = \"octopuslabs/k8s-workertools\"\n      }\n      environments = [\n        length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n        length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n        length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n      ]\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = [\"EKS_Reference_Cluster\"]\n  }\n\n  step {\n    condition           = \"Always\"\n    name                = \"Feedback\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.Script\"\n      name                               = \"Feedback\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      properties                         = {\n        \"Octopus.Action.RunOnServer\"         = \"true\"\n        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"\n        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"\n        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"\n      }\n      environments          = []\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = []\n  }\n}\n\nresource \"octopusdeploy_runbook\" \"runbook_octopub_frontend_get_pods\" {\n  count             = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0\n  name              = \"\uD83D\uDEE0\uFE0F Get Pods\"\n  project_id        = octopusdeploy_project.project_octopub_frontend[0].id\n  environment_scope = \"Specified\"\n  environments      = [\n    length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n    length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n    length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n  ]\n  force_package_download      = false\n  default_guided_failure_mode = \"Off\"\n  description                 = <<EOT\n**Action**: Returns the pods.\n\n**Affects**: Nothing - this runbook makes no changes.\nEOT\n  multi_tenancy_mode          = \"Untenanted\"\n\n  retention_policy {\n    quantity_to_keep    = 100\n    should_keep_forever = false\n  }\n\n  connectivity_policy {\n    allow_deployments_to_no_targets = true\n    exclude_unhealthy_targets       = false\n    skip_machine_behavior           = \"None\"\n  }\n}\n\nresource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_frontend_get_pods\" {\n  count      = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0\n  runbook_id = octopusdeploy_runbook.runbook_octopub_frontend_get_pods[0].id\n\n  step {\n    condition           = \"Success\"\n    name                = \"Get Pods\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.KubernetesRunScript\"\n      name                               = \"Get Pods\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = \"\"\n      worker_pool_variable               = \"OctopusInstance.WorkerPool.Id\"\n      properties                         = {\n        \"K8SInspectCreateArtifact\"                      = \"False\"\n        \"Octopus.Action.Script.ScriptBody\"              = \"\\u003c#\\n    This script provides a general purpose method for querying Kubernetes resources. It supports common operations\\n    like get, describe, logs and output formats like yaml and json. Output can be captured as artifacts.\\n#\\u003e\\n\\n\\u003c#\\n.Description\\nExecute an application, capturing the output. Based on https://stackoverflow.com/a/33652732/157605\\n#\\u003e\\nFunction Execute-Command ($commandPath, $commandArguments)\\n{\\n  Write-Host \\\"Executing: $commandPath $($commandArguments -join \\\" \\\")\\\"\\n  \\n  Try {\\n    $pinfo = New-Object System.Diagnostics.ProcessStartInfo\\n    $pinfo.FileName = $commandPath\\n    $pinfo.RedirectStandardError = $true\\n    $pinfo.RedirectStandardOutput = $true\\n    $pinfo.UseShellExecute = $false\\n    $pinfo.Arguments = $commandArguments\\n    $p = New-Object System.Diagnostics.Process\\n    $p.StartInfo = $pinfo\\n    $p.Start() | Out-Null\\n    [pscustomobject]@{\\n        stdout = $p.StandardOutput.ReadToEnd()\\n        stderr = $p.StandardError.ReadToEnd()\\n        ExitCode = $p.ExitCode\\n    }\\n    $p.WaitForExit()\\n  }\\n  Catch {\\n     exit\\n  }\\n}\\n\\n\\u003c#\\n.Description\\nFind any resource names that match a wildcard input if one was specified\\n#\\u003e\\nfunction Get-Resources() \\n{\\n    $names = $OctopusParameters[\\\"K8SInspectNames\\\"] -Split \\\"`n\\\" | % {$_.Trim()}\\n    \\n    if ($OctopusParameters[\\\"K8SInspectNames\\\"] -match '\\\\*' )\\n    {\\n        return Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", $OctopusParameters[\\\"K8SInspectResource\\\"])) |\\n            # Select the stdout property from the execution\\n            Select-Object -ExpandProperty stdout |\\n            # Convert the output from JSON\\n            ConvertFrom-JSON | \\n            # Get the items object from the kubectl response\\n            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\\n            # Extract the name\\n            % {$_.metadata.name} |\\n            # Find any matching resources\\n            ? {$k8sName = $_; ($names | ? {$k8sName -like $_}).Count -ne 0}\\n    }\\n    else\\n    {\\n        return $names\\n    }\\n}\\n\\n\\u003c#\\n.Description\\nGet the kubectl arguments for a given action\\n#\\u003e\\nfunction Get-KubectlVerb() \\n{\\n    switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\\n    {\\n        \\\"get json\\\" {return ,@(\\\"-o\\\", \\\"json\\\", \\\"get\\\")}\\n        \\\"get yaml\\\" {return ,@(\\\"-o\\\", \\\"yaml\\\", \\\"get\\\")}\\n        \\\"describe\\\" {return ,@(\\\"describe\\\")}\\n        \\\"logs\\\" {return ,@(\\\"logs\\\")}\\n        \\\"logs tail\\\" {return ,@(\\\"logs\\\", \\\"--tail\\\", \\\"100\\\")}\\n        \\\"previous logs\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\")}\\n        \\\"previous logs tail\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\", \\\"--tail\\\", \\\"100\\\")}\\n        default {return ,@(\\\"get\\\")}\\n    }\\n}\\n\\n\\u003c#\\n.Description\\nGet an appropiate file extension based on the selected action\\n#\\u003e\\nfunction Get-ArtifactExtension() \\n{\\n   switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\\n    {\\n        \\\"get json\\\" {\\\"json\\\"}\\n        \\\"get yaml\\\" {\\\"yaml\\\"}\\n        default {\\\"txt\\\"}\\n    }\\n}\\n\\nif ($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"] -like \\\"*logs*\\\") \\n{\\n    if ( -not @($OctopusParameters[\\\"K8SInspectResource\\\"]) -like \\\"pod*\\\")\\n    {\\n        Write-Error \\\"Logs can only be returned for pods, not $($OctopusParameters[\\\"K8SInspectResource\\\"])\\\"\\n    }\\n    else\\n    {\\n        Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", \\\"pods\\\") + (Get-Resources)) |\\n            # Select the stdout property from the execution\\n            Select-Object -ExpandProperty stdout |\\n            # Convert the output from JSON\\n            ConvertFrom-JSON | \\n            # Get the items object from the kubectl response\\n            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\\n            # Get the pod logs for each container\\n            % {\\n                $podDetails = $_\\n                @{\\n                    logs=$podDetails.spec.containers | % {$logs=\\\"\\\"} {$logs += (Select-Object -InputObject (Execute-Command kubectl ((Get-KubectlVerb) + @($podDetails.metadata.name, \\\"-c\\\", $_.name))) -ExpandProperty stdout)} {$logs}; \\n                    name=$podDetails.metadata.name\\n                }                \\n            } |\\n            # Write the output\\n            % {Write-Host $_.logs; $_} |\\n            # Optionally capture the artifact\\n            % {\\n                if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \\n                {\\n                    Set-Content -Path \\\"$($_.name).$(Get-ArtifactExtension)\\\" -Value $_.logs\\n                    New-OctopusArtifact \\\"$($_.name).$(Get-ArtifactExtension)\\\"\\n                }\\n            }\\n    }      \\n}\\nelse\\n{\\n    Execute-Command kubectl ((Get-KubectlVerb) + @($OctopusParameters[\\\"K8SInspectResource\\\"]) + (Get-Resources)) |\\n        % {Select-Object -InputObject $_ -ExpandProperty stdout} |\\n        % {Write-Host $_; $_} |\\n        % {\\n            if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \\n            {\\n                Set-Content -Path \\\"output.$(Get-ArtifactExtension)\\\" -Value $_\\n                New-OctopusArtifact \\\"output.$(Get-ArtifactExtension)\\\"\\n            }\\n        }\\n}\\n\"\n        \"Octopus.Action.Script.ScriptSource\"            = \"Inline\"\n        \"K8SInspectResource\"                            = \"pod\"\n        \"Octopus.Action.Script.Syntax\"                  = \"PowerShell\"\n        \"Octopus.Action.KubernetesContainers.Namespace\" = \"#{if K8SInspectNamespace}#{K8SInspectNamespace}#{/if}#{unless K8SInspectNamespace}#{Octopus.Action.Kubernetes.Namespace}#{/unless}\"\n        \"K8SInspectNames\"                               = \"#{Kubernetes.Deployment.Name}*\"\n        \"K8SInspectKubectlVerb\"                         = \"get\"\n      }\n      container {\n        feed_id = local.docker_hub_feed_id\n        image   = \"octopuslabs/k8s-workertools\"\n      }\n      environments = [\n        length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n        length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n        length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n      ]\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = [\"EKS_Reference_Cluster\"]\n  }\n\n  step {\n    condition           = \"Always\"\n    name                = \"Feedback\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.Script\"\n      name                               = \"Feedback\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      properties                         = {\n        \"Octopus.Action.RunOnServer\"         = \"true\"\n        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"\n        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"\n        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"\n      }\n      environments          = []\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = []\n  }\n}\n\nresource \"octopusdeploy_runbook\" \"runbook_octopub_frontend_describe_pods\" {\n  count             = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0\n  name              = \"\uD83D\uDEE0\uFE0F Describe Pods\"\n  project_id        = octopusdeploy_project.project_octopub_frontend[0].id\n  environment_scope = \"Specified\"\n  environments      = [\n    length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n    length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n    length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n  ]\n  force_package_download      = false\n  default_guided_failure_mode = \"Off\"\n  description                 = <<EOT\n**Action**: Returns the pods.\n\n**Affects**: Nothing - this runbook makes no changes.\nEOT\n  multi_tenancy_mode          = \"Untenanted\"\n\n  retention_policy {\n    quantity_to_keep    = 100\n    should_keep_forever = false\n  }\n\n  connectivity_policy {\n    allow_deployments_to_no_targets = true\n    exclude_unhealthy_targets       = false\n    skip_machine_behavior           = \"None\"\n  }\n}\n\nresource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_frontend_describe_pods\" {\n  count      = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0\n  runbook_id = octopusdeploy_runbook.runbook_octopub_frontend_describe_pods[0].id\n\n  step {\n    condition           = \"Success\"\n    name                = \"Describe Pods\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.KubernetesRunScript\"\n      name                               = \"Describe Pods\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      worker_pool_variable               = \"\"\n      properties                         = {\n        \"K8SInspectCreateArtifact\"                      = \"False\"\n        \"Octopus.Action.Script.ScriptBody\"              = \"\\u003c#\\n    This script provides a general purpose method for querying Kubernetes resources. It supports common operations\\n    like get, describe, logs and output formats like yaml and json. Output can be captured as artifacts.\\n#\\u003e\\n\\n\\u003c#\\n.Description\\nExecute an application, capturing the output. Based on https://stackoverflow.com/a/33652732/157605\\n#\\u003e\\nFunction Execute-Command ($commandPath, $commandArguments)\\n{\\n  Write-Host \\\"Executing: $commandPath $($commandArguments -join \\\" \\\")\\\"\\n  \\n  Try {\\n    $pinfo = New-Object System.Diagnostics.ProcessStartInfo\\n    $pinfo.FileName = $commandPath\\n    $pinfo.RedirectStandardError = $true\\n    $pinfo.RedirectStandardOutput = $true\\n    $pinfo.UseShellExecute = $false\\n    $pinfo.Arguments = $commandArguments\\n    $p = New-Object System.Diagnostics.Process\\n    $p.StartInfo = $pinfo\\n    $p.Start() | Out-Null\\n    [pscustomobject]@{\\n        stdout = $p.StandardOutput.ReadToEnd()\\n        stderr = $p.StandardError.ReadToEnd()\\n        ExitCode = $p.ExitCode\\n    }\\n    $p.WaitForExit()\\n  }\\n  Catch {\\n     exit\\n  }\\n}\\n\\n\\u003c#\\n.Description\\nFind any resource names that match a wildcard input if one was specified\\n#\\u003e\\nfunction Get-Resources() \\n{\\n    $names = $OctopusParameters[\\\"K8SInspectNames\\\"] -Split \\\"`n\\\" | % {$_.Trim()}\\n    \\n    if ($OctopusParameters[\\\"K8SInspectNames\\\"] -match '\\\\*' )\\n    {\\n        return Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", $OctopusParameters[\\\"K8SInspectResource\\\"])) |\\n            # Select the stdout property from the execution\\n            Select-Object -ExpandProperty stdout |\\n            # Convert the output from JSON\\n            ConvertFrom-JSON | \\n            # Get the items object from the kubectl response\\n            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\\n            # Extract the name\\n            % {$_.metadata.name} |\\n            # Find any matching resources\\n            ? {$k8sName = $_; ($names | ? {$k8sName -like $_}).Count -ne 0}\\n    }\\n    else\\n    {\\n        return $names\\n    }\\n}\\n\\n\\u003c#\\n.Description\\nGet the kubectl arguments for a given action\\n#\\u003e\\nfunction Get-KubectlVerb() \\n{\\n    switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\\n    {\\n        \\\"get json\\\" {return ,@(\\\"-o\\\", \\\"json\\\", \\\"get\\\")}\\n        \\\"get yaml\\\" {return ,@(\\\"-o\\\", \\\"yaml\\\", \\\"get\\\")}\\n        \\\"describe\\\" {return ,@(\\\"describe\\\")}\\n        \\\"logs\\\" {return ,@(\\\"logs\\\")}\\n        \\\"logs tail\\\" {return ,@(\\\"logs\\\", \\\"--tail\\\", \\\"100\\\")}\\n        \\\"previous logs\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\")}\\n        \\\"previous logs tail\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\", \\\"--tail\\\", \\\"100\\\")}\\n        default {return ,@(\\\"get\\\")}\\n    }\\n}\\n\\n\\u003c#\\n.Description\\nGet an appropiate file extension based on the selected action\\n#\\u003e\\nfunction Get-ArtifactExtension() \\n{\\n   switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\\n    {\\n        \\\"get json\\\" {\\\"json\\\"}\\n        \\\"get yaml\\\" {\\\"yaml\\\"}\\n        default {\\\"txt\\\"}\\n    }\\n}\\n\\nif ($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"] -like \\\"*logs*\\\") \\n{\\n    if ( -not @($OctopusParameters[\\\"K8SInspectResource\\\"]) -like \\\"pod*\\\")\\n    {\\n        Write-Error \\\"Logs can only be returned for pods, not $($OctopusParameters[\\\"K8SInspectResource\\\"])\\\"\\n    }\\n    else\\n    {\\n        Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", \\\"pods\\\") + (Get-Resources)) |\\n            # Select the stdout property from the execution\\n            Select-Object -ExpandProperty stdout |\\n            # Convert the output from JSON\\n            ConvertFrom-JSON | \\n            # Get the items object from the kubectl response\\n            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\\n            # Get the pod logs for each container\\n            % {\\n                $podDetails = $_\\n                @{\\n                    logs=$podDetails.spec.containers | % {$logs=\\\"\\\"} {$logs += (Select-Object -InputObject (Execute-Command kubectl ((Get-KubectlVerb) + @($podDetails.metadata.name, \\\"-c\\\", $_.name))) -ExpandProperty stdout)} {$logs}; \\n                    name=$podDetails.metadata.name\\n                }                \\n            } |\\n            # Write the output\\n            % {Write-Host $_.logs; $_} |\\n            # Optionally capture the artifact\\n            % {\\n                if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \\n                {\\n                    Set-Content -Path \\\"$($_.name).$(Get-ArtifactExtension)\\\" -Value $_.logs\\n                    New-OctopusArtifact \\\"$($_.name).$(Get-ArtifactExtension)\\\"\\n                }\\n            }\\n    }      \\n}\\nelse\\n{\\n    Execute-Command kubectl ((Get-KubectlVerb) + @($OctopusParameters[\\\"K8SInspectResource\\\"]) + (Get-Resources)) |\\n        % {Select-Object -InputObject $_ -ExpandProperty stdout} |\\n        % {Write-Host $_; $_} |\\n        % {\\n            if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \\n            {\\n                Set-Content -Path \\\"output.$(Get-ArtifactExtension)\\\" -Value $_\\n                New-OctopusArtifact \\\"output.$(Get-ArtifactExtension)\\\"\\n            }\\n        }\\n}\\n\"\n        \"Octopus.Action.Script.ScriptSource\"            = \"Inline\"\n        \"K8SInspectResource\"                            = \"pod\"\n        \"Octopus.Action.Script.Syntax\"                  = \"PowerShell\"\n        \"Octopus.Action.KubernetesContainers.Namespace\" = \"#{if K8SInspectNamespace}#{K8SInspectNamespace}#{/if}#{unless K8SInspectNamespace}#{Octopus.Action.Kubernetes.Namespace}#{/unless}\"\n        \"K8SInspectNames\"                               = \"#{Kubernetes.Deployment.Name}*\"\n        \"K8SInspectKubectlVerb\"                         = \"describe\"\n      }\n      container {\n        feed_id = local.docker_hub_feed_id\n        image   = \"octopuslabs/k8s-workertools\"\n      }\n      environments = [\n        length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n        length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n        length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n      ]\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = [\"EKS_Reference_Cluster\"]\n  }\n\n  step {\n    condition           = \"Always\"\n    name                = \"Feedback\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.Script\"\n      name                               = \"Feedback\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      properties                         = {\n        \"Octopus.Action.RunOnServer\"         = \"true\"\n        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"\n        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"\n        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"\n      }\n      environments          = []\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = []\n  }\n}\n\nresource \"octopusdeploy_runbook\" \"runbook_octopub_frontend_get_ingress\" {\n  count             = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0\n  name              = \"\uD83D\uDEE0\uFE0F Get Ingress\"\n  project_id        = octopusdeploy_project.project_octopub_frontend[0].id\n  environment_scope = \"Specified\"\n  environments      = [\n    length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n    length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n    length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n  ]\n  force_package_download      = false\n  default_guided_failure_mode = \"Off\"\n  description                 = <<EOT\n**Action**: Returns the ingresses.\n\n**Affects**: Nothing - this runbook makes no changes.\n\n**Resolves**: Finding the public IP to access the deployed application.\nEOT\n  multi_tenancy_mode          = \"Untenanted\"\n\n  retention_policy {\n    quantity_to_keep    = 100\n    should_keep_forever = false\n  }\n\n  connectivity_policy {\n    allow_deployments_to_no_targets = true\n    exclude_unhealthy_targets       = false\n    skip_machine_behavior           = \"None\"\n  }\n}\n\nresource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_frontend_get_ingress\" {\n  count      = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0\n  runbook_id = octopusdeploy_runbook.runbook_octopub_frontend_get_ingress[0].id\n\n  step {\n    condition           = \"Success\"\n    name                = \"Get Ingress\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.KubernetesRunScript\"\n      name                               = \"Get Ingress\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      worker_pool_variable               = \"\"\n      properties                         = {\n        \"K8SInspectCreateArtifact\"                      = \"False\"\n        \"Octopus.Action.Script.ScriptBody\"              = \"\\u003c#\\n    This script provides a general purpose method for querying Kubernetes resources. It supports common operations\\n    like get, describe, logs and output formats like yaml and json. Output can be captured as artifacts.\\n#\\u003e\\n\\n\\u003c#\\n.Description\\nExecute an application, capturing the output. Based on https://stackoverflow.com/a/33652732/157605\\n#\\u003e\\nFunction Execute-Command ($commandPath, $commandArguments)\\n{\\n  Write-Host \\\"Executing: $commandPath $($commandArguments -join \\\" \\\")\\\"\\n  \\n  Try {\\n    $pinfo = New-Object System.Diagnostics.ProcessStartInfo\\n    $pinfo.FileName = $commandPath\\n    $pinfo.RedirectStandardError = $true\\n    $pinfo.RedirectStandardOutput = $true\\n    $pinfo.UseShellExecute = $false\\n    $pinfo.Arguments = $commandArguments\\n    $p = New-Object System.Diagnostics.Process\\n    $p.StartInfo = $pinfo\\n    $p.Start() | Out-Null\\n    [pscustomobject]@{\\n        stdout = $p.StandardOutput.ReadToEnd()\\n        stderr = $p.StandardError.ReadToEnd()\\n        ExitCode = $p.ExitCode\\n    }\\n    $p.WaitForExit()\\n  }\\n  Catch {\\n     exit\\n  }\\n}\\n\\n\\u003c#\\n.Description\\nFind any resource names that match a wildcard input if one was specified\\n#\\u003e\\nfunction Get-Resources() \\n{\\n    $names = $OctopusParameters[\\\"K8SInspectNames\\\"] -Split \\\"`n\\\" | % {$_.Trim()}\\n    \\n    if ($OctopusParameters[\\\"K8SInspectNames\\\"] -match '\\\\*' )\\n    {\\n        return Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", $OctopusParameters[\\\"K8SInspectResource\\\"])) |\\n            # Select the stdout property from the execution\\n            Select-Object -ExpandProperty stdout |\\n            # Convert the output from JSON\\n            ConvertFrom-JSON | \\n            # Get the items object from the kubectl response\\n            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\\n            # Extract the name\\n            % {$_.metadata.name} |\\n            # Find any matching resources\\n            ? {$k8sName = $_; ($names | ? {$k8sName -like $_}).Count -ne 0}\\n    }\\n    else\\n    {\\n        return $names\\n    }\\n}\\n\\n\\u003c#\\n.Description\\nGet the kubectl arguments for a given action\\n#\\u003e\\nfunction Get-KubectlVerb() \\n{\\n    switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\\n    {\\n        \\\"get json\\\" {return ,@(\\\"-o\\\", \\\"json\\\", \\\"get\\\")}\\n        \\\"get yaml\\\" {return ,@(\\\"-o\\\", \\\"yaml\\\", \\\"get\\\")}\\n        \\\"describe\\\" {return ,@(\\\"describe\\\")}\\n        \\\"logs\\\" {return ,@(\\\"logs\\\")}\\n        \\\"logs tail\\\" {return ,@(\\\"logs\\\", \\\"--tail\\\", \\\"100\\\")}\\n        \\\"previous logs\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\")}\\n        \\\"previous logs tail\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\", \\\"--tail\\\", \\\"100\\\")}\\n        default {return ,@(\\\"get\\\")}\\n    }\\n}\\n\\n\\u003c#\\n.Description\\nGet an appropiate file extension based on the selected action\\n#\\u003e\\nfunction Get-ArtifactExtension() \\n{\\n   switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\\n    {\\n        \\\"get json\\\" {\\\"json\\\"}\\n        \\\"get yaml\\\" {\\\"yaml\\\"}\\n        default {\\\"txt\\\"}\\n    }\\n}\\n\\nif ($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"] -like \\\"*logs*\\\") \\n{\\n    if ( -not @($OctopusParameters[\\\"K8SInspectResource\\\"]) -like \\\"pod*\\\")\\n    {\\n        Write-Error \\\"Logs can only be returned for pods, not $($OctopusParameters[\\\"K8SInspectResource\\\"])\\\"\\n    }\\n    else\\n    {\\n        Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", \\\"pods\\\") + (Get-Resources)) |\\n            # Select the stdout property from the execution\\n            Select-Object -ExpandProperty stdout |\\n            # Convert the output from JSON\\n            ConvertFrom-JSON | \\n            # Get the items object from the kubectl response\\n            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\\n            # Get the pod logs for each container\\n            % {\\n                $podDetails = $_\\n                @{\\n                    logs=$podDetails.spec.containers | % {$logs=\\\"\\\"} {$logs += (Select-Object -InputObject (Execute-Command kubectl ((Get-KubectlVerb) + @($podDetails.metadata.name, \\\"-c\\\", $_.name))) -ExpandProperty stdout)} {$logs}; \\n                    name=$podDetails.metadata.name\\n                }                \\n            } |\\n            # Write the output\\n            % {Write-Host $_.logs; $_} |\\n            # Optionally capture the artifact\\n            % {\\n                if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \\n                {\\n                    Set-Content -Path \\\"$($_.name).$(Get-ArtifactExtension)\\\" -Value $_.logs\\n                    New-OctopusArtifact \\\"$($_.name).$(Get-ArtifactExtension)\\\"\\n                }\\n            }\\n    }      \\n}\\nelse\\n{\\n    Execute-Command kubectl ((Get-KubectlVerb) + @($OctopusParameters[\\\"K8SInspectResource\\\"]) + (Get-Resources)) |\\n        % {Select-Object -InputObject $_ -ExpandProperty stdout} |\\n        % {Write-Host $_; $_} |\\n        % {\\n            if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \\n            {\\n                Set-Content -Path \\\"output.$(Get-ArtifactExtension)\\\" -Value $_\\n                New-OctopusArtifact \\\"output.$(Get-ArtifactExtension)\\\"\\n            }\\n        }\\n}\\n\"\n        \"Octopus.Action.Script.ScriptSource\"            = \"Inline\"\n        \"K8SInspectResource\"                            = \"ingress\"\n        \"Octopus.Action.Script.Syntax\"                  = \"PowerShell\"\n        \"Octopus.Action.KubernetesContainers.Namespace\" = \"#{if K8SInspectNamespace}#{K8SInspectNamespace}#{/if}#{unless K8SInspectNamespace}#{Octopus.Action.Kubernetes.Namespace}#{/unless}\"\n        \"K8SInspectNames\"                               = \"#{Kubernetes.Ingress.Name}*\"\n        \"K8SInspectKubectlVerb\"                         = \"get\"\n      }\n      container {\n        feed_id = local.docker_hub_feed_id\n        image   = \"octopuslabs/k8s-workertools\"\n      }\n      environments = [\n        length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n        length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n        length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n      ]\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = [\"EKS_Reference_Cluster\"]\n  }\n\n  step {\n    condition           = \"Always\"\n    name                = \"Feedback\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.Script\"\n      name                               = \"Feedback\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      properties                         = {\n        \"Octopus.Action.RunOnServer\"         = \"true\"\n        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"\n        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"\n        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"\n      }\n      environments          = []\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = []\n  }\n}\n\nresource \"octopusdeploy_runbook\" \"runbook_octopub_frontend_get_service\" {\n  count             = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0\n  name              = \"\uD83D\uDEE0\uFE0F Get Service\"\n  project_id        = octopusdeploy_project.project_octopub_frontend[0].id\n  environment_scope = \"Specified\"\n  environments      = [\n    length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n    length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n    length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n  ]\n  force_package_download      = false\n  default_guided_failure_mode = \"Off\"\n  description                 = <<EOT\n**Action**: Returns the services.\n\n**Affects**: Nothing - this runbook makes no changes.\nEOT\n  multi_tenancy_mode          = \"Untenanted\"\n\n  retention_policy {\n    quantity_to_keep    = 100\n    should_keep_forever = false\n  }\n\n  connectivity_policy {\n    allow_deployments_to_no_targets = true\n    exclude_unhealthy_targets       = false\n    skip_machine_behavior           = \"None\"\n  }\n}\n\nresource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_frontend_get_service\" {\n  count      = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0\n  runbook_id = octopusdeploy_runbook.runbook_octopub_frontend_get_service[0].id\n\n  step {\n    condition           = \"Success\"\n    name                = \"Get Service\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.KubernetesRunScript\"\n      name                               = \"Get Service\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      worker_pool_variable               = \"\"\n      properties                         = {\n        \"K8SInspectCreateArtifact\"                      = \"False\"\n        \"Octopus.Action.Script.ScriptBody\"              = \"\\u003c#\\n    This script provides a general purpose method for querying Kubernetes resources. It supports common operations\\n    like get, describe, logs and output formats like yaml and json. Output can be captured as artifacts.\\n#\\u003e\\n\\n\\u003c#\\n.Description\\nExecute an application, capturing the output. Based on https://stackoverflow.com/a/33652732/157605\\n#\\u003e\\nFunction Execute-Command ($commandPath, $commandArguments)\\n{\\n  Write-Host \\\"Executing: $commandPath $($commandArguments -join \\\" \\\")\\\"\\n  \\n  Try {\\n    $pinfo = New-Object System.Diagnostics.ProcessStartInfo\\n    $pinfo.FileName = $commandPath\\n    $pinfo.RedirectStandardError = $true\\n    $pinfo.RedirectStandardOutput = $true\\n    $pinfo.UseShellExecute = $false\\n    $pinfo.Arguments = $commandArguments\\n    $p = New-Object System.Diagnostics.Process\\n    $p.StartInfo = $pinfo\\n    $p.Start() | Out-Null\\n    [pscustomobject]@{\\n        stdout = $p.StandardOutput.ReadToEnd()\\n        stderr = $p.StandardError.ReadToEnd()\\n        ExitCode = $p.ExitCode\\n    }\\n    $p.WaitForExit()\\n  }\\n  Catch {\\n     exit\\n  }\\n}\\n\\n\\u003c#\\n.Description\\nFind any resource names that match a wildcard input if one was specified\\n#\\u003e\\nfunction Get-Resources() \\n{\\n    $names = $OctopusParameters[\\\"K8SInspectNames\\\"] -Split \\\"`n\\\" | % {$_.Trim()}\\n    \\n    if ($OctopusParameters[\\\"K8SInspectNames\\\"] -match '\\\\*' )\\n    {\\n        return Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", $OctopusParameters[\\\"K8SInspectResource\\\"])) |\\n            # Select the stdout property from the execution\\n            Select-Object -ExpandProperty stdout |\\n            # Convert the output from JSON\\n            ConvertFrom-JSON | \\n            # Get the items object from the kubectl response\\n            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\\n            # Extract the name\\n            % {$_.metadata.name} |\\n            # Find any matching resources\\n            ? {$k8sName = $_; ($names | ? {$k8sName -like $_}).Count -ne 0}\\n    }\\n    else\\n    {\\n        return $names\\n    }\\n}\\n\\n\\u003c#\\n.Description\\nGet the kubectl arguments for a given action\\n#\\u003e\\nfunction Get-KubectlVerb() \\n{\\n    switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\\n    {\\n        \\\"get json\\\" {return ,@(\\\"-o\\\", \\\"json\\\", \\\"get\\\")}\\n        \\\"get yaml\\\" {return ,@(\\\"-o\\\", \\\"yaml\\\", \\\"get\\\")}\\n        \\\"describe\\\" {return ,@(\\\"describe\\\")}\\n        \\\"logs\\\" {return ,@(\\\"logs\\\")}\\n        \\\"logs tail\\\" {return ,@(\\\"logs\\\", \\\"--tail\\\", \\\"100\\\")}\\n        \\\"previous logs\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\")}\\n        \\\"previous logs tail\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\", \\\"--tail\\\", \\\"100\\\")}\\n        default {return ,@(\\\"get\\\")}\\n    }\\n}\\n\\n\\u003c#\\n.Description\\nGet an appropiate file extension based on the selected action\\n#\\u003e\\nfunction Get-ArtifactExtension() \\n{\\n   switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\\n    {\\n        \\\"get json\\\" {\\\"json\\\"}\\n        \\\"get yaml\\\" {\\\"yaml\\\"}\\n        default {\\\"txt\\\"}\\n    }\\n}\\n\\nif ($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"] -like \\\"*logs*\\\") \\n{\\n    if ( -not @($OctopusParameters[\\\"K8SInspectResource\\\"]) -like \\\"pod*\\\")\\n    {\\n        Write-Error \\\"Logs can only be returned for pods, not $($OctopusParameters[\\\"K8SInspectResource\\\"])\\\"\\n    }\\n    else\\n    {\\n        Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", \\\"pods\\\") + (Get-Resources)) |\\n            # Select the stdout property from the execution\\n            Select-Object -ExpandProperty stdout |\\n            # Convert the output from JSON\\n            ConvertFrom-JSON | \\n            # Get the items object from the kubectl response\\n            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\\n            # Get the pod logs for each container\\n            % {\\n                $podDetails = $_\\n                @{\\n                    logs=$podDetails.spec.containers | % {$logs=\\\"\\\"} {$logs += (Select-Object -InputObject (Execute-Command kubectl ((Get-KubectlVerb) + @($podDetails.metadata.name, \\\"-c\\\", $_.name))) -ExpandProperty stdout)} {$logs}; \\n                    name=$podDetails.metadata.name\\n                }                \\n            } |\\n            # Write the output\\n            % {Write-Host $_.logs; $_} |\\n            # Optionally capture the artifact\\n            % {\\n                if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \\n                {\\n                    Set-Content -Path \\\"$($_.name).$(Get-ArtifactExtension)\\\" -Value $_.logs\\n                    New-OctopusArtifact \\\"$($_.name).$(Get-ArtifactExtension)\\\"\\n                }\\n            }\\n    }      \\n}\\nelse\\n{\\n    Execute-Command kubectl ((Get-KubectlVerb) + @($OctopusParameters[\\\"K8SInspectResource\\\"]) + (Get-Resources)) |\\n        % {Select-Object -InputObject $_ -ExpandProperty stdout} |\\n        % {Write-Host $_; $_} |\\n        % {\\n            if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \\n            {\\n                Set-Content -Path \\\"output.$(Get-ArtifactExtension)\\\" -Value $_\\n                New-OctopusArtifact \\\"output.$(Get-ArtifactExtension)\\\"\\n            }\\n        }\\n}\\n\"\n        \"Octopus.Action.Script.ScriptSource\"            = \"Inline\"\n        \"K8SInspectResource\"                            = \"service\"\n        \"Octopus.Action.Script.Syntax\"                  = \"PowerShell\"\n        \"Octopus.Action.KubernetesContainers.Namespace\" = \"#{if K8SInspectNamespace}#{K8SInspectNamespace}#{/if}#{unless K8SInspectNamespace}#{Octopus.Action.Kubernetes.Namespace}#{/unless}\"\n        \"K8SInspectNames\"                               = \"#{Kubernetes.Service.Name}*\"\n        \"K8SInspectKubectlVerb\"                         = \"get\"\n      }\n      container {\n        feed_id = local.docker_hub_feed_id\n        image   = \"octopuslabs/k8s-workertools\"\n      }\n      environments = [\n        length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n        length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n        length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n      ]\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = [\"EKS_Reference_Cluster\"]\n  }\n\n  step {\n    condition           = \"Always\"\n    name                = \"Feedback\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.Script\"\n      name                               = \"Feedback\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      properties                         = {\n        \"Octopus.Action.RunOnServer\"         = \"true\"\n        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"\n        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"\n        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"\n      }\n      environments          = []\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = []\n  }\n}\n\nresource \"octopusdeploy_runbook\" \"runbook_octopub_frontend_get_deployment\" {\n  count             = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0\n  name              = \"\uD83D\uDEE0\uFE0F Get Deployment\"\n  project_id        = octopusdeploy_project.project_octopub_frontend[0].id\n  environment_scope = \"Specified\"\n  environments      = [\n    length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n    length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n    length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n  ]\n  force_package_download      = false\n  default_guided_failure_mode = \"Off\"\n  description                 = <<EOT\n**Action**: Returns the deployments.\n\n**Affects**: Nothing - this runbook makes no changes.\nEOT\n  multi_tenancy_mode          = \"Untenanted\"\n\n  retention_policy {\n    quantity_to_keep    = 100\n    should_keep_forever = false\n  }\n\n  connectivity_policy {\n    allow_deployments_to_no_targets = true\n    exclude_unhealthy_targets       = false\n    skip_machine_behavior           = \"None\"\n  }\n}\n\nresource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_frontend_get_deployment\" {\n  count      = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? 1 : 0\n  runbook_id = octopusdeploy_runbook.runbook_octopub_frontend_get_deployment[0].id\n\n  step {\n    condition           = \"Success\"\n    name                = \"Get Deployment\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.KubernetesRunScript\"\n      name                               = \"Get Deployment\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      worker_pool_variable               = \"\"\n      properties                         = {\n        \"K8SInspectCreateArtifact\"                      = \"False\"\n        \"Octopus.Action.Script.ScriptBody\"              = \"\\u003c#\\n    This script provides a general purpose method for querying Kubernetes resources. It supports common operations\\n    like get, describe, logs and output formats like yaml and json. Output can be captured as artifacts.\\n#\\u003e\\n\\n\\u003c#\\n.Description\\nExecute an application, capturing the output. Based on https://stackoverflow.com/a/33652732/157605\\n#\\u003e\\nFunction Execute-Command ($commandPath, $commandArguments)\\n{\\n  Write-Host \\\"Executing: $commandPath $($commandArguments -join \\\" \\\")\\\"\\n  \\n  Try {\\n    $pinfo = New-Object System.Diagnostics.ProcessStartInfo\\n    $pinfo.FileName = $commandPath\\n    $pinfo.RedirectStandardError = $true\\n    $pinfo.RedirectStandardOutput = $true\\n    $pinfo.UseShellExecute = $false\\n    $pinfo.Arguments = $commandArguments\\n    $p = New-Object System.Diagnostics.Process\\n    $p.StartInfo = $pinfo\\n    $p.Start() | Out-Null\\n    [pscustomobject]@{\\n        stdout = $p.StandardOutput.ReadToEnd()\\n        stderr = $p.StandardError.ReadToEnd()\\n        ExitCode = $p.ExitCode\\n    }\\n    $p.WaitForExit()\\n  }\\n  Catch {\\n     exit\\n  }\\n}\\n\\n\\u003c#\\n.Description\\nFind any resource names that match a wildcard input if one was specified\\n#\\u003e\\nfunction Get-Resources() \\n{\\n    $names = $OctopusParameters[\\\"K8SInspectNames\\\"] -Split \\\"`n\\\" | % {$_.Trim()}\\n    \\n    if ($OctopusParameters[\\\"K8SInspectNames\\\"] -match '\\\\*' )\\n    {\\n        return Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", $OctopusParameters[\\\"K8SInspectResource\\\"])) |\\n            # Select the stdout property from the execution\\n            Select-Object -ExpandProperty stdout |\\n            # Convert the output from JSON\\n            ConvertFrom-JSON | \\n            # Get the items object from the kubectl response\\n            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\\n            # Extract the name\\n            % {$_.metadata.name} |\\n            # Find any matching resources\\n            ? {$k8sName = $_; ($names | ? {$k8sName -like $_}).Count -ne 0}\\n    }\\n    else\\n    {\\n        return $names\\n    }\\n}\\n\\n\\u003c#\\n.Description\\nGet the kubectl arguments for a given action\\n#\\u003e\\nfunction Get-KubectlVerb() \\n{\\n    switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\\n    {\\n        \\\"get json\\\" {return ,@(\\\"-o\\\", \\\"json\\\", \\\"get\\\")}\\n        \\\"get yaml\\\" {return ,@(\\\"-o\\\", \\\"yaml\\\", \\\"get\\\")}\\n        \\\"describe\\\" {return ,@(\\\"describe\\\")}\\n        \\\"logs\\\" {return ,@(\\\"logs\\\")}\\n        \\\"logs tail\\\" {return ,@(\\\"logs\\\", \\\"--tail\\\", \\\"100\\\")}\\n        \\\"previous logs\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\")}\\n        \\\"previous logs tail\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\", \\\"--tail\\\", \\\"100\\\")}\\n        default {return ,@(\\\"get\\\")}\\n    }\\n}\\n\\n\\u003c#\\n.Description\\nGet an appropiate file extension based on the selected action\\n#\\u003e\\nfunction Get-ArtifactExtension() \\n{\\n   switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\\n    {\\n        \\\"get json\\\" {\\\"json\\\"}\\n        \\\"get yaml\\\" {\\\"yaml\\\"}\\n        default {\\\"txt\\\"}\\n    }\\n}\\n\\nif ($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"] -like \\\"*logs*\\\") \\n{\\n    if ( -not @($OctopusParameters[\\\"K8SInspectResource\\\"]) -like \\\"pod*\\\")\\n    {\\n        Write-Error \\\"Logs can only be returned for pods, not $($OctopusParameters[\\\"K8SInspectResource\\\"])\\\"\\n    }\\n    else\\n    {\\n        Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", \\\"pods\\\") + (Get-Resources)) |\\n            # Select the stdout property from the execution\\n            Select-Object -ExpandProperty stdout |\\n            # Convert the output from JSON\\n            ConvertFrom-JSON | \\n            # Get the items object from the kubectl response\\n            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\\n            # Get the pod logs for each container\\n            % {\\n                $podDetails = $_\\n                @{\\n                    logs=$podDetails.spec.containers | % {$logs=\\\"\\\"} {$logs += (Select-Object -InputObject (Execute-Command kubectl ((Get-KubectlVerb) + @($podDetails.metadata.name, \\\"-c\\\", $_.name))) -ExpandProperty stdout)} {$logs}; \\n                    name=$podDetails.metadata.name\\n                }                \\n            } |\\n            # Write the output\\n            % {Write-Host $_.logs; $_} |\\n            # Optionally capture the artifact\\n            % {\\n                if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \\n                {\\n                    Set-Content -Path \\\"$($_.name).$(Get-ArtifactExtension)\\\" -Value $_.logs\\n                    New-OctopusArtifact \\\"$($_.name).$(Get-ArtifactExtension)\\\"\\n                }\\n            }\\n    }      \\n}\\nelse\\n{\\n    Execute-Command kubectl ((Get-KubectlVerb) + @($OctopusParameters[\\\"K8SInspectResource\\\"]) + (Get-Resources)) |\\n        % {Select-Object -InputObject $_ -ExpandProperty stdout} |\\n        % {Write-Host $_; $_} |\\n        % {\\n            if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \\n            {\\n                Set-Content -Path \\\"output.$(Get-ArtifactExtension)\\\" -Value $_\\n                New-OctopusArtifact \\\"output.$(Get-ArtifactExtension)\\\"\\n            }\\n        }\\n}\\n\"\n        \"Octopus.Action.Script.ScriptSource\"            = \"Inline\"\n        \"K8SInspectResource\"                            = \"deployment\"\n        \"Octopus.Action.Script.Syntax\"                  = \"PowerShell\"\n        \"Octopus.Action.KubernetesContainers.Namespace\" = \"#{if K8SInspectNamespace}#{K8SInspectNamespace}#{/if}#{unless K8SInspectNamespace}#{Octopus.Action.Kubernetes.Namespace}#{/unless}\"\n        \"K8SInspectNames\"                               = \"#{Kubernetes.Deployment.Name}*\"\n        \"K8SInspectKubectlVerb\"                         = \"get\"\n      }\n      container {\n        feed_id = local.docker_hub_feed_id\n        image   = \"octopuslabs/k8s-workertools\"\n      }\n      environments = [\n        length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n        length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n        length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n      ]\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = [\"EKS_Reference_Cluster\"]\n  }\n\n  step {\n    condition           = \"Always\"\n    name                = \"Feedback\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.Script\"\n      name                               = \"Feedback\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      properties                         = {\n        \"Octopus.Action.RunOnServer\"         = \"true\"\n        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"\n        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"\n        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"\n      }\n      environments          = []\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = []\n  }\n}\n#endregion\n\n#region Products\ndata \"octopusdeploy_projects\" \"octopub_products\" {\n  partial_name = \"EKS Octopub Products\"\n  skip         = 0\n  take         = 1\n}\n\nresource \"octopusdeploy_variable\" \"products_deployment_feed\" {\n  count        = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0\n  owner_id     = octopusdeploy_project.project_octopub_products[0].id\n  value        = local.docker_hub_feed_id\n  name         = \"Kubernetes.Deployment.Feed\"\n  type         = \"String\"\n  description  = \"The feed ID hosting the image\"\n  is_sensitive = false\n}\n\nresource \"octopusdeploy_variable\" \"products_deployment_image\" {\n  count        = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0\n  owner_id     = octopusdeploy_project.project_octopub_products[0].id\n  value        = \"octopussamples/octopub-products-microservice\"\n  name         = \"Kubernetes.Deployment.Image\"\n  type         = \"String\"\n  description  = \"The image to deploy\"\n  is_sensitive = false\n}\n\nresource \"octopusdeploy_variable\" \"products_deployment_port\" {\n  count        = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0\n  owner_id     = octopusdeploy_project.project_octopub_products[0].id\n  value        = \"8083\"\n  name         = \"Kubernetes.Deployment.Port\"\n  type         = \"String\"\n  description  = \"The port exposed by the web app\"\n  is_sensitive = false\n}\n\nresource \"octopusdeploy_variable\" \"products_deployment_name\" {\n  count        = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0\n  owner_id     = octopusdeploy_project.project_octopub_products[0].id\n  value        = \"products\"\n  name         = \"Kubernetes.Deployment.Name\"\n  type         = \"String\"\n  description  = \"The name of the Kubernetes deployment resource\"\n  is_sensitive = false\n  depends_on   = []\n}\n\nresource \"octopusdeploy_variable\" \"products_service_name\" {\n  count        = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0\n  owner_id     = octopusdeploy_project.project_octopub_products[0].id\n  value        = \"products\"\n  name         = \"Kubernetes.Service.Name\"\n  type         = \"String\"\n  description  = \"The name of the Kubernetes service resource\"\n  is_sensitive = false\n  depends_on   = []\n}\n\nresource \"octopusdeploy_variable\" \"products_ingress_name\" {\n  count        = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0\n  owner_id     = octopusdeploy_project.project_octopub_products[0].id\n  value        = \"products\"\n  name         = \"Kubernetes.Ingress.Name\"\n  type         = \"String\"\n  description  = \"The name of the Kubernetes ingress resource\"\n  is_sensitive = false\n  depends_on   = []\n}\n\nresource \"octopusdeploy_project\" \"project_octopub_products\" {\n  count                                = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0\n  name                                 = \"EKS Octopub Products\"\n  auto_create_release                  = false\n  default_guided_failure_mode          = \"Off\"\n  default_to_skip_if_already_installed = false\n  discrete_channel_release             = false\n  is_disabled                          = false\n  is_version_controlled                = false\n  lifecycle_id                         = length(data.octopusdeploy_lifecycles.devsecops.lifecycles) == 0 ? octopusdeploy_lifecycle.lifecycle_devsecops[0].id : data.octopusdeploy_lifecycles.devsecops.lifecycles[0].id\n  project_group_id                     = length(data.octopusdeploy_project_groups.eks.project_groups) == 0 ? octopusdeploy_project_group.project_group_eks[0].id : data.octopusdeploy_project_groups.eks.project_groups[0].id\n  included_library_variable_sets       = []\n  tenanted_deployment_participation    = \"Untenanted\"\n\n  connectivity_policy {\n    allow_deployments_to_no_targets = true\n    exclude_unhealthy_targets       = false\n    skip_machine_behavior           = \"None\"\n  }\n\n  versioning_strategy {\n    template = \"#{Octopus.Version.LastMajor}.#{Octopus.Version.LastMinor}.#{Octopus.Version.NextPatch}\"\n  }\n\n  lifecycle {\n    ignore_changes = []\n  }\n  description = <<EOT\nDeploys the Octopub Products Service\n\n**Source**: [GitHub](https://github.com/OctopusSolutionsEngineering/Octopub)\n\n**Build**: [GitHub Actions](https://github.com/OctopusSolutionsEngineering/Octopub/actions)\n\n**Issues**: [GitHub Issues](https://github.com/OctopusSolutionsEngineering/Octopub/issues)\nEOT\n}\n\nresource \"octopusdeploy_deployment_process\" \"deployment_process_octopub_products\" {\n  count      = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0\n  project_id = octopusdeploy_project.project_octopub_products[0].id\n\n  step {\n    condition           = \"Success\"\n    name                = \"Deploy Container\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.KubernetesDeployContainers\"\n      name                               = \"Deploy Container\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = true\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      properties                         = {\n        \"Octopus.Action.KubernetesContainers.Replicas\"               = \"1\"\n        \"Octopus.Action.KubernetesContainers.DeploymentResourceType\" = \"Deployment\"\n        \"Octopus.Action.KubernetesContainers.IngressAnnotations\"     = jsonencode([\n          {\n            \"optionError\"  = null\n            \"option2\"      = \"\"\n            \"option2Error\" = null\n            \"key\"          = \"nginx.ingress.kubernetes.io/rewrite-target\"\n            \"keyError\"     = null\n            \"value\"        = \"$1$2\"\n            \"valueError\"   = null\n            \"option\"       = \"\"\n          },\n          {\n            \"keyError\"     = null\n            \"value\"        = \"true\"\n            \"valueError\"   = null\n            \"option\"       = \"\"\n            \"optionError\"  = null\n            \"option2\"      = \"\"\n            \"option2Error\" = null\n            \"key\"          = \"nginx.ingress.kubernetes.io/use-regex\"\n          },\n        ])\n        \"Octopus.Action.KubernetesContainers.DeploymentStyle\" = \"RollingUpdate\"\n        \"Octopus.Action.KubernetesContainers.IngressName\"     = \"#{Kubernetes.Ingress.Name}\"\n        \"Octopus.Action.KubernetesContainers.DeploymentName\"  = \"#{Kubernetes.Deployment.Name}\"\n        \"Octopus.Action.KubernetesContainers.IngressRules\"    = jsonencode([\n          {\n            \"host\" = \"\"\n            \"http\" = {\n              \"paths\" = [\n                {\n                  \"key\"     = \"/#{Octopus.Action.Kubernetes.Namespace}(/api/products)(/.*)?\"\n                  \"value\"   = \"web\"\n                  \"option\"  = \"\"\n                  \"option2\" = \"ImplementationSpecific\"\n                },\n              ]\n            }\n          },\n        ])\n        \"OctopusUseBundledTooling\"                       = \"False\"\n        \"Octopus.Action.KubernetesContainers.Containers\" = jsonencode([\n          {\n            \"Args\"                         = []\n            \"FieldRefEnvironmentVariables\" = []\n            \"SecretEnvFromSource\"          = []\n            \"Command\"                      = []\n            \"Ports\"                        = [\n              {\n                \"option2Error\" = null\n                \"optionError\"  = null\n                \"value\"        = \"#{Kubernetes.Deployment.Port}\"\n                \"valueError\"   = null\n                \"key\"          = \"web\"\n                \"keyError\"     = null\n                \"option\"       = \"TCP\"\n                \"option2\"      = \"\"\n              },\n            ]\n            \"Resources\" = {\n              \"limits\" = {\n                \"storage\"          = \"\"\n                \"amdGpu\"           = \"\"\n                \"cpu\"              = \"\"\n                \"ephemeralStorage\" = \"\"\n                \"memory\"           = \"\"\n                \"nvidiaGpu\"        = \"\"\n              }\n              \"requests\" = {\n                \"amdGpu\"           = \"\"\n                \"cpu\"              = \"\"\n                \"ephemeralStorage\" = \"\"\n                \"memory\"           = \"\"\n                \"nvidiaGpu\"        = \"\"\n                \"storage\"          = \"\"\n              }\n            }\n            \"SecretEnvironmentVariables\" = []\n            \"SecurityContext\"            = {\n              \"runAsNonRoot\"   = \"True\"\n              \"runAsUser\"      = \"\"\n              \"seLinuxOptions\" = {\n                \"level\" = \"\"\n                \"role\"  = \"\"\n                \"type\"  = \"\"\n                \"user\"  = \"\"\n              }\n              \"allowPrivilegeEscalation\" = \"\"\n              \"capabilities\"             = {\n                \"add\"  = []\n                \"drop\" = [\n                  \"ALL\",\n                ]\n              }\n              \"privileged\"             = \"\"\n              \"readOnlyRootFilesystem\" = \"\"\n              \"runAsGroup\"             = \"\"\n            }\n            \"TerminationMessagePath\" = \"\"\n            \"EnvironmentVariables\"   = []\n            \"LivenessProbe\"          = {\n              \"successThreshold\" = \"\"\n              \"tcpSocket\"        = {\n                \"port\" = \"\"\n                \"host\" = \"\"\n              }\n              \"exec\" = {\n                \"command\" = []\n              }\n              \"failureThreshold\" = \"\"\n              \"periodSeconds\"    = \"\"\n              \"type\"             = \"\"\n              \"httpGet\"          = {\n                \"host\"        = \"\"\n                \"httpHeaders\" = []\n                \"path\"        = \"\"\n                \"port\"        = \"\"\n                \"scheme\"      = \"\"\n              }\n              \"initialDelaySeconds\" = \"\"\n              \"timeoutSeconds\"      = \"\"\n            }\n            \"ReadinessProbe\" = {\n              \"exec\" = {\n                \"command\" = []\n              }\n              \"failureThreshold\" = \"\"\n              \"timeoutSeconds\"   = \"\"\n              \"successThreshold\" = \"\"\n              \"tcpSocket\"        = {\n                \"host\" = \"\"\n                \"port\" = \"\"\n              }\n              \"type\"    = \"\"\n              \"httpGet\" = {\n                \"host\"        = \"\"\n                \"httpHeaders\" = []\n                \"path\"        = \"\"\n                \"port\"        = \"\"\n                \"scheme\"      = \"\"\n              }\n              \"initialDelaySeconds\" = \"\"\n              \"periodSeconds\"       = \"\"\n            }\n            \"TerminationMessagePolicy\"      = \"\"\n            \"VolumeMounts\"                  = []\n            \"ConfigMapEnvFromSource\"        = []\n            \"ConfigMapEnvironmentVariables\" = []\n            \"CreateFeedSecrets\"             = \"False\"\n            \"Lifecycle\"                     = {\n              \"PostStart\" = null\n              \"PreStop\"   = null\n            }\n            \"Name\"         = \"web\"\n            \"StartupProbe\" = {\n              \"successThreshold\" = \"\"\n              \"tcpSocket\"        = {\n                \"host\" = \"\"\n                \"port\" = \"\"\n              }\n              \"failureThreshold\" = \"\"\n              \"httpGet\"          = {\n                \"host\"        = \"\"\n                \"httpHeaders\" = []\n                \"path\"        = \"\"\n                \"port\"        = \"\"\n                \"scheme\"      = \"\"\n              }\n              \"initialDelaySeconds\" = \"\"\n              \"type\"                = \"\"\n              \"exec\"                = {\n                \"command\" = []\n              }\n              \"periodSeconds\"  = \"\"\n              \"timeoutSeconds\" = \"\"\n            }\n          },\n        ])\n        \"Octopus.Action.KubernetesContainers.ServiceName\"         = \"#{Kubernetes.Service.Name}\"\n        \"Octopus.Action.KubernetesContainers.PodManagementPolicy\" = \"OrderedReady\"\n        \"Octopus.Action.Kubernetes.DeploymentTimeout\"             = \"180\"\n        \"Octopus.Action.RunOnServer\"                              = \"true\"\n        \"Octopus.Action.KubernetesContainers.IngressClassName\"    = \"nginx\"\n        \"Octopus.Action.KubernetesContainers.ServicePorts\"        = jsonencode([\n          {\n            \"port\"       = \"80\"\n            \"protocol\"   = \"TCP\"\n            \"targetPort\" = \"web\"\n            \"name\"       = \"web\"\n            \"nodePort\"   = \"\"\n          },\n        ])\n        \"Octopus.Action.Kubernetes.ResourceStatusCheck\"       = \"True\"\n        \"Octopus.Action.KubernetesContainers.ServiceNameType\" = \"External\"\n        \"Octopus.Action.KubernetesContainers.ServiceType\"     = \"ClusterIP\"\n      }\n      container {\n        feed_id = local.docker_hub_feed_id\n        image   = \"octopuslabs/k8s-workertools\"\n      }\n\n      environments = [\n        length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n        length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n        length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n      ]\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n\n      package {\n        name                      = \"web\"\n        package_id                = \"#{Kubernetes.Deployment.Image}\"\n        acquisition_location      = \"NotAcquired\"\n        extract_during_deployment = false\n        feed_id                   = \"#{Kubernetes.Deployment.Feed}\"\n        properties                = { Extract = \"False\", PackageParameterName = \"\", SelectionMode = \"immediate\" }\n      }\n      features = [\n        \"\", \"Octopus.Features.KubernetesService\", \"Octopus.Features.KubernetesIngress\",\n        \"Octopus.Features.KubernetesConfigMap\", \"Octopus.Features.KubernetesSecret\"\n      ]\n    }\n\n    properties   = {}\n    target_roles = [\"EKS_Reference_Cluster\"]\n  }\n\n  step {\n    condition           = \"Success\"\n    name                = \"Smoke Test\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.KubernetesRunScript\"\n      name                               = \"Smoke Test\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      properties                         = {\n        \"Octopus.Action.RunOnServer\"         = \"true\"\n        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"\n        \"Octopus.Action.Script.Syntax\"       = \"Bash\"\n        \"Octopus.Action.Script.ScriptBody\"   = \"for i in {1..30}\\ndo\\n\\tHOSTNAME=$(kubectl get ingress #{Kubernetes.Ingress.Name} -o json -n development | jq -r '.status.loadBalancer.ingress[0].hostname')\\n    if [[ -n \\\"$${HOSTNAME}\\\" ]]\\n  \\tthen\\n    \\tbreak\\n  \\tfi\\n  \\techo \\\"Waiting for ingress hostname\\\"\\n  \\tsleep 10\\ndone\\n    \\n\\n# Load balancers can take a minute or so before their DNS is propagated.\\n# A status code of 000 means curl could not resolve the DNS name, so we wait for a bit until DNS is updated.\\necho \\\"Testing http://$${HOSTNAME}/#{Octopus.Action.Kubernetes.Namespace}/api/products\\\"\\necho \\\"Waiting for DNS to propagate. This can take a while for a new load balancer.\\\"\\nfor i in {1..30}\\ndo\\n  CODE=$(curl -o /dev/null -s -w \\\"%%{http_code}\\\\n\\\" http://$${HOSTNAME}/#{Octopus.Action.Kubernetes.Namespace}/api/products)\\n  if [[ \\\"$${CODE}\\\" == \\\"200\\\" ]]\\n  then\\n    break\\n  fi\\n  echo \\\"Waiting for DNS name to be resolvable and for service to respond\\\"\\n  sleep 10\\ndone\\n\\necho \\\"response code: $${CODE}\\\"\\nif [[ \\\"$${CODE}\\\" == \\\"200\\\" ]]\\nthen\\n    echo \\\"success\\\"\\n    exit 0\\nelse\\n    echo \\\"error\\\"\\n    exit 1\\nfi\"\n      }\n      container {\n        feed_id = local.docker_hub_feed_id\n        image   = \"octopuslabs/k8s-workertools\"\n      }\n      environments = [\n        length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n        length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n        length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n      ]\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = [\"EKS_Reference_Cluster\"]\n  }\n\n  step {\n    condition           = \"Success\"\n    name                = \"Security Scan\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.Script\"\n      name                               = \"Security Scan\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = true\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      properties                         = {\n        \"Octopus.Action.RunOnServer\"         = \"true\"\n        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"\n        \"Octopus.Action.Script.Syntax\"       = \"Bash\"\n        \"Octopus.Action.Script.ScriptBody\"   = local.security_scan_script\n      }\n      environments          = []\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features = []\n    }\n\n    properties   = {}\n    target_roles = []\n  }\n\n  step {\n    condition           = \"Always\"\n    name                = \"Feedback\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.Script\"\n      name                               = \"Feedback\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      properties                         = {\n        \"Octopus.Action.RunOnServer\"         = \"true\"\n        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"\n        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"\n        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"\n      }\n      environments          = []\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = []\n  }\n}\n\nresource \"octopusdeploy_runbook\" \"runbook_octopub_products_scale_to_zero\" {\n  count             = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0\n  name              = \"\uD83C\uDF03 Scale Pods to Zero\"\n  project_id        = octopusdeploy_project.project_octopub_products[0].id\n  environment_scope = \"Specified\"\n  environments      = [\n    length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n    length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n    length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n  ]\n  force_package_download      = false\n  default_guided_failure_mode = \"Off\"\n  description                 = <<EOT\n**WARNING**: This is a destructive operation. The service will no longer be available when scaled down.\n\n**Action**: Scales the deployment down to zero pods.\n\n**Affects**: The products service is effectively shut down.\n\nThis runbook is designed to be be run in non-production environments after hours to remove the Fargate nodes hosting\nthe service. This removes the cost of hosting the service out of hours.\nEOT\n  multi_tenancy_mode          = \"Untenanted\"\n\n  retention_policy {\n    quantity_to_keep    = 100\n    should_keep_forever = false\n  }\n\n  connectivity_policy {\n    allow_deployments_to_no_targets = true\n    exclude_unhealthy_targets       = false\n    skip_machine_behavior           = \"None\"\n  }\n}\n\nresource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_products_scale_pods_to_zero\" {\n  count      = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0\n  runbook_id = octopusdeploy_runbook.runbook_octopub_products_scale_to_zero[0].id\n\n  step {\n    condition           = \"Success\"\n    name                = \"Scale Pods to Zero\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.KubernetesRunScript\"\n      name                               = \"Scale Pods to Zero\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = true\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      worker_pool_variable               = \"\"\n      properties                         = {\n        \"OctopusUseBundledTooling\"           = \"False\"\n        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"\n        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"\n        \"Octopus.Action.Script.ScriptBody\"   = \"kubectl scale --replicas=0 deployment/#{Kubernetes.Deployment.Name}\"\n        \"Octopus.Action.RunOnServer\"         = \"true\"\n      }\n\n      container {\n        feed_id = local.docker_hub_feed_id\n        image   = \"octopuslabs/k8s-workertools\"\n      }\n\n      environments          = []\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = [\"EKS_Reference_Cluster\"]\n  }\n\n  step {\n    condition           = \"Always\"\n    name                = \"Feedback\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.Script\"\n      name                               = \"Feedback\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      properties                         = {\n        \"Octopus.Action.RunOnServer\"         = \"true\"\n        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"\n        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"\n        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"\n      }\n      environments          = []\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = []\n  }\n}\n\nresource \"octopusdeploy_runbook\" \"runbook_octopub_products_scale_to_one\" {\n  count             = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0\n  name              = \"\uD83C\uDF07 Scale Pods to One\"\n  project_id        = octopusdeploy_project.project_octopub_products[0].id\n  environment_scope = \"Specified\"\n  environments      = [\n    length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n    length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n    length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n  ]\n  force_package_download      = false\n  default_guided_failure_mode = \"Off\"\n  description                 = <<EOT\n**Action**: Scales the deployment to one pod.\n\n**Affects**: Products service - this will create new pods if the deployment has been scaled to zero.\n\nThis runbook is designed to be be run in non-production environments during office hours to recreate the pods after they\nwere shutdown after hours.\nEOT\n  multi_tenancy_mode          = \"Untenanted\"\n\n  retention_policy {\n    quantity_to_keep    = 100\n    should_keep_forever = false\n  }\n\n  connectivity_policy {\n    allow_deployments_to_no_targets = true\n    exclude_unhealthy_targets       = false\n    skip_machine_behavior           = \"None\"\n  }\n}\n\nresource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_products_scale_pods_to_one\" {\n  count      = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0\n  runbook_id = octopusdeploy_runbook.runbook_octopub_products_scale_to_one[0].id\n\n  step {\n    condition           = \"Success\"\n    name                = \"Scale Pods to One\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.KubernetesRunScript\"\n      name                               = \"Scale Pods to One\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = true\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      worker_pool_variable               = \"\"\n      properties                         = {\n        \"OctopusUseBundledTooling\"           = \"False\"\n        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"\n        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"\n        \"Octopus.Action.Script.ScriptBody\"   = \"kubectl scale --replicas=1 deployment/#{Kubernetes.Deployment.Name}\"\n        \"Octopus.Action.RunOnServer\"         = \"true\"\n      }\n\n      container {\n        feed_id = local.docker_hub_feed_id\n        image   = \"octopuslabs/k8s-workertools\"\n      }\n\n      environments          = []\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = [\"EKS_Reference_Cluster\"]\n  }\n\n  step {\n    condition           = \"Always\"\n    name                = \"Feedback\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.Script\"\n      name                               = \"Feedback\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      properties                         = {\n        \"Octopus.Action.RunOnServer\"         = \"true\"\n        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"\n        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"\n        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"\n      }\n      environments          = []\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = []\n  }\n}\n\nresource \"octopusdeploy_runbook\" \"runbook_octopub_products_get_pod_logs\" {\n  count             = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0\n  name              = \"\uD83D\uDEE0\uFE0F Get Pod Logs\"\n  project_id        = octopusdeploy_project.project_octopub_products[0].id\n  environment_scope = \"Specified\"\n  environments      = [\n    length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n    length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n    length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n  ]\n  force_package_download      = false\n  default_guided_failure_mode = \"Off\"\n  description                 = <<EOT\n**Action**: Returns the pod logs.\n\n**Affects**: Nothing - this runbook makes no changes.\nEOT\n  multi_tenancy_mode          = \"Untenanted\"\n\n  retention_policy {\n    quantity_to_keep    = 100\n    should_keep_forever = false\n  }\n\n  connectivity_policy {\n    allow_deployments_to_no_targets = true\n    exclude_unhealthy_targets       = false\n    skip_machine_behavior           = \"None\"\n  }\n}\n\nresource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_products_get_pod_logs\" {\n  count      = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0\n  runbook_id = octopusdeploy_runbook.runbook_octopub_products_get_pod_logs[0].id\n\n  step {\n    condition           = \"Success\"\n    name                = \"Get Pod Logs\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.KubernetesRunScript\"\n      name                               = \"Get Pod Logs\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      worker_pool_variable               = \"\"\n      properties                         = {\n        \"K8SInspectCreateArtifact\"                      = \"False\"\n        \"Octopus.Action.Script.ScriptBody\"              = \"\\u003c#\\n    This script provides a general purpose method for querying Kubernetes resources. It supports common operations\\n    like get, describe, logs and output formats like yaml and json. Output can be captured as artifacts.\\n#\\u003e\\n\\n\\u003c#\\n.Description\\nExecute an application, capturing the output. Based on https://stackoverflow.com/a/33652732/157605\\n#\\u003e\\nFunction Execute-Command ($commandPath, $commandArguments)\\n{\\n  Write-Host \\\"Executing: $commandPath $($commandArguments -join \\\" \\\")\\\"\\n  \\n  Try {\\n    $pinfo = New-Object System.Diagnostics.ProcessStartInfo\\n    $pinfo.FileName = $commandPath\\n    $pinfo.RedirectStandardError = $true\\n    $pinfo.RedirectStandardOutput = $true\\n    $pinfo.UseShellExecute = $false\\n    $pinfo.Arguments = $commandArguments\\n    $p = New-Object System.Diagnostics.Process\\n    $p.StartInfo = $pinfo\\n    $p.Start() | Out-Null\\n    [pscustomobject]@{\\n        stdout = $p.StandardOutput.ReadToEnd()\\n        stderr = $p.StandardError.ReadToEnd()\\n        ExitCode = $p.ExitCode\\n    }\\n    $p.WaitForExit()\\n  }\\n  Catch {\\n     exit\\n  }\\n}\\n\\n\\u003c#\\n.Description\\nFind any resource names that match a wildcard input if one was specified\\n#\\u003e\\nfunction Get-Resources() \\n{\\n    $names = $OctopusParameters[\\\"K8SInspectNames\\\"] -Split \\\"`n\\\" | % {$_.Trim()}\\n    \\n    if ($OctopusParameters[\\\"K8SInspectNames\\\"] -match '\\\\*' )\\n    {\\n        return Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", $OctopusParameters[\\\"K8SInspectResource\\\"])) |\\n            # Select the stdout property from the execution\\n            Select-Object -ExpandProperty stdout |\\n            # Convert the output from JSON\\n            ConvertFrom-JSON | \\n            # Get the items object from the kubectl response\\n            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\\n            # Extract the name\\n            % {$_.metadata.name} |\\n            # Find any matching resources\\n            ? {$k8sName = $_; ($names | ? {$k8sName -like $_}).Count -ne 0}\\n    }\\n    else\\n    {\\n        return $names\\n    }\\n}\\n\\n\\u003c#\\n.Description\\nGet the kubectl arguments for a given action\\n#\\u003e\\nfunction Get-KubectlVerb() \\n{\\n    switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\\n    {\\n        \\\"get json\\\" {return ,@(\\\"-o\\\", \\\"json\\\", \\\"get\\\")}\\n        \\\"get yaml\\\" {return ,@(\\\"-o\\\", \\\"yaml\\\", \\\"get\\\")}\\n        \\\"describe\\\" {return ,@(\\\"describe\\\")}\\n        \\\"logs\\\" {return ,@(\\\"logs\\\")}\\n        \\\"logs tail\\\" {return ,@(\\\"logs\\\", \\\"--tail\\\", \\\"100\\\")}\\n        \\\"previous logs\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\")}\\n        \\\"previous logs tail\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\", \\\"--tail\\\", \\\"100\\\")}\\n        default {return ,@(\\\"get\\\")}\\n    }\\n}\\n\\n\\u003c#\\n.Description\\nGet an appropiate file extension based on the selected action\\n#\\u003e\\nfunction Get-ArtifactExtension() \\n{\\n   switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\\n    {\\n        \\\"get json\\\" {\\\"json\\\"}\\n        \\\"get yaml\\\" {\\\"yaml\\\"}\\n        default {\\\"txt\\\"}\\n    }\\n}\\n\\nif ($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"] -like \\\"*logs*\\\") \\n{\\n    if ( -not @($OctopusParameters[\\\"K8SInspectResource\\\"]) -like \\\"pod*\\\")\\n    {\\n        Write-Error \\\"Logs can only be returned for pods, not $($OctopusParameters[\\\"K8SInspectResource\\\"])\\\"\\n    }\\n    else\\n    {\\n        Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", \\\"pods\\\") + (Get-Resources)) |\\n            # Select the stdout property from the execution\\n            Select-Object -ExpandProperty stdout |\\n            # Convert the output from JSON\\n            ConvertFrom-JSON | \\n            # Get the items object from the kubectl response\\n            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\\n            # Get the pod logs for each container\\n            % {\\n                $podDetails = $_\\n                @{\\n                    logs=$podDetails.spec.containers | % {$logs=\\\"\\\"} {$logs += (Select-Object -InputObject (Execute-Command kubectl ((Get-KubectlVerb) + @($podDetails.metadata.name, \\\"-c\\\", $_.name))) -ExpandProperty stdout)} {$logs}; \\n                    name=$podDetails.metadata.name\\n                }                \\n            } |\\n            # Write the output\\n            % {Write-Host $_.logs; $_} |\\n            # Optionally capture the artifact\\n            % {\\n                if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \\n                {\\n                    Set-Content -Path \\\"$($_.name).$(Get-ArtifactExtension)\\\" -Value $_.logs\\n                    New-OctopusArtifact \\\"$($_.name).$(Get-ArtifactExtension)\\\"\\n                }\\n            }\\n    }      \\n}\\nelse\\n{\\n    Execute-Command kubectl ((Get-KubectlVerb) + @($OctopusParameters[\\\"K8SInspectResource\\\"]) + (Get-Resources)) |\\n        % {Select-Object -InputObject $_ -ExpandProperty stdout} |\\n        % {Write-Host $_; $_} |\\n        % {\\n            if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \\n            {\\n                Set-Content -Path \\\"output.$(Get-ArtifactExtension)\\\" -Value $_\\n                New-OctopusArtifact \\\"output.$(Get-ArtifactExtension)\\\"\\n            }\\n        }\\n}\\n\"\n        \"Octopus.Action.Script.ScriptSource\"            = \"Inline\"\n        \"K8SInspectResource\"                            = \"pod\"\n        \"Octopus.Action.Script.Syntax\"                  = \"PowerShell\"\n        \"Octopus.Action.KubernetesContainers.Namespace\" = \"#{if K8SInspectNamespace}#{K8SInspectNamespace}#{/if}#{unless K8SInspectNamespace}#{Octopus.Action.Kubernetes.Namespace}#{/unless}\"\n        \"K8SInspectNames\"                               = \"#{Kubernetes.Deployment.Name}*\"\n        \"K8SInspectKubectlVerb\"                         = \"logs\"\n      }\n      container {\n        feed_id = local.docker_hub_feed_id\n        image   = \"octopuslabs/k8s-workertools\"\n      }\n      environments = [\n        length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n        length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n        length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n      ]\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = [\"EKS_Reference_Cluster\"]\n  }\n\n  step {\n    condition           = \"Always\"\n    name                = \"Feedback\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.Script\"\n      name                               = \"Feedback\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      properties                         = {\n        \"Octopus.Action.RunOnServer\"         = \"true\"\n        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"\n        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"\n        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"\n      }\n      environments          = []\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = []\n  }\n}\n\nresource \"octopusdeploy_runbook\" \"runbook_octopub_products_get_pods\" {\n  count             = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0\n  name              = \"\uD83D\uDEE0\uFE0F Get Pods\"\n  project_id        = octopusdeploy_project.project_octopub_products[0].id\n  environment_scope = \"Specified\"\n  environments      = [\n    length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n    length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n    length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n  ]\n  force_package_download      = false\n  default_guided_failure_mode = \"Off\"\n  description                 = <<EOT\n**Action**: Returns the pods.\n\n**Affects**: Nothing - this runbook makes no changes.\nEOT\n  multi_tenancy_mode          = \"Untenanted\"\n\n  retention_policy {\n    quantity_to_keep    = 100\n    should_keep_forever = false\n  }\n\n  connectivity_policy {\n    allow_deployments_to_no_targets = true\n    exclude_unhealthy_targets       = false\n    skip_machine_behavior           = \"None\"\n  }\n}\n\nresource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_products_get_pods\" {\n  count      = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0\n  runbook_id = octopusdeploy_runbook.runbook_octopub_products_get_pods[0].id\n\n  step {\n    condition           = \"Success\"\n    name                = \"Get Pods\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.KubernetesRunScript\"\n      name                               = \"Get Pods\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      worker_pool_variable               = \"\"\n      properties                         = {\n        \"K8SInspectCreateArtifact\"                      = \"False\"\n        \"Octopus.Action.Script.ScriptBody\"              = \"\\u003c#\\n    This script provides a general purpose method for querying Kubernetes resources. It supports common operations\\n    like get, describe, logs and output formats like yaml and json. Output can be captured as artifacts.\\n#\\u003e\\n\\n\\u003c#\\n.Description\\nExecute an application, capturing the output. Based on https://stackoverflow.com/a/33652732/157605\\n#\\u003e\\nFunction Execute-Command ($commandPath, $commandArguments)\\n{\\n  Write-Host \\\"Executing: $commandPath $($commandArguments -join \\\" \\\")\\\"\\n  \\n  Try {\\n    $pinfo = New-Object System.Diagnostics.ProcessStartInfo\\n    $pinfo.FileName = $commandPath\\n    $pinfo.RedirectStandardError = $true\\n    $pinfo.RedirectStandardOutput = $true\\n    $pinfo.UseShellExecute = $false\\n    $pinfo.Arguments = $commandArguments\\n    $p = New-Object System.Diagnostics.Process\\n    $p.StartInfo = $pinfo\\n    $p.Start() | Out-Null\\n    [pscustomobject]@{\\n        stdout = $p.StandardOutput.ReadToEnd()\\n        stderr = $p.StandardError.ReadToEnd()\\n        ExitCode = $p.ExitCode\\n    }\\n    $p.WaitForExit()\\n  }\\n  Catch {\\n     exit\\n  }\\n}\\n\\n\\u003c#\\n.Description\\nFind any resource names that match a wildcard input if one was specified\\n#\\u003e\\nfunction Get-Resources() \\n{\\n    $names = $OctopusParameters[\\\"K8SInspectNames\\\"] -Split \\\"`n\\\" | % {$_.Trim()}\\n    \\n    if ($OctopusParameters[\\\"K8SInspectNames\\\"] -match '\\\\*' )\\n    {\\n        return Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", $OctopusParameters[\\\"K8SInspectResource\\\"])) |\\n            # Select the stdout property from the execution\\n            Select-Object -ExpandProperty stdout |\\n            # Convert the output from JSON\\n            ConvertFrom-JSON | \\n            # Get the items object from the kubectl response\\n            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\\n            # Extract the name\\n            % {$_.metadata.name} |\\n            # Find any matching resources\\n            ? {$k8sName = $_; ($names | ? {$k8sName -like $_}).Count -ne 0}\\n    }\\n    else\\n    {\\n        return $names\\n    }\\n}\\n\\n\\u003c#\\n.Description\\nGet the kubectl arguments for a given action\\n#\\u003e\\nfunction Get-KubectlVerb() \\n{\\n    switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\\n    {\\n        \\\"get json\\\" {return ,@(\\\"-o\\\", \\\"json\\\", \\\"get\\\")}\\n        \\\"get yaml\\\" {return ,@(\\\"-o\\\", \\\"yaml\\\", \\\"get\\\")}\\n        \\\"describe\\\" {return ,@(\\\"describe\\\")}\\n        \\\"logs\\\" {return ,@(\\\"logs\\\")}\\n        \\\"logs tail\\\" {return ,@(\\\"logs\\\", \\\"--tail\\\", \\\"100\\\")}\\n        \\\"previous logs\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\")}\\n        \\\"previous logs tail\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\", \\\"--tail\\\", \\\"100\\\")}\\n        default {return ,@(\\\"get\\\")}\\n    }\\n}\\n\\n\\u003c#\\n.Description\\nGet an appropiate file extension based on the selected action\\n#\\u003e\\nfunction Get-ArtifactExtension() \\n{\\n   switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\\n    {\\n        \\\"get json\\\" {\\\"json\\\"}\\n        \\\"get yaml\\\" {\\\"yaml\\\"}\\n        default {\\\"txt\\\"}\\n    }\\n}\\n\\nif ($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"] -like \\\"*logs*\\\") \\n{\\n    if ( -not @($OctopusParameters[\\\"K8SInspectResource\\\"]) -like \\\"pod*\\\")\\n    {\\n        Write-Error \\\"Logs can only be returned for pods, not $($OctopusParameters[\\\"K8SInspectResource\\\"])\\\"\\n    }\\n    else\\n    {\\n        Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", \\\"pods\\\") + (Get-Resources)) |\\n            # Select the stdout property from the execution\\n            Select-Object -ExpandProperty stdout |\\n            # Convert the output from JSON\\n            ConvertFrom-JSON | \\n            # Get the items object from the kubectl response\\n            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\\n            # Get the pod logs for each container\\n            % {\\n                $podDetails = $_\\n                @{\\n                    logs=$podDetails.spec.containers | % {$logs=\\\"\\\"} {$logs += (Select-Object -InputObject (Execute-Command kubectl ((Get-KubectlVerb) + @($podDetails.metadata.name, \\\"-c\\\", $_.name))) -ExpandProperty stdout)} {$logs}; \\n                    name=$podDetails.metadata.name\\n                }                \\n            } |\\n            # Write the output\\n            % {Write-Host $_.logs; $_} |\\n            # Optionally capture the artifact\\n            % {\\n                if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \\n                {\\n                    Set-Content -Path \\\"$($_.name).$(Get-ArtifactExtension)\\\" -Value $_.logs\\n                    New-OctopusArtifact \\\"$($_.name).$(Get-ArtifactExtension)\\\"\\n                }\\n            }\\n    }      \\n}\\nelse\\n{\\n    Execute-Command kubectl ((Get-KubectlVerb) + @($OctopusParameters[\\\"K8SInspectResource\\\"]) + (Get-Resources)) |\\n        % {Select-Object -InputObject $_ -ExpandProperty stdout} |\\n        % {Write-Host $_; $_} |\\n        % {\\n            if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \\n            {\\n                Set-Content -Path \\\"output.$(Get-ArtifactExtension)\\\" -Value $_\\n                New-OctopusArtifact \\\"output.$(Get-ArtifactExtension)\\\"\\n            }\\n        }\\n}\\n\"\n        \"Octopus.Action.Script.ScriptSource\"            = \"Inline\"\n        \"K8SInspectResource\"                            = \"pod\"\n        \"Octopus.Action.Script.Syntax\"                  = \"PowerShell\"\n        \"Octopus.Action.KubernetesContainers.Namespace\" = \"#{if K8SInspectNamespace}#{K8SInspectNamespace}#{/if}#{unless K8SInspectNamespace}#{Octopus.Action.Kubernetes.Namespace}#{/unless}\"\n        \"K8SInspectNames\"                               = \"#{Kubernetes.Deployment.Name}*\"\n        \"K8SInspectKubectlVerb\"                         = \"get\"\n      }\n      container {\n        feed_id = local.docker_hub_feed_id\n        image   = \"octopuslabs/k8s-workertools\"\n      }\n      environments = [\n        length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n        length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n        length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n      ]\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = [\"EKS_Reference_Cluster\"]\n  }\n\n  step {\n    condition           = \"Always\"\n    name                = \"Feedback\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.Script\"\n      name                               = \"Feedback\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      properties                         = {\n        \"Octopus.Action.RunOnServer\"         = \"true\"\n        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"\n        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"\n        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"\n      }\n      environments          = []\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = []\n  }\n}\n\nresource \"octopusdeploy_runbook\" \"runbook_octopub_products_describe_pods\" {\n  count             = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0\n  name              = \"\uD83D\uDEE0\uFE0F Describe Pods\"\n  project_id        = octopusdeploy_project.project_octopub_products[0].id\n  environment_scope = \"Specified\"\n  environments      = [\n    length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n    length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n    length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n  ]\n  force_package_download      = false\n  default_guided_failure_mode = \"Off\"\n  description                 = <<EOT\n**Action**: Returns the pods.\n\n**Affects**: Nothing - this runbook makes no changes.\nEOT\n  multi_tenancy_mode          = \"Untenanted\"\n\n  retention_policy {\n    quantity_to_keep    = 100\n    should_keep_forever = false\n  }\n\n  connectivity_policy {\n    allow_deployments_to_no_targets = true\n    exclude_unhealthy_targets       = false\n    skip_machine_behavior           = \"None\"\n  }\n}\n\nresource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_products_describe_pods\" {\n  count      = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0\n  runbook_id = octopusdeploy_runbook.runbook_octopub_products_describe_pods[0].id\n\n  step {\n    condition           = \"Success\"\n    name                = \"Describe Pods\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.KubernetesRunScript\"\n      name                               = \"Describe Pods\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      worker_pool_variable               = \"\"\n      properties                         = {\n        \"K8SInspectCreateArtifact\"                      = \"False\"\n        \"Octopus.Action.Script.ScriptBody\"              = \"\\u003c#\\n    This script provides a general purpose method for querying Kubernetes resources. It supports common operations\\n    like get, describe, logs and output formats like yaml and json. Output can be captured as artifacts.\\n#\\u003e\\n\\n\\u003c#\\n.Description\\nExecute an application, capturing the output. Based on https://stackoverflow.com/a/33652732/157605\\n#\\u003e\\nFunction Execute-Command ($commandPath, $commandArguments)\\n{\\n  Write-Host \\\"Executing: $commandPath $($commandArguments -join \\\" \\\")\\\"\\n  \\n  Try {\\n    $pinfo = New-Object System.Diagnostics.ProcessStartInfo\\n    $pinfo.FileName = $commandPath\\n    $pinfo.RedirectStandardError = $true\\n    $pinfo.RedirectStandardOutput = $true\\n    $pinfo.UseShellExecute = $false\\n    $pinfo.Arguments = $commandArguments\\n    $p = New-Object System.Diagnostics.Process\\n    $p.StartInfo = $pinfo\\n    $p.Start() | Out-Null\\n    [pscustomobject]@{\\n        stdout = $p.StandardOutput.ReadToEnd()\\n        stderr = $p.StandardError.ReadToEnd()\\n        ExitCode = $p.ExitCode\\n    }\\n    $p.WaitForExit()\\n  }\\n  Catch {\\n     exit\\n  }\\n}\\n\\n\\u003c#\\n.Description\\nFind any resource names that match a wildcard input if one was specified\\n#\\u003e\\nfunction Get-Resources() \\n{\\n    $names = $OctopusParameters[\\\"K8SInspectNames\\\"] -Split \\\"`n\\\" | % {$_.Trim()}\\n    \\n    if ($OctopusParameters[\\\"K8SInspectNames\\\"] -match '\\\\*' )\\n    {\\n        return Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", $OctopusParameters[\\\"K8SInspectResource\\\"])) |\\n            # Select the stdout property from the execution\\n            Select-Object -ExpandProperty stdout |\\n            # Convert the output from JSON\\n            ConvertFrom-JSON | \\n            # Get the items object from the kubectl response\\n            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\\n            # Extract the name\\n            % {$_.metadata.name} |\\n            # Find any matching resources\\n            ? {$k8sName = $_; ($names | ? {$k8sName -like $_}).Count -ne 0}\\n    }\\n    else\\n    {\\n        return $names\\n    }\\n}\\n\\n\\u003c#\\n.Description\\nGet the kubectl arguments for a given action\\n#\\u003e\\nfunction Get-KubectlVerb() \\n{\\n    switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\\n    {\\n        \\\"get json\\\" {return ,@(\\\"-o\\\", \\\"json\\\", \\\"get\\\")}\\n        \\\"get yaml\\\" {return ,@(\\\"-o\\\", \\\"yaml\\\", \\\"get\\\")}\\n        \\\"describe\\\" {return ,@(\\\"describe\\\")}\\n        \\\"logs\\\" {return ,@(\\\"logs\\\")}\\n        \\\"logs tail\\\" {return ,@(\\\"logs\\\", \\\"--tail\\\", \\\"100\\\")}\\n        \\\"previous logs\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\")}\\n        \\\"previous logs tail\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\", \\\"--tail\\\", \\\"100\\\")}\\n        default {return ,@(\\\"get\\\")}\\n    }\\n}\\n\\n\\u003c#\\n.Description\\nGet an appropiate file extension based on the selected action\\n#\\u003e\\nfunction Get-ArtifactExtension() \\n{\\n   switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\\n    {\\n        \\\"get json\\\" {\\\"json\\\"}\\n        \\\"get yaml\\\" {\\\"yaml\\\"}\\n        default {\\\"txt\\\"}\\n    }\\n}\\n\\nif ($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"] -like \\\"*logs*\\\") \\n{\\n    if ( -not @($OctopusParameters[\\\"K8SInspectResource\\\"]) -like \\\"pod*\\\")\\n    {\\n        Write-Error \\\"Logs can only be returned for pods, not $($OctopusParameters[\\\"K8SInspectResource\\\"])\\\"\\n    }\\n    else\\n    {\\n        Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", \\\"pods\\\") + (Get-Resources)) |\\n            # Select the stdout property from the execution\\n            Select-Object -ExpandProperty stdout |\\n            # Convert the output from JSON\\n            ConvertFrom-JSON | \\n            # Get the items object from the kubectl response\\n            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\\n            # Get the pod logs for each container\\n            % {\\n                $podDetails = $_\\n                @{\\n                    logs=$podDetails.spec.containers | % {$logs=\\\"\\\"} {$logs += (Select-Object -InputObject (Execute-Command kubectl ((Get-KubectlVerb) + @($podDetails.metadata.name, \\\"-c\\\", $_.name))) -ExpandProperty stdout)} {$logs}; \\n                    name=$podDetails.metadata.name\\n                }                \\n            } |\\n            # Write the output\\n            % {Write-Host $_.logs; $_} |\\n            # Optionally capture the artifact\\n            % {\\n                if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \\n                {\\n                    Set-Content -Path \\\"$($_.name).$(Get-ArtifactExtension)\\\" -Value $_.logs\\n                    New-OctopusArtifact \\\"$($_.name).$(Get-ArtifactExtension)\\\"\\n                }\\n            }\\n    }      \\n}\\nelse\\n{\\n    Execute-Command kubectl ((Get-KubectlVerb) + @($OctopusParameters[\\\"K8SInspectResource\\\"]) + (Get-Resources)) |\\n        % {Select-Object -InputObject $_ -ExpandProperty stdout} |\\n        % {Write-Host $_; $_} |\\n        % {\\n            if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \\n            {\\n                Set-Content -Path \\\"output.$(Get-ArtifactExtension)\\\" -Value $_\\n                New-OctopusArtifact \\\"output.$(Get-ArtifactExtension)\\\"\\n            }\\n        }\\n}\\n\"\n        \"Octopus.Action.Script.ScriptSource\"            = \"Inline\"\n        \"K8SInspectResource\"                            = \"pod\"\n        \"Octopus.Action.Script.Syntax\"                  = \"PowerShell\"\n        \"Octopus.Action.KubernetesContainers.Namespace\" = \"#{if K8SInspectNamespace}#{K8SInspectNamespace}#{/if}#{unless K8SInspectNamespace}#{Octopus.Action.Kubernetes.Namespace}#{/unless}\"\n        \"K8SInspectNames\"                               = \"#{Kubernetes.Deployment.Name}*\"\n        \"K8SInspectKubectlVerb\"                         = \"describe\"\n      }\n      container {\n        feed_id = local.docker_hub_feed_id\n        image   = \"octopuslabs/k8s-workertools\"\n      }\n      environments = [\n        length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n        length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n        length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n      ]\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = [\"EKS_Reference_Cluster\"]\n  }\n\n  step {\n    condition           = \"Always\"\n    name                = \"Feedback\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.Script\"\n      name                               = \"Feedback\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      properties                         = {\n        \"Octopus.Action.RunOnServer\"         = \"true\"\n        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"\n        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"\n        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"\n      }\n      environments          = []\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = []\n  }\n}\n\nresource \"octopusdeploy_runbook\" \"runbook_octopub_products_get_ingress\" {\n  count             = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0\n  name              = \"\uD83D\uDEE0\uFE0F Get Ingress\"\n  project_id        = octopusdeploy_project.project_octopub_products[0].id\n  environment_scope = \"Specified\"\n  environments      = [\n    length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n    length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n    length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n  ]\n  force_package_download      = false\n  default_guided_failure_mode = \"Off\"\n  description                 = <<EOT\n**Action**: Returns the ingresses.\n\n**Affects**: Nothing - this runbook makes no changes.\n\n**Resolves**: Finding the public IP to access the deployed application.\nEOT\n  multi_tenancy_mode          = \"Untenanted\"\n\n  retention_policy {\n    quantity_to_keep    = 100\n    should_keep_forever = false\n  }\n\n  connectivity_policy {\n    allow_deployments_to_no_targets = true\n    exclude_unhealthy_targets       = false\n    skip_machine_behavior           = \"None\"\n  }\n}\n\nresource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_products_get_ingress\" {\n  count      = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0\n  runbook_id = octopusdeploy_runbook.runbook_octopub_products_get_ingress[0].id\n\n  step {\n    condition           = \"Success\"\n    name                = \"Get Ingress\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.KubernetesRunScript\"\n      name                               = \"Get Ingress\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      worker_pool_variable               = \"\"\n      properties                         = {\n        \"K8SInspectCreateArtifact\"                      = \"False\"\n        \"Octopus.Action.Script.ScriptBody\"              = \"\\u003c#\\n    This script provides a general purpose method for querying Kubernetes resources. It supports common operations\\n    like get, describe, logs and output formats like yaml and json. Output can be captured as artifacts.\\n#\\u003e\\n\\n\\u003c#\\n.Description\\nExecute an application, capturing the output. Based on https://stackoverflow.com/a/33652732/157605\\n#\\u003e\\nFunction Execute-Command ($commandPath, $commandArguments)\\n{\\n  Write-Host \\\"Executing: $commandPath $($commandArguments -join \\\" \\\")\\\"\\n  \\n  Try {\\n    $pinfo = New-Object System.Diagnostics.ProcessStartInfo\\n    $pinfo.FileName = $commandPath\\n    $pinfo.RedirectStandardError = $true\\n    $pinfo.RedirectStandardOutput = $true\\n    $pinfo.UseShellExecute = $false\\n    $pinfo.Arguments = $commandArguments\\n    $p = New-Object System.Diagnostics.Process\\n    $p.StartInfo = $pinfo\\n    $p.Start() | Out-Null\\n    [pscustomobject]@{\\n        stdout = $p.StandardOutput.ReadToEnd()\\n        stderr = $p.StandardError.ReadToEnd()\\n        ExitCode = $p.ExitCode\\n    }\\n    $p.WaitForExit()\\n  }\\n  Catch {\\n     exit\\n  }\\n}\\n\\n\\u003c#\\n.Description\\nFind any resource names that match a wildcard input if one was specified\\n#\\u003e\\nfunction Get-Resources() \\n{\\n    $names = $OctopusParameters[\\\"K8SInspectNames\\\"] -Split \\\"`n\\\" | % {$_.Trim()}\\n    \\n    if ($OctopusParameters[\\\"K8SInspectNames\\\"] -match '\\\\*' )\\n    {\\n        return Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", $OctopusParameters[\\\"K8SInspectResource\\\"])) |\\n            # Select the stdout property from the execution\\n            Select-Object -ExpandProperty stdout |\\n            # Convert the output from JSON\\n            ConvertFrom-JSON | \\n            # Get the items object from the kubectl response\\n            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\\n            # Extract the name\\n            % {$_.metadata.name} |\\n            # Find any matching resources\\n            ? {$k8sName = $_; ($names | ? {$k8sName -like $_}).Count -ne 0}\\n    }\\n    else\\n    {\\n        return $names\\n    }\\n}\\n\\n\\u003c#\\n.Description\\nGet the kubectl arguments for a given action\\n#\\u003e\\nfunction Get-KubectlVerb() \\n{\\n    switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\\n    {\\n        \\\"get json\\\" {return ,@(\\\"-o\\\", \\\"json\\\", \\\"get\\\")}\\n        \\\"get yaml\\\" {return ,@(\\\"-o\\\", \\\"yaml\\\", \\\"get\\\")}\\n        \\\"describe\\\" {return ,@(\\\"describe\\\")}\\n        \\\"logs\\\" {return ,@(\\\"logs\\\")}\\n        \\\"logs tail\\\" {return ,@(\\\"logs\\\", \\\"--tail\\\", \\\"100\\\")}\\n        \\\"previous logs\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\")}\\n        \\\"previous logs tail\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\", \\\"--tail\\\", \\\"100\\\")}\\n        default {return ,@(\\\"get\\\")}\\n    }\\n}\\n\\n\\u003c#\\n.Description\\nGet an appropiate file extension based on the selected action\\n#\\u003e\\nfunction Get-ArtifactExtension() \\n{\\n   switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\\n    {\\n        \\\"get json\\\" {\\\"json\\\"}\\n        \\\"get yaml\\\" {\\\"yaml\\\"}\\n        default {\\\"txt\\\"}\\n    }\\n}\\n\\nif ($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"] -like \\\"*logs*\\\") \\n{\\n    if ( -not @($OctopusParameters[\\\"K8SInspectResource\\\"]) -like \\\"pod*\\\")\\n    {\\n        Write-Error \\\"Logs can only be returned for pods, not $($OctopusParameters[\\\"K8SInspectResource\\\"])\\\"\\n    }\\n    else\\n    {\\n        Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", \\\"pods\\\") + (Get-Resources)) |\\n            # Select the stdout property from the execution\\n            Select-Object -ExpandProperty stdout |\\n            # Convert the output from JSON\\n            ConvertFrom-JSON | \\n            # Get the items object from the kubectl response\\n            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\\n            # Get the pod logs for each container\\n            % {\\n                $podDetails = $_\\n                @{\\n                    logs=$podDetails.spec.containers | % {$logs=\\\"\\\"} {$logs += (Select-Object -InputObject (Execute-Command kubectl ((Get-KubectlVerb) + @($podDetails.metadata.name, \\\"-c\\\", $_.name))) -ExpandProperty stdout)} {$logs}; \\n                    name=$podDetails.metadata.name\\n                }                \\n            } |\\n            # Write the output\\n            % {Write-Host $_.logs; $_} |\\n            # Optionally capture the artifact\\n            % {\\n                if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \\n                {\\n                    Set-Content -Path \\\"$($_.name).$(Get-ArtifactExtension)\\\" -Value $_.logs\\n                    New-OctopusArtifact \\\"$($_.name).$(Get-ArtifactExtension)\\\"\\n                }\\n            }\\n    }      \\n}\\nelse\\n{\\n    Execute-Command kubectl ((Get-KubectlVerb) + @($OctopusParameters[\\\"K8SInspectResource\\\"]) + (Get-Resources)) |\\n        % {Select-Object -InputObject $_ -ExpandProperty stdout} |\\n        % {Write-Host $_; $_} |\\n        % {\\n            if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \\n            {\\n                Set-Content -Path \\\"output.$(Get-ArtifactExtension)\\\" -Value $_\\n                New-OctopusArtifact \\\"output.$(Get-ArtifactExtension)\\\"\\n            }\\n        }\\n}\\n\"\n        \"Octopus.Action.Script.ScriptSource\"            = \"Inline\"\n        \"K8SInspectResource\"                            = \"ingress\"\n        \"Octopus.Action.Script.Syntax\"                  = \"PowerShell\"\n        \"Octopus.Action.KubernetesContainers.Namespace\" = \"#{if K8SInspectNamespace}#{K8SInspectNamespace}#{/if}#{unless K8SInspectNamespace}#{Octopus.Action.Kubernetes.Namespace}#{/unless}\"\n        \"K8SInspectNames\"                               = \"#{Kubernetes.Ingress.Name}*\"\n        \"K8SInspectKubectlVerb\"                         = \"get\"\n      }\n      container {\n        feed_id = local.docker_hub_feed_id\n        image   = \"octopuslabs/k8s-workertools\"\n      }\n      environments = [\n        length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n        length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n        length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n      ]\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = [\"EKS_Reference_Cluster\"]\n  }\n\n  step {\n    condition           = \"Always\"\n    name                = \"Feedback\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.Script\"\n      name                               = \"Feedback\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      properties                         = {\n        \"Octopus.Action.RunOnServer\"         = \"true\"\n        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"\n        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"\n        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"\n      }\n      environments          = []\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = []\n  }\n}\n\nresource \"octopusdeploy_runbook\" \"runbook_octopub_products_get_service\" {\n  count             = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0\n  name              = \"\uD83D\uDEE0\uFE0F Get Service\"\n  project_id        = octopusdeploy_project.project_octopub_products[0].id\n  environment_scope = \"Specified\"\n  environments      = [\n    length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n    length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n    length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n  ]\n  force_package_download      = false\n  default_guided_failure_mode = \"Off\"\n  description                 = <<EOT\n**Action**: Returns the services.\n\n**Affects**: Nothing - this runbook makes no changes.\nEOT\n  multi_tenancy_mode          = \"Untenanted\"\n\n  retention_policy {\n    quantity_to_keep    = 100\n    should_keep_forever = false\n  }\n\n  connectivity_policy {\n    allow_deployments_to_no_targets = true\n    exclude_unhealthy_targets       = false\n    skip_machine_behavior           = \"None\"\n  }\n}\n\nresource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_products_get_service\" {\n  count      = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0\n  runbook_id = octopusdeploy_runbook.runbook_octopub_products_get_service[0].id\n\n  step {\n    condition           = \"Success\"\n    name                = \"Get Service\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.KubernetesRunScript\"\n      name                               = \"Get Service\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      worker_pool_variable               = \"\"\n      properties                         = {\n        \"K8SInspectCreateArtifact\"                      = \"False\"\n        \"Octopus.Action.Script.ScriptBody\"              = \"\\u003c#\\n    This script provides a general purpose method for querying Kubernetes resources. It supports common operations\\n    like get, describe, logs and output formats like yaml and json. Output can be captured as artifacts.\\n#\\u003e\\n\\n\\u003c#\\n.Description\\nExecute an application, capturing the output. Based on https://stackoverflow.com/a/33652732/157605\\n#\\u003e\\nFunction Execute-Command ($commandPath, $commandArguments)\\n{\\n  Write-Host \\\"Executing: $commandPath $($commandArguments -join \\\" \\\")\\\"\\n  \\n  Try {\\n    $pinfo = New-Object System.Diagnostics.ProcessStartInfo\\n    $pinfo.FileName = $commandPath\\n    $pinfo.RedirectStandardError = $true\\n    $pinfo.RedirectStandardOutput = $true\\n    $pinfo.UseShellExecute = $false\\n    $pinfo.Arguments = $commandArguments\\n    $p = New-Object System.Diagnostics.Process\\n    $p.StartInfo = $pinfo\\n    $p.Start() | Out-Null\\n    [pscustomobject]@{\\n        stdout = $p.StandardOutput.ReadToEnd()\\n        stderr = $p.StandardError.ReadToEnd()\\n        ExitCode = $p.ExitCode\\n    }\\n    $p.WaitForExit()\\n  }\\n  Catch {\\n     exit\\n  }\\n}\\n\\n\\u003c#\\n.Description\\nFind any resource names that match a wildcard input if one was specified\\n#\\u003e\\nfunction Get-Resources() \\n{\\n    $names = $OctopusParameters[\\\"K8SInspectNames\\\"] -Split \\\"`n\\\" | % {$_.Trim()}\\n    \\n    if ($OctopusParameters[\\\"K8SInspectNames\\\"] -match '\\\\*' )\\n    {\\n        return Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", $OctopusParameters[\\\"K8SInspectResource\\\"])) |\\n            # Select the stdout property from the execution\\n            Select-Object -ExpandProperty stdout |\\n            # Convert the output from JSON\\n            ConvertFrom-JSON | \\n            # Get the items object from the kubectl response\\n            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\\n            # Extract the name\\n            % {$_.metadata.name} |\\n            # Find any matching resources\\n            ? {$k8sName = $_; ($names | ? {$k8sName -like $_}).Count -ne 0}\\n    }\\n    else\\n    {\\n        return $names\\n    }\\n}\\n\\n\\u003c#\\n.Description\\nGet the kubectl arguments for a given action\\n#\\u003e\\nfunction Get-KubectlVerb() \\n{\\n    switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\\n    {\\n        \\\"get json\\\" {return ,@(\\\"-o\\\", \\\"json\\\", \\\"get\\\")}\\n        \\\"get yaml\\\" {return ,@(\\\"-o\\\", \\\"yaml\\\", \\\"get\\\")}\\n        \\\"describe\\\" {return ,@(\\\"describe\\\")}\\n        \\\"logs\\\" {return ,@(\\\"logs\\\")}\\n        \\\"logs tail\\\" {return ,@(\\\"logs\\\", \\\"--tail\\\", \\\"100\\\")}\\n        \\\"previous logs\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\")}\\n        \\\"previous logs tail\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\", \\\"--tail\\\", \\\"100\\\")}\\n        default {return ,@(\\\"get\\\")}\\n    }\\n}\\n\\n\\u003c#\\n.Description\\nGet an appropiate file extension based on the selected action\\n#\\u003e\\nfunction Get-ArtifactExtension() \\n{\\n   switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\\n    {\\n        \\\"get json\\\" {\\\"json\\\"}\\n        \\\"get yaml\\\" {\\\"yaml\\\"}\\n        default {\\\"txt\\\"}\\n    }\\n}\\n\\nif ($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"] -like \\\"*logs*\\\") \\n{\\n    if ( -not @($OctopusParameters[\\\"K8SInspectResource\\\"]) -like \\\"pod*\\\")\\n    {\\n        Write-Error \\\"Logs can only be returned for pods, not $($OctopusParameters[\\\"K8SInspectResource\\\"])\\\"\\n    }\\n    else\\n    {\\n        Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", \\\"pods\\\") + (Get-Resources)) |\\n            # Select the stdout property from the execution\\n            Select-Object -ExpandProperty stdout |\\n            # Convert the output from JSON\\n            ConvertFrom-JSON | \\n            # Get the items object from the kubectl response\\n            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\\n            # Get the pod logs for each container\\n            % {\\n                $podDetails = $_\\n                @{\\n                    logs=$podDetails.spec.containers | % {$logs=\\\"\\\"} {$logs += (Select-Object -InputObject (Execute-Command kubectl ((Get-KubectlVerb) + @($podDetails.metadata.name, \\\"-c\\\", $_.name))) -ExpandProperty stdout)} {$logs}; \\n                    name=$podDetails.metadata.name\\n                }                \\n            } |\\n            # Write the output\\n            % {Write-Host $_.logs; $_} |\\n            # Optionally capture the artifact\\n            % {\\n                if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \\n                {\\n                    Set-Content -Path \\\"$($_.name).$(Get-ArtifactExtension)\\\" -Value $_.logs\\n                    New-OctopusArtifact \\\"$($_.name).$(Get-ArtifactExtension)\\\"\\n                }\\n            }\\n    }      \\n}\\nelse\\n{\\n    Execute-Command kubectl ((Get-KubectlVerb) + @($OctopusParameters[\\\"K8SInspectResource\\\"]) + (Get-Resources)) |\\n        % {Select-Object -InputObject $_ -ExpandProperty stdout} |\\n        % {Write-Host $_; $_} |\\n        % {\\n            if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \\n            {\\n                Set-Content -Path \\\"output.$(Get-ArtifactExtension)\\\" -Value $_\\n                New-OctopusArtifact \\\"output.$(Get-ArtifactExtension)\\\"\\n            }\\n        }\\n}\\n\"\n        \"Octopus.Action.Script.ScriptSource\"            = \"Inline\"\n        \"K8SInspectResource\"                            = \"service\"\n        \"Octopus.Action.Script.Syntax\"                  = \"PowerShell\"\n        \"Octopus.Action.KubernetesContainers.Namespace\" = \"#{if K8SInspectNamespace}#{K8SInspectNamespace}#{/if}#{unless K8SInspectNamespace}#{Octopus.Action.Kubernetes.Namespace}#{/unless}\"\n        \"K8SInspectNames\"                               = \"#{Kubernetes.Service.Name}*\"\n        \"K8SInspectKubectlVerb\"                         = \"get\"\n      }\n      container {\n        feed_id = local.docker_hub_feed_id\n        image   = \"octopuslabs/k8s-workertools\"\n      }\n      environments = [\n        length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n        length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n        length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n      ]\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = [\"EKS_Reference_Cluster\"]\n  }\n\n  step {\n    condition           = \"Always\"\n    name                = \"Feedback\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.Script\"\n      name                               = \"Feedback\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      properties                         = {\n        \"Octopus.Action.RunOnServer\"         = \"true\"\n        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"\n        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"\n        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"\n      }\n      environments          = []\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = []\n  }\n}\n\nresource \"octopusdeploy_runbook\" \"runbook_octopub_products_get_deployment\" {\n  count             = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0\n  name              = \"\uD83D\uDEE0\uFE0F Get Deployment\"\n  project_id        = octopusdeploy_project.project_octopub_products[0].id\n  environment_scope = \"Specified\"\n  environments      = [\n    length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n    length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n    length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n  ]\n  force_package_download      = false\n  default_guided_failure_mode = \"Off\"\n  description                 = <<EOT\n**Action**: Returns the deployments.\n\n**Affects**: Nothing - this runbook makes no changes.\nEOT\n  multi_tenancy_mode          = \"Untenanted\"\n\n  retention_policy {\n    quantity_to_keep    = 100\n    should_keep_forever = false\n  }\n\n  connectivity_policy {\n    allow_deployments_to_no_targets = true\n    exclude_unhealthy_targets       = false\n    skip_machine_behavior           = \"None\"\n  }\n}\n\nresource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_products_get_deployment\" {\n  count      = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? 1 : 0\n  runbook_id = octopusdeploy_runbook.runbook_octopub_products_get_deployment[0].id\n\n  step {\n    condition           = \"Success\"\n    name                = \"Get Deployment\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.KubernetesRunScript\"\n      name                               = \"Get Deployment\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      worker_pool_variable               = \"\"\n      properties                         = {\n        \"K8SInspectCreateArtifact\"                      = \"False\"\n        \"Octopus.Action.Script.ScriptBody\"              = \"\\u003c#\\n    This script provides a general purpose method for querying Kubernetes resources. It supports common operations\\n    like get, describe, logs and output formats like yaml and json. Output can be captured as artifacts.\\n#\\u003e\\n\\n\\u003c#\\n.Description\\nExecute an application, capturing the output. Based on https://stackoverflow.com/a/33652732/157605\\n#\\u003e\\nFunction Execute-Command ($commandPath, $commandArguments)\\n{\\n  Write-Host \\\"Executing: $commandPath $($commandArguments -join \\\" \\\")\\\"\\n  \\n  Try {\\n    $pinfo = New-Object System.Diagnostics.ProcessStartInfo\\n    $pinfo.FileName = $commandPath\\n    $pinfo.RedirectStandardError = $true\\n    $pinfo.RedirectStandardOutput = $true\\n    $pinfo.UseShellExecute = $false\\n    $pinfo.Arguments = $commandArguments\\n    $p = New-Object System.Diagnostics.Process\\n    $p.StartInfo = $pinfo\\n    $p.Start() | Out-Null\\n    [pscustomobject]@{\\n        stdout = $p.StandardOutput.ReadToEnd()\\n        stderr = $p.StandardError.ReadToEnd()\\n        ExitCode = $p.ExitCode\\n    }\\n    $p.WaitForExit()\\n  }\\n  Catch {\\n     exit\\n  }\\n}\\n\\n\\u003c#\\n.Description\\nFind any resource names that match a wildcard input if one was specified\\n#\\u003e\\nfunction Get-Resources() \\n{\\n    $names = $OctopusParameters[\\\"K8SInspectNames\\\"] -Split \\\"`n\\\" | % {$_.Trim()}\\n    \\n    if ($OctopusParameters[\\\"K8SInspectNames\\\"] -match '\\\\*' )\\n    {\\n        return Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", $OctopusParameters[\\\"K8SInspectResource\\\"])) |\\n            # Select the stdout property from the execution\\n            Select-Object -ExpandProperty stdout |\\n            # Convert the output from JSON\\n            ConvertFrom-JSON | \\n            # Get the items object from the kubectl response\\n            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\\n            # Extract the name\\n            % {$_.metadata.name} |\\n            # Find any matching resources\\n            ? {$k8sName = $_; ($names | ? {$k8sName -like $_}).Count -ne 0}\\n    }\\n    else\\n    {\\n        return $names\\n    }\\n}\\n\\n\\u003c#\\n.Description\\nGet the kubectl arguments for a given action\\n#\\u003e\\nfunction Get-KubectlVerb() \\n{\\n    switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\\n    {\\n        \\\"get json\\\" {return ,@(\\\"-o\\\", \\\"json\\\", \\\"get\\\")}\\n        \\\"get yaml\\\" {return ,@(\\\"-o\\\", \\\"yaml\\\", \\\"get\\\")}\\n        \\\"describe\\\" {return ,@(\\\"describe\\\")}\\n        \\\"logs\\\" {return ,@(\\\"logs\\\")}\\n        \\\"logs tail\\\" {return ,@(\\\"logs\\\", \\\"--tail\\\", \\\"100\\\")}\\n        \\\"previous logs\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\")}\\n        \\\"previous logs tail\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\", \\\"--tail\\\", \\\"100\\\")}\\n        default {return ,@(\\\"get\\\")}\\n    }\\n}\\n\\n\\u003c#\\n.Description\\nGet an appropiate file extension based on the selected action\\n#\\u003e\\nfunction Get-ArtifactExtension() \\n{\\n   switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\\n    {\\n        \\\"get json\\\" {\\\"json\\\"}\\n        \\\"get yaml\\\" {\\\"yaml\\\"}\\n        default {\\\"txt\\\"}\\n    }\\n}\\n\\nif ($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"] -like \\\"*logs*\\\") \\n{\\n    if ( -not @($OctopusParameters[\\\"K8SInspectResource\\\"]) -like \\\"pod*\\\")\\n    {\\n        Write-Error \\\"Logs can only be returned for pods, not $($OctopusParameters[\\\"K8SInspectResource\\\"])\\\"\\n    }\\n    else\\n    {\\n        Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", \\\"pods\\\") + (Get-Resources)) |\\n            # Select the stdout property from the execution\\n            Select-Object -ExpandProperty stdout |\\n            # Convert the output from JSON\\n            ConvertFrom-JSON | \\n            # Get the items object from the kubectl response\\n            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\\n            # Get the pod logs for each container\\n            % {\\n                $podDetails = $_\\n                @{\\n                    logs=$podDetails.spec.containers | % {$logs=\\\"\\\"} {$logs += (Select-Object -InputObject (Execute-Command kubectl ((Get-KubectlVerb) + @($podDetails.metadata.name, \\\"-c\\\", $_.name))) -ExpandProperty stdout)} {$logs}; \\n                    name=$podDetails.metadata.name\\n                }                \\n            } |\\n            # Write the output\\n            % {Write-Host $_.logs; $_} |\\n            # Optionally capture the artifact\\n            % {\\n                if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \\n                {\\n                    Set-Content -Path \\\"$($_.name).$(Get-ArtifactExtension)\\\" -Value $_.logs\\n                    New-OctopusArtifact \\\"$($_.name).$(Get-ArtifactExtension)\\\"\\n                }\\n            }\\n    }      \\n}\\nelse\\n{\\n    Execute-Command kubectl ((Get-KubectlVerb) + @($OctopusParameters[\\\"K8SInspectResource\\\"]) + (Get-Resources)) |\\n        % {Select-Object -InputObject $_ -ExpandProperty stdout} |\\n        % {Write-Host $_; $_} |\\n        % {\\n            if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \\n            {\\n                Set-Content -Path \\\"output.$(Get-ArtifactExtension)\\\" -Value $_\\n                New-OctopusArtifact \\\"output.$(Get-ArtifactExtension)\\\"\\n            }\\n        }\\n}\\n\"\n        \"Octopus.Action.Script.ScriptSource\"            = \"Inline\"\n        \"K8SInspectResource\"                            = \"deployment\"\n        \"Octopus.Action.Script.Syntax\"                  = \"PowerShell\"\n        \"Octopus.Action.KubernetesContainers.Namespace\" = \"#{if K8SInspectNamespace}#{K8SInspectNamespace}#{/if}#{unless K8SInspectNamespace}#{Octopus.Action.Kubernetes.Namespace}#{/unless}\"\n        \"K8SInspectNames\"                               = \"#{Kubernetes.Deployment.Name}*\"\n        \"K8SInspectKubectlVerb\"                         = \"get\"\n      }\n      container {\n        feed_id = local.docker_hub_feed_id\n        image   = \"octopuslabs/k8s-workertools\"\n      }\n      environments = [\n        length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n        length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n        length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n      ]\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = [\"EKS_Reference_Cluster\"]\n  }\n\n  step {\n    condition           = \"Always\"\n    name                = \"Feedback\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.Script\"\n      name                               = \"Feedback\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      properties                         = {\n        \"Octopus.Action.RunOnServer\"         = \"true\"\n        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"\n        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"\n        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"\n      }\n      environments          = []\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = []\n  }\n}\n#endregion\n\n#region Audits\ndata \"octopusdeploy_projects\" \"octopub_audits\" {\n  partial_name = \"EKS Octopub Audits\"\n  skip         = 0\n  take         = 1\n}\n\nresource \"octopusdeploy_variable\" \"audits_deployment_feed\" {\n  count        = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0\n  owner_id     = octopusdeploy_project.project_octopub_audits[0].id\n  value        = local.docker_hub_feed_id\n  name         = \"Kubernetes.Deployment.Feed\"\n  type         = \"String\"\n  description  = \"The feed ID hosting the image\"\n  is_sensitive = false\n}\n\nresource \"octopusdeploy_variable\" \"audits_deployment_image\" {\n  count        = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0\n  owner_id     = octopusdeploy_project.project_octopub_audits[0].id\n  value        = \"octopussamples/octopub-audit-microservice\"\n  name         = \"Kubernetes.Deployment.Image\"\n  type         = \"String\"\n  description  = \"The image to deploy\"\n  is_sensitive = false\n}\n\nresource \"octopusdeploy_variable\" \"audits_deployment_port\" {\n  count        = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0\n  owner_id     = octopusdeploy_project.project_octopub_audits[0].id\n  value        = \"10000\"\n  name         = \"Kubernetes.Deployment.Port\"\n  type         = \"String\"\n  description  = \"The port exposed by the web app\"\n  is_sensitive = false\n}\n\nresource \"octopusdeploy_variable\" \"audits_deployment_name\" {\n  count        = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0\n  owner_id     = octopusdeploy_project.project_octopub_audits[0].id\n  value        = \"audits\"\n  name         = \"Kubernetes.Deployment.Name\"\n  type         = \"String\"\n  description  = \"\"\n  is_sensitive = false\n  depends_on   = []\n}\n\nresource \"octopusdeploy_variable\" \"audits_service_name\" {\n  count        = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0\n  owner_id     = octopusdeploy_project.project_octopub_audits[0].id\n  value        = \"audits\"\n  name         = \"Kubernetes.Service.Name\"\n  type         = \"String\"\n  description  = \"\"\n  is_sensitive = false\n  depends_on   = []\n}\n\nresource \"octopusdeploy_variable\" \"audits_ingress_name\" {\n  count        = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0\n  owner_id     = octopusdeploy_project.project_octopub_audits[0].id\n  value        = \"audits\"\n  name         = \"Kubernetes.Ingress.Name\"\n  type         = \"String\"\n  description  = \"\"\n  is_sensitive = false\n  depends_on   = []\n}\n\nresource \"octopusdeploy_project\" \"project_octopub_audits\" {\n  count                                = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0\n  name                                 = \"EKS Octopub Audits\"\n  auto_create_release                  = false\n  default_guided_failure_mode          = \"Off\"\n  default_to_skip_if_already_installed = false\n  discrete_channel_release             = false\n  is_disabled                          = false\n  is_version_controlled                = false\n  lifecycle_id                         = length(data.octopusdeploy_lifecycles.devsecops.lifecycles) == 0 ? octopusdeploy_lifecycle.lifecycle_devsecops[0].id : data.octopusdeploy_lifecycles.devsecops.lifecycles[0].id\n  project_group_id                     = length(data.octopusdeploy_project_groups.eks.project_groups) == 0 ? octopusdeploy_project_group.project_group_eks[0].id : data.octopusdeploy_project_groups.eks.project_groups[0].id\n  included_library_variable_sets       = []\n  tenanted_deployment_participation    = \"Untenanted\"\n\n  connectivity_policy {\n    allow_deployments_to_no_targets = true\n    exclude_unhealthy_targets       = false\n    skip_machine_behavior           = \"None\"\n  }\n\n  versioning_strategy {\n    template = \"#{Octopus.Version.LastMajor}.#{Octopus.Version.LastMinor}.#{Octopus.Version.NextPatch}\"\n  }\n\n  lifecycle {\n    ignore_changes = []\n  }\n  description = <<EOT\nDeploys the Octopub Audits Service\n\n**Source**: [GitHub](https://github.com/OctopusSolutionsEngineering/Octopub)\n\n**Build**: [GitHub Actions](https://github.com/OctopusSolutionsEngineering/Octopub/actions)\n\n**Issues**: [GitHub Issues](https://github.com/OctopusSolutionsEngineering/Octopub/issues)\nEOT\n}\n\nresource \"octopusdeploy_deployment_process\" \"deployment_process_octopub_audits\" {\n  count      = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0\n  project_id = octopusdeploy_project.project_octopub_audits[0].id\n\n  step {\n    condition           = \"Success\"\n    name                = \"Deploy Container\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.KubernetesDeployContainers\"\n      name                               = \"Deploy Container\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = true\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      properties                         = {\n        \"Octopus.Action.KubernetesContainers.Replicas\"               = \"1\"\n        \"Octopus.Action.KubernetesContainers.DeploymentResourceType\" = \"Deployment\"\n        \"Octopus.Action.KubernetesContainers.IngressAnnotations\"     = jsonencode([\n          {\n            \"optionError\"  = null\n            \"option2\"      = \"\"\n            \"option2Error\" = null\n            \"key\"          = \"nginx.ingress.kubernetes.io/rewrite-target\"\n            \"keyError\"     = null\n            \"value\"        = \"$1$2\"\n            \"valueError\"   = null\n            \"option\"       = \"\"\n          },\n          {\n            \"keyError\"     = null\n            \"value\"        = \"true\"\n            \"valueError\"   = null\n            \"option\"       = \"\"\n            \"optionError\"  = null\n            \"option2\"      = \"\"\n            \"option2Error\" = null\n            \"key\"          = \"nginx.ingress.kubernetes.io/use-regex\"\n          },\n        ])\n        \"Octopus.Action.KubernetesContainers.DeploymentStyle\" = \"RollingUpdate\"\n        \"Octopus.Action.KubernetesContainers.IngressName\"     = \"#{Kubernetes.Ingress.Name}\"\n        \"Octopus.Action.KubernetesContainers.DeploymentName\"  = \"#{Kubernetes.Deployment.Name}\"\n        \"Octopus.Action.KubernetesContainers.IngressRules\"    = jsonencode([\n          {\n            \"host\" = \"\"\n            \"http\" = {\n              \"paths\" = [\n                {\n                  \"key\"     = \"/#{Octopus.Action.Kubernetes.Namespace}(/api/audits)(/.*)?\"\n                  \"value\"   = \"web\"\n                  \"option\"  = \"\"\n                  \"option2\" = \"ImplementationSpecific\"\n                },\n              ]\n            }\n          },\n        ])\n        \"OctopusUseBundledTooling\"                       = \"False\"\n        \"Octopus.Action.KubernetesContainers.Containers\" = jsonencode([\n          {\n            \"Args\"                         = []\n            \"FieldRefEnvironmentVariables\" = []\n            \"SecretEnvFromSource\"          = []\n            \"Command\"                      = []\n            \"Ports\"                        = [\n              {\n                \"option2Error\" = null\n                \"optionError\"  = null\n                \"value\"        = \"#{Kubernetes.Deployment.Port}\"\n                \"valueError\"   = null\n                \"key\"          = \"web\"\n                \"keyError\"     = null\n                \"option\"       = \"TCP\"\n                \"option2\"      = \"\"\n              },\n            ]\n            \"Resources\" = {\n              \"limits\" = {\n                \"storage\"          = \"\"\n                \"amdGpu\"           = \"\"\n                \"cpu\"              = \"\"\n                \"ephemeralStorage\" = \"\"\n                \"memory\"           = \"\"\n                \"nvidiaGpu\"        = \"\"\n              }\n              \"requests\" = {\n                \"amdGpu\"           = \"\"\n                \"cpu\"              = \"\"\n                \"ephemeralStorage\" = \"\"\n                \"memory\"           = \"\"\n                \"nvidiaGpu\"        = \"\"\n                \"storage\"          = \"\"\n              }\n            }\n            \"SecretEnvironmentVariables\" = []\n            \"SecurityContext\"            = {\n              \"runAsNonRoot\"   = \"True\"\n              \"runAsUser\"      = \"\"\n              \"seLinuxOptions\" = {\n                \"level\" = \"\"\n                \"role\"  = \"\"\n                \"type\"  = \"\"\n                \"user\"  = \"\"\n              }\n              \"allowPrivilegeEscalation\" = \"\"\n              \"capabilities\"             = {\n                \"add\"  = []\n                \"drop\" = [\n                  \"ALL\",\n                ]\n              }\n              \"privileged\"             = \"\"\n              \"readOnlyRootFilesystem\" = \"\"\n              \"runAsGroup\"             = \"\"\n            }\n            \"TerminationMessagePath\" = \"\"\n            \"EnvironmentVariables\"   = [\n              {\n                \"key\"          = \"COGNITO_DISABLE_AUTH\"\n                \"keyError\"     = null\n                \"value\"        = \"True\"\n                \"valueError\"   = null\n                \"option\"       = \"\"\n                \"optionError\"  = null\n                \"option2\"      = \"\"\n                \"option2Error\" = null\n              },\n              {\n                \"key\"          = \"MIGRATE_AT_START\"\n                \"keyError\"     = null\n                \"value\"        = \"True\"\n                \"valueError\"   = null\n                \"option\"       = \"\"\n                \"optionError\"  = null\n                \"option2\"      = \"\"\n                \"option2Error\" = null\n              },\n            ]\n            \"LivenessProbe\" = {\n              \"successThreshold\" = \"\"\n              \"tcpSocket\"        = {\n                \"port\" = \"\"\n                \"host\" = \"\"\n              }\n              \"exec\" = {\n                \"command\" = []\n              }\n              \"failureThreshold\" = \"\"\n              \"periodSeconds\"    = \"\"\n              \"type\"             = \"\"\n              \"httpGet\"          = {\n                \"host\"        = \"\"\n                \"httpHeaders\" = []\n                \"path\"        = \"\"\n                \"port\"        = \"\"\n                \"scheme\"      = \"\"\n              }\n              \"initialDelaySeconds\" = \"\"\n              \"timeoutSeconds\"      = \"\"\n            }\n            \"ReadinessProbe\" = {\n              \"exec\" = {\n                \"command\" = []\n              }\n              \"failureThreshold\" = \"\"\n              \"timeoutSeconds\"   = \"\"\n              \"successThreshold\" = \"\"\n              \"tcpSocket\"        = {\n                \"host\" = \"\"\n                \"port\" = \"\"\n              }\n              \"type\"    = \"\"\n              \"httpGet\" = {\n                \"host\"        = \"\"\n                \"httpHeaders\" = []\n                \"path\"        = \"\"\n                \"port\"        = \"\"\n                \"scheme\"      = \"\"\n              }\n              \"initialDelaySeconds\" = \"\"\n              \"periodSeconds\"       = \"\"\n            }\n            \"TerminationMessagePolicy\"      = \"\"\n            \"VolumeMounts\"                  = []\n            \"ConfigMapEnvFromSource\"        = []\n            \"ConfigMapEnvironmentVariables\" = []\n            \"CreateFeedSecrets\"             = \"False\"\n            \"Lifecycle\"                     = {\n              \"PostStart\" = null\n              \"PreStop\"   = null\n            }\n            \"Name\"         = \"web\"\n            \"StartupProbe\" = {\n              \"successThreshold\" = \"\"\n              \"tcpSocket\"        = {\n                \"host\" = \"\"\n                \"port\" = \"\"\n              }\n              \"failureThreshold\" = \"\"\n              \"httpGet\"          = {\n                \"host\"        = \"\"\n                \"httpHeaders\" = []\n                \"path\"        = \"\"\n                \"port\"        = \"\"\n                \"scheme\"      = \"\"\n              }\n              \"initialDelaySeconds\" = \"\"\n              \"type\"                = \"\"\n              \"exec\"                = {\n                \"command\" = []\n              }\n              \"periodSeconds\"  = \"\"\n              \"timeoutSeconds\" = \"\"\n            }\n          },\n        ])\n        \"Octopus.Action.KubernetesContainers.ServiceName\"         = \"#{Kubernetes.Service.Name}\"\n        \"Octopus.Action.KubernetesContainers.PodManagementPolicy\" = \"OrderedReady\"\n        \"Octopus.Action.Kubernetes.DeploymentTimeout\"             = \"180\"\n        \"Octopus.Action.RunOnServer\"                              = \"true\"\n        \"Octopus.Action.KubernetesContainers.IngressClassName\"    = \"nginx\"\n        \"Octopus.Action.KubernetesContainers.ServicePorts\"        = jsonencode([\n          {\n            \"port\"       = \"80\"\n            \"protocol\"   = \"TCP\"\n            \"targetPort\" = \"web\"\n            \"name\"       = \"web\"\n            \"nodePort\"   = \"\"\n          },\n        ])\n        \"Octopus.Action.Kubernetes.ResourceStatusCheck\"       = \"True\"\n        \"Octopus.Action.KubernetesContainers.ServiceNameType\" = \"External\"\n        \"Octopus.Action.KubernetesContainers.ServiceType\"     = \"ClusterIP\"\n      }\n      container {\n        feed_id = local.docker_hub_feed_id\n        image   = \"octopuslabs/k8s-workertools\"\n      }\n\n      environments = [\n        length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n        length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n        length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n      ]\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n\n      package {\n        name                      = \"web\"\n        package_id                = \"#{Kubernetes.Deployment.Image}\"\n        acquisition_location      = \"NotAcquired\"\n        extract_during_deployment = false\n        feed_id                   = \"#{Kubernetes.Deployment.Feed}\"\n        properties                = { Extract = \"False\", PackageParameterName = \"\", SelectionMode = \"immediate\" }\n      }\n      features = [\n        \"\", \"Octopus.Features.KubernetesService\", \"Octopus.Features.KubernetesIngress\",\n        \"Octopus.Features.KubernetesConfigMap\", \"Octopus.Features.KubernetesSecret\"\n      ]\n    }\n\n    properties   = {}\n    target_roles = [\"EKS_Reference_Cluster\"]\n  }\n\n  step {\n    condition           = \"Success\"\n    name                = \"Smoke Test\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.KubernetesRunScript\"\n      name                               = \"Smoke Test\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      properties                         = {\n        \"Octopus.Action.RunOnServer\"         = \"true\"\n        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"\n        \"Octopus.Action.Script.Syntax\"       = \"Bash\"\n        \"Octopus.Action.Script.ScriptBody\"   = \"for i in {1..30}\\ndo\\n\\tHOSTNAME=$(kubectl get ingress #{Kubernetes.Ingress.Name} -o json -n development | jq -r '.status.loadBalancer.ingress[0].hostname')\\n    if [[ -n \\\"$${HOSTNAME}\\\" ]]\\n  \\tthen\\n    \\tbreak\\n  \\tfi\\n  \\techo \\\"Waiting for ingress hostname\\\"\\n  \\tsleep 10\\ndone\\n    \\n\\n# Load balancers can take a minute or so before their DNS is propagated.\\n# A status code of 000 means curl could not resolve the DNS name, so we wait for a bit until DNS is updated.\\necho \\\"Testing http://$${HOSTNAME}/#{Octopus.Action.Kubernetes.Namespace}/api/audits\\\"\\necho \\\"Waiting for DNS to propagate. This can take a while for a new load balancer.\\\"\\nfor i in {1..30}\\ndo\\n  CODE=$(curl -o /dev/null -s -w \\\"%%{http_code}\\\\n\\\" http://$${HOSTNAME}/#{Octopus.Action.Kubernetes.Namespace}/api/audits)\\n  if [[ \\\"$${CODE}\\\" == \\\"200\\\" ]]\\n  then\\n    break\\n  fi\\n  echo \\\"Waiting for DNS name to be resolvable and for service to respond\\\"\\n  sleep 10\\ndone\\n\\necho \\\"response code: $${CODE}\\\"\\nif [[ \\\"$${CODE}\\\" == \\\"200\\\" ]]\\nthen\\n    echo \\\"success\\\"\\n    exit 0\\nelse\\n    echo \\\"error\\\"\\n    exit 1\\nfi\"\n      }\n      container {\n        feed_id = local.docker_hub_feed_id\n        image   = \"octopuslabs/k8s-workertools\"\n      }\n      environments = [\n        length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n        length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n        length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n      ]\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = [\"EKS_Reference_Cluster\"]\n  }\n\n  step {\n    condition           = \"Success\"\n    name                = \"Security Scan\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.Script\"\n      name                               = \"Security Scan\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = true\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      properties                         = {\n        \"Octopus.Action.RunOnServer\"         = \"true\"\n        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"\n        \"Octopus.Action.Script.Syntax\"       = \"Bash\"\n        \"Octopus.Action.Script.ScriptBody\"   = local.security_scan_script\n      }\n      environments          = []\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features = []\n    }\n\n    properties   = {}\n    target_roles = []\n  }\n\n  step {\n    condition           = \"Always\"\n    name                = \"Feedback\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.Script\"\n      name                               = \"Feedback\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      properties                         = {\n        \"Octopus.Action.RunOnServer\"         = \"true\"\n        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"\n        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"\n        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"\n      }\n      environments          = []\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = []\n  }\n}\n\nresource \"octopusdeploy_runbook\" \"runbook_octopub_audits_get_pod_logs\" {\n  count             = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0\n  name              = \"\uD83D\uDEE0\uFE0F Get Pod Logs\"\n  project_id        = octopusdeploy_project.project_octopub_audits[0].id\n  environment_scope = \"Specified\"\n  environments      = [\n    length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n    length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n    length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n  ]\n  force_package_download      = false\n  default_guided_failure_mode = \"Off\"\n  description                 = <<EOT\n**Action**: Returns the pod logs.\n\n**Affects**: Nothing - this runbook makes no changes.\nEOT\n  multi_tenancy_mode          = \"Untenanted\"\n\n  retention_policy {\n    quantity_to_keep    = 100\n    should_keep_forever = false\n  }\n\n  connectivity_policy {\n    allow_deployments_to_no_targets = true\n    exclude_unhealthy_targets       = false\n    skip_machine_behavior           = \"None\"\n  }\n}\n\nresource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_audits_get_pod_logs\" {\n  count      = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0\n  runbook_id = octopusdeploy_runbook.runbook_octopub_audits_get_pod_logs[0].id\n\n  step {\n    condition           = \"Success\"\n    name                = \"Get Pod Logs\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.KubernetesRunScript\"\n      name                               = \"Get Pod Logs\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      worker_pool_variable               = \"\"\n      properties                         = {\n        \"K8SInspectCreateArtifact\"                      = \"False\"\n        \"Octopus.Action.Script.ScriptBody\"              = \"\\u003c#\\n    This script provides a general purpose method for querying Kubernetes resources. It supports common operations\\n    like get, describe, logs and output formats like yaml and json. Output can be captured as artifacts.\\n#\\u003e\\n\\n\\u003c#\\n.Description\\nExecute an application, capturing the output. Based on https://stackoverflow.com/a/33652732/157605\\n#\\u003e\\nFunction Execute-Command ($commandPath, $commandArguments)\\n{\\n  Write-Host \\\"Executing: $commandPath $($commandArguments -join \\\" \\\")\\\"\\n  \\n  Try {\\n    $pinfo = New-Object System.Diagnostics.ProcessStartInfo\\n    $pinfo.FileName = $commandPath\\n    $pinfo.RedirectStandardError = $true\\n    $pinfo.RedirectStandardOutput = $true\\n    $pinfo.UseShellExecute = $false\\n    $pinfo.Arguments = $commandArguments\\n    $p = New-Object System.Diagnostics.Process\\n    $p.StartInfo = $pinfo\\n    $p.Start() | Out-Null\\n    [pscustomobject]@{\\n        stdout = $p.StandardOutput.ReadToEnd()\\n        stderr = $p.StandardError.ReadToEnd()\\n        ExitCode = $p.ExitCode\\n    }\\n    $p.WaitForExit()\\n  }\\n  Catch {\\n     exit\\n  }\\n}\\n\\n\\u003c#\\n.Description\\nFind any resource names that match a wildcard input if one was specified\\n#\\u003e\\nfunction Get-Resources() \\n{\\n    $names = $OctopusParameters[\\\"K8SInspectNames\\\"] -Split \\\"`n\\\" | % {$_.Trim()}\\n    \\n    if ($OctopusParameters[\\\"K8SInspectNames\\\"] -match '\\\\*' )\\n    {\\n        return Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", $OctopusParameters[\\\"K8SInspectResource\\\"])) |\\n            # Select the stdout property from the execution\\n            Select-Object -ExpandProperty stdout |\\n            # Convert the output from JSON\\n            ConvertFrom-JSON | \\n            # Get the items object from the kubectl response\\n            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\\n            # Extract the name\\n            % {$_.metadata.name} |\\n            # Find any matching resources\\n            ? {$k8sName = $_; ($names | ? {$k8sName -like $_}).Count -ne 0}\\n    }\\n    else\\n    {\\n        return $names\\n    }\\n}\\n\\n\\u003c#\\n.Description\\nGet the kubectl arguments for a given action\\n#\\u003e\\nfunction Get-KubectlVerb() \\n{\\n    switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\\n    {\\n        \\\"get json\\\" {return ,@(\\\"-o\\\", \\\"json\\\", \\\"get\\\")}\\n        \\\"get yaml\\\" {return ,@(\\\"-o\\\", \\\"yaml\\\", \\\"get\\\")}\\n        \\\"describe\\\" {return ,@(\\\"describe\\\")}\\n        \\\"logs\\\" {return ,@(\\\"logs\\\")}\\n        \\\"logs tail\\\" {return ,@(\\\"logs\\\", \\\"--tail\\\", \\\"100\\\")}\\n        \\\"previous logs\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\")}\\n        \\\"previous logs tail\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\", \\\"--tail\\\", \\\"100\\\")}\\n        default {return ,@(\\\"get\\\")}\\n    }\\n}\\n\\n\\u003c#\\n.Description\\nGet an appropiate file extension based on the selected action\\n#\\u003e\\nfunction Get-ArtifactExtension() \\n{\\n   switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\\n    {\\n        \\\"get json\\\" {\\\"json\\\"}\\n        \\\"get yaml\\\" {\\\"yaml\\\"}\\n        default {\\\"txt\\\"}\\n    }\\n}\\n\\nif ($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"] -like \\\"*logs*\\\") \\n{\\n    if ( -not @($OctopusParameters[\\\"K8SInspectResource\\\"]) -like \\\"pod*\\\")\\n    {\\n        Write-Error \\\"Logs can only be returned for pods, not $($OctopusParameters[\\\"K8SInspectResource\\\"])\\\"\\n    }\\n    else\\n    {\\n        Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", \\\"pods\\\") + (Get-Resources)) |\\n            # Select the stdout property from the execution\\n            Select-Object -ExpandProperty stdout |\\n            # Convert the output from JSON\\n            ConvertFrom-JSON | \\n            # Get the items object from the kubectl response\\n            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\\n            # Get the pod logs for each container\\n            % {\\n                $podDetails = $_\\n                @{\\n                    logs=$podDetails.spec.containers | % {$logs=\\\"\\\"} {$logs += (Select-Object -InputObject (Execute-Command kubectl ((Get-KubectlVerb) + @($podDetails.metadata.name, \\\"-c\\\", $_.name))) -ExpandProperty stdout)} {$logs}; \\n                    name=$podDetails.metadata.name\\n                }                \\n            } |\\n            # Write the output\\n            % {Write-Host $_.logs; $_} |\\n            # Optionally capture the artifact\\n            % {\\n                if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \\n                {\\n                    Set-Content -Path \\\"$($_.name).$(Get-ArtifactExtension)\\\" -Value $_.logs\\n                    New-OctopusArtifact \\\"$($_.name).$(Get-ArtifactExtension)\\\"\\n                }\\n            }\\n    }      \\n}\\nelse\\n{\\n    Execute-Command kubectl ((Get-KubectlVerb) + @($OctopusParameters[\\\"K8SInspectResource\\\"]) + (Get-Resources)) |\\n        % {Select-Object -InputObject $_ -ExpandProperty stdout} |\\n        % {Write-Host $_; $_} |\\n        % {\\n            if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \\n            {\\n                Set-Content -Path \\\"output.$(Get-ArtifactExtension)\\\" -Value $_\\n                New-OctopusArtifact \\\"output.$(Get-ArtifactExtension)\\\"\\n            }\\n        }\\n}\\n\"\n        \"Octopus.Action.Script.ScriptSource\"            = \"Inline\"\n        \"K8SInspectResource\"                            = \"pod\"\n        \"Octopus.Action.Script.Syntax\"                  = \"PowerShell\"\n        \"Octopus.Action.KubernetesContainers.Namespace\" = \"#{if K8SInspectNamespace}#{K8SInspectNamespace}#{/if}#{unless K8SInspectNamespace}#{Octopus.Action.Kubernetes.Namespace}#{/unless}\"\n        \"K8SInspectNames\"                               = \"#{Kubernetes.Deployment.Name}*\"\n        \"K8SInspectKubectlVerb\"                         = \"logs\"\n      }\n      container {\n        feed_id = local.docker_hub_feed_id\n        image   = \"octopuslabs/k8s-workertools\"\n      }\n      environments = [\n        length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n        length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n        length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n      ]\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = [\"EKS_Reference_Cluster\"]\n  }\n\n  step {\n    condition           = \"Always\"\n    name                = \"Feedback\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.Script\"\n      name                               = \"Feedback\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      properties                         = {\n        \"Octopus.Action.RunOnServer\"         = \"true\"\n        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"\n        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"\n        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"\n      }\n      environments          = []\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = []\n  }\n}\n\nresource \"octopusdeploy_runbook\" \"runbook_octopub_audits_get_pods\" {\n  count             = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0\n  name              = \"\uD83D\uDEE0\uFE0F Get Pods\"\n  project_id        = octopusdeploy_project.project_octopub_audits[0].id\n  environment_scope = \"Specified\"\n  environments      = [\n    length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n    length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n    length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n  ]\n  force_package_download      = false\n  default_guided_failure_mode = \"Off\"\n  description                 = <<EOT\n**Action**: Returns the pods.\n\n**Affects**: Nothing - this runbook makes no changes.\nEOT\n  multi_tenancy_mode          = \"Untenanted\"\n\n  retention_policy {\n    quantity_to_keep    = 100\n    should_keep_forever = false\n  }\n\n  connectivity_policy {\n    allow_deployments_to_no_targets = true\n    exclude_unhealthy_targets       = false\n    skip_machine_behavior           = \"None\"\n  }\n}\n\nresource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_audits_get_pods\" {\n  count      = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0\n  runbook_id = octopusdeploy_runbook.runbook_octopub_audits_get_pods[0].id\n\n  step {\n    condition           = \"Success\"\n    name                = \"Get Pods\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.KubernetesRunScript\"\n      name                               = \"Get Pods\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      worker_pool_variable               = \"\"\n      properties                         = {\n        \"K8SInspectCreateArtifact\"                      = \"False\"\n        \"Octopus.Action.Script.ScriptBody\"              = \"\\u003c#\\n    This script provides a general purpose method for querying Kubernetes resources. It supports common operations\\n    like get, describe, logs and output formats like yaml and json. Output can be captured as artifacts.\\n#\\u003e\\n\\n\\u003c#\\n.Description\\nExecute an application, capturing the output. Based on https://stackoverflow.com/a/33652732/157605\\n#\\u003e\\nFunction Execute-Command ($commandPath, $commandArguments)\\n{\\n  Write-Host \\\"Executing: $commandPath $($commandArguments -join \\\" \\\")\\\"\\n  \\n  Try {\\n    $pinfo = New-Object System.Diagnostics.ProcessStartInfo\\n    $pinfo.FileName = $commandPath\\n    $pinfo.RedirectStandardError = $true\\n    $pinfo.RedirectStandardOutput = $true\\n    $pinfo.UseShellExecute = $false\\n    $pinfo.Arguments = $commandArguments\\n    $p = New-Object System.Diagnostics.Process\\n    $p.StartInfo = $pinfo\\n    $p.Start() | Out-Null\\n    [pscustomobject]@{\\n        stdout = $p.StandardOutput.ReadToEnd()\\n        stderr = $p.StandardError.ReadToEnd()\\n        ExitCode = $p.ExitCode\\n    }\\n    $p.WaitForExit()\\n  }\\n  Catch {\\n     exit\\n  }\\n}\\n\\n\\u003c#\\n.Description\\nFind any resource names that match a wildcard input if one was specified\\n#\\u003e\\nfunction Get-Resources() \\n{\\n    $names = $OctopusParameters[\\\"K8SInspectNames\\\"] -Split \\\"`n\\\" | % {$_.Trim()}\\n    \\n    if ($OctopusParameters[\\\"K8SInspectNames\\\"] -match '\\\\*' )\\n    {\\n        return Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", $OctopusParameters[\\\"K8SInspectResource\\\"])) |\\n            # Select the stdout property from the execution\\n            Select-Object -ExpandProperty stdout |\\n            # Convert the output from JSON\\n            ConvertFrom-JSON | \\n            # Get the items object from the kubectl response\\n            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\\n            # Extract the name\\n            % {$_.metadata.name} |\\n            # Find any matching resources\\n            ? {$k8sName = $_; ($names | ? {$k8sName -like $_}).Count -ne 0}\\n    }\\n    else\\n    {\\n        return $names\\n    }\\n}\\n\\n\\u003c#\\n.Description\\nGet the kubectl arguments for a given action\\n#\\u003e\\nfunction Get-KubectlVerb() \\n{\\n    switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\\n    {\\n        \\\"get json\\\" {return ,@(\\\"-o\\\", \\\"json\\\", \\\"get\\\")}\\n        \\\"get yaml\\\" {return ,@(\\\"-o\\\", \\\"yaml\\\", \\\"get\\\")}\\n        \\\"describe\\\" {return ,@(\\\"describe\\\")}\\n        \\\"logs\\\" {return ,@(\\\"logs\\\")}\\n        \\\"logs tail\\\" {return ,@(\\\"logs\\\", \\\"--tail\\\", \\\"100\\\")}\\n        \\\"previous logs\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\")}\\n        \\\"previous logs tail\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\", \\\"--tail\\\", \\\"100\\\")}\\n        default {return ,@(\\\"get\\\")}\\n    }\\n}\\n\\n\\u003c#\\n.Description\\nGet an appropiate file extension based on the selected action\\n#\\u003e\\nfunction Get-ArtifactExtension() \\n{\\n   switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\\n    {\\n        \\\"get json\\\" {\\\"json\\\"}\\n        \\\"get yaml\\\" {\\\"yaml\\\"}\\n        default {\\\"txt\\\"}\\n    }\\n}\\n\\nif ($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"] -like \\\"*logs*\\\") \\n{\\n    if ( -not @($OctopusParameters[\\\"K8SInspectResource\\\"]) -like \\\"pod*\\\")\\n    {\\n        Write-Error \\\"Logs can only be returned for pods, not $($OctopusParameters[\\\"K8SInspectResource\\\"])\\\"\\n    }\\n    else\\n    {\\n        Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", \\\"pods\\\") + (Get-Resources)) |\\n            # Select the stdout property from the execution\\n            Select-Object -ExpandProperty stdout |\\n            # Convert the output from JSON\\n            ConvertFrom-JSON | \\n            # Get the items object from the kubectl response\\n            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\\n            # Get the pod logs for each container\\n            % {\\n                $podDetails = $_\\n                @{\\n                    logs=$podDetails.spec.containers | % {$logs=\\\"\\\"} {$logs += (Select-Object -InputObject (Execute-Command kubectl ((Get-KubectlVerb) + @($podDetails.metadata.name, \\\"-c\\\", $_.name))) -ExpandProperty stdout)} {$logs}; \\n                    name=$podDetails.metadata.name\\n                }                \\n            } |\\n            # Write the output\\n            % {Write-Host $_.logs; $_} |\\n            # Optionally capture the artifact\\n            % {\\n                if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \\n                {\\n                    Set-Content -Path \\\"$($_.name).$(Get-ArtifactExtension)\\\" -Value $_.logs\\n                    New-OctopusArtifact \\\"$($_.name).$(Get-ArtifactExtension)\\\"\\n                }\\n            }\\n    }      \\n}\\nelse\\n{\\n    Execute-Command kubectl ((Get-KubectlVerb) + @($OctopusParameters[\\\"K8SInspectResource\\\"]) + (Get-Resources)) |\\n        % {Select-Object -InputObject $_ -ExpandProperty stdout} |\\n        % {Write-Host $_; $_} |\\n        % {\\n            if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \\n            {\\n                Set-Content -Path \\\"output.$(Get-ArtifactExtension)\\\" -Value $_\\n                New-OctopusArtifact \\\"output.$(Get-ArtifactExtension)\\\"\\n            }\\n        }\\n}\\n\"\n        \"Octopus.Action.Script.ScriptSource\"            = \"Inline\"\n        \"K8SInspectResource\"                            = \"pod\"\n        \"Octopus.Action.Script.Syntax\"                  = \"PowerShell\"\n        \"Octopus.Action.KubernetesContainers.Namespace\" = \"#{if K8SInspectNamespace}#{K8SInspectNamespace}#{/if}#{unless K8SInspectNamespace}#{Octopus.Action.Kubernetes.Namespace}#{/unless}\"\n        \"K8SInspectNames\"                               = \"#{Kubernetes.Deployment.Name}*\"\n        \"K8SInspectKubectlVerb\"                         = \"get\"\n      }\n      container {\n        feed_id = local.docker_hub_feed_id\n        image   = \"octopuslabs/k8s-workertools\"\n      }\n      environments = [\n        length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n        length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n        length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n      ]\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = [\"EKS_Reference_Cluster\"]\n  }\n\n  step {\n    condition           = \"Always\"\n    name                = \"Feedback\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.Script\"\n      name                               = \"Feedback\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      properties                         = {\n        \"Octopus.Action.RunOnServer\"         = \"true\"\n        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"\n        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"\n        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"\n      }\n      environments          = []\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = []\n  }\n}\n\nresource \"octopusdeploy_runbook\" \"runbook_octopub_audits_describe_pods\" {\n  count             = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0\n  name              = \"\uD83D\uDEE0\uFE0F Describe Pods\"\n  project_id        = octopusdeploy_project.project_octopub_audits[0].id\n  environment_scope = \"Specified\"\n  environments      = [\n    length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n    length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n    length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n  ]\n  force_package_download      = false\n  default_guided_failure_mode = \"Off\"\n  description                 = <<EOT\n**Action**: Returns the pods.\n\n**Affects**: Nothing - this runbook makes no changes.\nEOT\n  multi_tenancy_mode          = \"Untenanted\"\n\n  retention_policy {\n    quantity_to_keep    = 100\n    should_keep_forever = false\n  }\n\n  connectivity_policy {\n    allow_deployments_to_no_targets = true\n    exclude_unhealthy_targets       = false\n    skip_machine_behavior           = \"None\"\n  }\n}\n\nresource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_audits_describe_pods\" {\n  count      = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0\n  runbook_id = octopusdeploy_runbook.runbook_octopub_audits_describe_pods[0].id\n\n  step {\n    condition           = \"Success\"\n    name                = \"Describe Pods\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.KubernetesRunScript\"\n      name                               = \"Describe Pods\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      worker_pool_variable               = \"\"\n      properties                         = {\n        \"K8SInspectCreateArtifact\"                      = \"False\"\n        \"Octopus.Action.Script.ScriptBody\"              = \"\\u003c#\\n    This script provides a general purpose method for querying Kubernetes resources. It supports common operations\\n    like get, describe, logs and output formats like yaml and json. Output can be captured as artifacts.\\n#\\u003e\\n\\n\\u003c#\\n.Description\\nExecute an application, capturing the output. Based on https://stackoverflow.com/a/33652732/157605\\n#\\u003e\\nFunction Execute-Command ($commandPath, $commandArguments)\\n{\\n  Write-Host \\\"Executing: $commandPath $($commandArguments -join \\\" \\\")\\\"\\n  \\n  Try {\\n    $pinfo = New-Object System.Diagnostics.ProcessStartInfo\\n    $pinfo.FileName = $commandPath\\n    $pinfo.RedirectStandardError = $true\\n    $pinfo.RedirectStandardOutput = $true\\n    $pinfo.UseShellExecute = $false\\n    $pinfo.Arguments = $commandArguments\\n    $p = New-Object System.Diagnostics.Process\\n    $p.StartInfo = $pinfo\\n    $p.Start() | Out-Null\\n    [pscustomobject]@{\\n        stdout = $p.StandardOutput.ReadToEnd()\\n        stderr = $p.StandardError.ReadToEnd()\\n        ExitCode = $p.ExitCode\\n    }\\n    $p.WaitForExit()\\n  }\\n  Catch {\\n     exit\\n  }\\n}\\n\\n\\u003c#\\n.Description\\nFind any resource names that match a wildcard input if one was specified\\n#\\u003e\\nfunction Get-Resources() \\n{\\n    $names = $OctopusParameters[\\\"K8SInspectNames\\\"] -Split \\\"`n\\\" | % {$_.Trim()}\\n    \\n    if ($OctopusParameters[\\\"K8SInspectNames\\\"] -match '\\\\*' )\\n    {\\n        return Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", $OctopusParameters[\\\"K8SInspectResource\\\"])) |\\n            # Select the stdout property from the execution\\n            Select-Object -ExpandProperty stdout |\\n            # Convert the output from JSON\\n            ConvertFrom-JSON | \\n            # Get the items object from the kubectl response\\n            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\\n            # Extract the name\\n            % {$_.metadata.name} |\\n            # Find any matching resources\\n            ? {$k8sName = $_; ($names | ? {$k8sName -like $_}).Count -ne 0}\\n    }\\n    else\\n    {\\n        return $names\\n    }\\n}\\n\\n\\u003c#\\n.Description\\nGet the kubectl arguments for a given action\\n#\\u003e\\nfunction Get-KubectlVerb() \\n{\\n    switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\\n    {\\n        \\\"get json\\\" {return ,@(\\\"-o\\\", \\\"json\\\", \\\"get\\\")}\\n        \\\"get yaml\\\" {return ,@(\\\"-o\\\", \\\"yaml\\\", \\\"get\\\")}\\n        \\\"describe\\\" {return ,@(\\\"describe\\\")}\\n        \\\"logs\\\" {return ,@(\\\"logs\\\")}\\n        \\\"logs tail\\\" {return ,@(\\\"logs\\\", \\\"--tail\\\", \\\"100\\\")}\\n        \\\"previous logs\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\")}\\n        \\\"previous logs tail\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\", \\\"--tail\\\", \\\"100\\\")}\\n        default {return ,@(\\\"get\\\")}\\n    }\\n}\\n\\n\\u003c#\\n.Description\\nGet an appropiate file extension based on the selected action\\n#\\u003e\\nfunction Get-ArtifactExtension() \\n{\\n   switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\\n    {\\n        \\\"get json\\\" {\\\"json\\\"}\\n        \\\"get yaml\\\" {\\\"yaml\\\"}\\n        default {\\\"txt\\\"}\\n    }\\n}\\n\\nif ($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"] -like \\\"*logs*\\\") \\n{\\n    if ( -not @($OctopusParameters[\\\"K8SInspectResource\\\"]) -like \\\"pod*\\\")\\n    {\\n        Write-Error \\\"Logs can only be returned for pods, not $($OctopusParameters[\\\"K8SInspectResource\\\"])\\\"\\n    }\\n    else\\n    {\\n        Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", \\\"pods\\\") + (Get-Resources)) |\\n            # Select the stdout property from the execution\\n            Select-Object -ExpandProperty stdout |\\n            # Convert the output from JSON\\n            ConvertFrom-JSON | \\n            # Get the items object from the kubectl response\\n            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\\n            # Get the pod logs for each container\\n            % {\\n                $podDetails = $_\\n                @{\\n                    logs=$podDetails.spec.containers | % {$logs=\\\"\\\"} {$logs += (Select-Object -InputObject (Execute-Command kubectl ((Get-KubectlVerb) + @($podDetails.metadata.name, \\\"-c\\\", $_.name))) -ExpandProperty stdout)} {$logs}; \\n                    name=$podDetails.metadata.name\\n                }                \\n            } |\\n            # Write the output\\n            % {Write-Host $_.logs; $_} |\\n            # Optionally capture the artifact\\n            % {\\n                if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \\n                {\\n                    Set-Content -Path \\\"$($_.name).$(Get-ArtifactExtension)\\\" -Value $_.logs\\n                    New-OctopusArtifact \\\"$($_.name).$(Get-ArtifactExtension)\\\"\\n                }\\n            }\\n    }      \\n}\\nelse\\n{\\n    Execute-Command kubectl ((Get-KubectlVerb) + @($OctopusParameters[\\\"K8SInspectResource\\\"]) + (Get-Resources)) |\\n        % {Select-Object -InputObject $_ -ExpandProperty stdout} |\\n        % {Write-Host $_; $_} |\\n        % {\\n            if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \\n            {\\n                Set-Content -Path \\\"output.$(Get-ArtifactExtension)\\\" -Value $_\\n                New-OctopusArtifact \\\"output.$(Get-ArtifactExtension)\\\"\\n            }\\n        }\\n}\\n\"\n        \"Octopus.Action.Script.ScriptSource\"            = \"Inline\"\n        \"K8SInspectResource\"                            = \"pod\"\n        \"Octopus.Action.Script.Syntax\"                  = \"PowerShell\"\n        \"Octopus.Action.KubernetesContainers.Namespace\" = \"#{if K8SInspectNamespace}#{K8SInspectNamespace}#{/if}#{unless K8SInspectNamespace}#{Octopus.Action.Kubernetes.Namespace}#{/unless}\"\n        \"K8SInspectNames\"                               = \"#{Kubernetes.Deployment.Name}*\"\n        \"K8SInspectKubectlVerb\"                         = \"describe\"\n      }\n      container {\n        feed_id = local.docker_hub_feed_id\n        image   = \"octopuslabs/k8s-workertools\"\n      }\n      environments = [\n        length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n        length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n        length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n      ]\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = [\"EKS_Reference_Cluster\"]\n  }\n\n  step {\n    condition           = \"Always\"\n    name                = \"Feedback\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.Script\"\n      name                               = \"Feedback\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      properties                         = {\n        \"Octopus.Action.RunOnServer\"         = \"true\"\n        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"\n        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"\n        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"\n      }\n      environments          = []\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = []\n  }\n}\n\nresource \"octopusdeploy_runbook\" \"runbook_octopub_audits_get_ingress\" {\n  count             = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0\n  name              = \"\uD83D\uDEE0\uFE0F Get Ingress\"\n  project_id        = octopusdeploy_project.project_octopub_audits[0].id\n  environment_scope = \"Specified\"\n  environments      = [\n    length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n    length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n    length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n  ]\n  force_package_download      = false\n  default_guided_failure_mode = \"Off\"\n  description                 = <<EOT\n**Action**: Returns the ingresses.\n\n**Affects**: Nothing - this runbook makes no changes.\n\n**Resolves**: Finding the public IP to access the deployed application.\nEOT\n  multi_tenancy_mode          = \"Untenanted\"\n\n  retention_policy {\n    quantity_to_keep    = 100\n    should_keep_forever = false\n  }\n\n  connectivity_policy {\n    allow_deployments_to_no_targets = true\n    exclude_unhealthy_targets       = false\n    skip_machine_behavior           = \"None\"\n  }\n}\n\nresource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_audits_get_ingress\" {\n  count      = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0\n  runbook_id = octopusdeploy_runbook.runbook_octopub_audits_get_ingress[0].id\n\n  step {\n    condition           = \"Success\"\n    name                = \"Get Ingress\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.KubernetesRunScript\"\n      name                               = \"Get Ingress\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      worker_pool_variable               = \"\"\n      properties                         = {\n        \"K8SInspectCreateArtifact\"                      = \"False\"\n        \"Octopus.Action.Script.ScriptBody\"              = \"\\u003c#\\n    This script provides a general purpose method for querying Kubernetes resources. It supports common operations\\n    like get, describe, logs and output formats like yaml and json. Output can be captured as artifacts.\\n#\\u003e\\n\\n\\u003c#\\n.Description\\nExecute an application, capturing the output. Based on https://stackoverflow.com/a/33652732/157605\\n#\\u003e\\nFunction Execute-Command ($commandPath, $commandArguments)\\n{\\n  Write-Host \\\"Executing: $commandPath $($commandArguments -join \\\" \\\")\\\"\\n  \\n  Try {\\n    $pinfo = New-Object System.Diagnostics.ProcessStartInfo\\n    $pinfo.FileName = $commandPath\\n    $pinfo.RedirectStandardError = $true\\n    $pinfo.RedirectStandardOutput = $true\\n    $pinfo.UseShellExecute = $false\\n    $pinfo.Arguments = $commandArguments\\n    $p = New-Object System.Diagnostics.Process\\n    $p.StartInfo = $pinfo\\n    $p.Start() | Out-Null\\n    [pscustomobject]@{\\n        stdout = $p.StandardOutput.ReadToEnd()\\n        stderr = $p.StandardError.ReadToEnd()\\n        ExitCode = $p.ExitCode\\n    }\\n    $p.WaitForExit()\\n  }\\n  Catch {\\n     exit\\n  }\\n}\\n\\n\\u003c#\\n.Description\\nFind any resource names that match a wildcard input if one was specified\\n#\\u003e\\nfunction Get-Resources() \\n{\\n    $names = $OctopusParameters[\\\"K8SInspectNames\\\"] -Split \\\"`n\\\" | % {$_.Trim()}\\n    \\n    if ($OctopusParameters[\\\"K8SInspectNames\\\"] -match '\\\\*' )\\n    {\\n        return Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", $OctopusParameters[\\\"K8SInspectResource\\\"])) |\\n            # Select the stdout property from the execution\\n            Select-Object -ExpandProperty stdout |\\n            # Convert the output from JSON\\n            ConvertFrom-JSON | \\n            # Get the items object from the kubectl response\\n            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\\n            # Extract the name\\n            % {$_.metadata.name} |\\n            # Find any matching resources\\n            ? {$k8sName = $_; ($names | ? {$k8sName -like $_}).Count -ne 0}\\n    }\\n    else\\n    {\\n        return $names\\n    }\\n}\\n\\n\\u003c#\\n.Description\\nGet the kubectl arguments for a given action\\n#\\u003e\\nfunction Get-KubectlVerb() \\n{\\n    switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\\n    {\\n        \\\"get json\\\" {return ,@(\\\"-o\\\", \\\"json\\\", \\\"get\\\")}\\n        \\\"get yaml\\\" {return ,@(\\\"-o\\\", \\\"yaml\\\", \\\"get\\\")}\\n        \\\"describe\\\" {return ,@(\\\"describe\\\")}\\n        \\\"logs\\\" {return ,@(\\\"logs\\\")}\\n        \\\"logs tail\\\" {return ,@(\\\"logs\\\", \\\"--tail\\\", \\\"100\\\")}\\n        \\\"previous logs\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\")}\\n        \\\"previous logs tail\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\", \\\"--tail\\\", \\\"100\\\")}\\n        default {return ,@(\\\"get\\\")}\\n    }\\n}\\n\\n\\u003c#\\n.Description\\nGet an appropiate file extension based on the selected action\\n#\\u003e\\nfunction Get-ArtifactExtension() \\n{\\n   switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\\n    {\\n        \\\"get json\\\" {\\\"json\\\"}\\n        \\\"get yaml\\\" {\\\"yaml\\\"}\\n        default {\\\"txt\\\"}\\n    }\\n}\\n\\nif ($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"] -like \\\"*logs*\\\") \\n{\\n    if ( -not @($OctopusParameters[\\\"K8SInspectResource\\\"]) -like \\\"pod*\\\")\\n    {\\n        Write-Error \\\"Logs can only be returned for pods, not $($OctopusParameters[\\\"K8SInspectResource\\\"])\\\"\\n    }\\n    else\\n    {\\n        Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", \\\"pods\\\") + (Get-Resources)) |\\n            # Select the stdout property from the execution\\n            Select-Object -ExpandProperty stdout |\\n            # Convert the output from JSON\\n            ConvertFrom-JSON | \\n            # Get the items object from the kubectl response\\n            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\\n            # Get the pod logs for each container\\n            % {\\n                $podDetails = $_\\n                @{\\n                    logs=$podDetails.spec.containers | % {$logs=\\\"\\\"} {$logs += (Select-Object -InputObject (Execute-Command kubectl ((Get-KubectlVerb) + @($podDetails.metadata.name, \\\"-c\\\", $_.name))) -ExpandProperty stdout)} {$logs}; \\n                    name=$podDetails.metadata.name\\n                }                \\n            } |\\n            # Write the output\\n            % {Write-Host $_.logs; $_} |\\n            # Optionally capture the artifact\\n            % {\\n                if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \\n                {\\n                    Set-Content -Path \\\"$($_.name).$(Get-ArtifactExtension)\\\" -Value $_.logs\\n                    New-OctopusArtifact \\\"$($_.name).$(Get-ArtifactExtension)\\\"\\n                }\\n            }\\n    }      \\n}\\nelse\\n{\\n    Execute-Command kubectl ((Get-KubectlVerb) + @($OctopusParameters[\\\"K8SInspectResource\\\"]) + (Get-Resources)) |\\n        % {Select-Object -InputObject $_ -ExpandProperty stdout} |\\n        % {Write-Host $_; $_} |\\n        % {\\n            if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \\n            {\\n                Set-Content -Path \\\"output.$(Get-ArtifactExtension)\\\" -Value $_\\n                New-OctopusArtifact \\\"output.$(Get-ArtifactExtension)\\\"\\n            }\\n        }\\n}\\n\"\n        \"Octopus.Action.Script.ScriptSource\"            = \"Inline\"\n        \"K8SInspectResource\"                            = \"ingress\"\n        \"Octopus.Action.Script.Syntax\"                  = \"PowerShell\"\n        \"Octopus.Action.KubernetesContainers.Namespace\" = \"#{if K8SInspectNamespace}#{K8SInspectNamespace}#{/if}#{unless K8SInspectNamespace}#{Octopus.Action.Kubernetes.Namespace}#{/unless}\"\n        \"K8SInspectNames\"                               = \"#{Kubernetes.Ingress.Name}*\"\n        \"K8SInspectKubectlVerb\"                         = \"get\"\n      }\n      container {\n        feed_id = local.docker_hub_feed_id\n        image   = \"octopuslabs/k8s-workertools\"\n      }\n      environments = [\n        length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n        length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n        length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n      ]\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = [\"EKS_Reference_Cluster\"]\n  }\n\n  step {\n    condition           = \"Always\"\n    name                = \"Feedback\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.Script\"\n      name                               = \"Feedback\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      properties                         = {\n        \"Octopus.Action.RunOnServer\"         = \"true\"\n        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"\n        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"\n        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"\n      }\n      environments          = []\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = []\n  }\n}\n\nresource \"octopusdeploy_runbook\" \"runbook_octopub_audits_get_service\" {\n  count             = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0\n  name              = \"\uD83D\uDEE0\uFE0F Get Service\"\n  project_id        = octopusdeploy_project.project_octopub_audits[0].id\n  environment_scope = \"Specified\"\n  environments      = [\n    length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n    length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n    length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n  ]\n  force_package_download      = false\n  default_guided_failure_mode = \"Off\"\n  description                 = <<EOT\n**Action**: Returns the services.\n\n**Affects**: Nothing - this runbook makes no changes.\nEOT\n  multi_tenancy_mode          = \"Untenanted\"\n\n  retention_policy {\n    quantity_to_keep    = 100\n    should_keep_forever = false\n  }\n\n  connectivity_policy {\n    allow_deployments_to_no_targets = true\n    exclude_unhealthy_targets       = false\n    skip_machine_behavior           = \"None\"\n  }\n}\n\nresource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_audits_get_service\" {\n  count      = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0\n  runbook_id = octopusdeploy_runbook.runbook_octopub_audits_get_service[0].id\n\n  step {\n    condition           = \"Success\"\n    name                = \"Get Service\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.KubernetesRunScript\"\n      name                               = \"Get Service\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      worker_pool_variable               = \"\"\n      properties                         = {\n        \"K8SInspectCreateArtifact\"                      = \"False\"\n        \"Octopus.Action.Script.ScriptBody\"              = \"\\u003c#\\n    This script provides a general purpose method for querying Kubernetes resources. It supports common operations\\n    like get, describe, logs and output formats like yaml and json. Output can be captured as artifacts.\\n#\\u003e\\n\\n\\u003c#\\n.Description\\nExecute an application, capturing the output. Based on https://stackoverflow.com/a/33652732/157605\\n#\\u003e\\nFunction Execute-Command ($commandPath, $commandArguments)\\n{\\n  Write-Host \\\"Executing: $commandPath $($commandArguments -join \\\" \\\")\\\"\\n  \\n  Try {\\n    $pinfo = New-Object System.Diagnostics.ProcessStartInfo\\n    $pinfo.FileName = $commandPath\\n    $pinfo.RedirectStandardError = $true\\n    $pinfo.RedirectStandardOutput = $true\\n    $pinfo.UseShellExecute = $false\\n    $pinfo.Arguments = $commandArguments\\n    $p = New-Object System.Diagnostics.Process\\n    $p.StartInfo = $pinfo\\n    $p.Start() | Out-Null\\n    [pscustomobject]@{\\n        stdout = $p.StandardOutput.ReadToEnd()\\n        stderr = $p.StandardError.ReadToEnd()\\n        ExitCode = $p.ExitCode\\n    }\\n    $p.WaitForExit()\\n  }\\n  Catch {\\n     exit\\n  }\\n}\\n\\n\\u003c#\\n.Description\\nFind any resource names that match a wildcard input if one was specified\\n#\\u003e\\nfunction Get-Resources() \\n{\\n    $names = $OctopusParameters[\\\"K8SInspectNames\\\"] -Split \\\"`n\\\" | % {$_.Trim()}\\n    \\n    if ($OctopusParameters[\\\"K8SInspectNames\\\"] -match '\\\\*' )\\n    {\\n        return Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", $OctopusParameters[\\\"K8SInspectResource\\\"])) |\\n            # Select the stdout property from the execution\\n            Select-Object -ExpandProperty stdout |\\n            # Convert the output from JSON\\n            ConvertFrom-JSON | \\n            # Get the items object from the kubectl response\\n            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\\n            # Extract the name\\n            % {$_.metadata.name} |\\n            # Find any matching resources\\n            ? {$k8sName = $_; ($names | ? {$k8sName -like $_}).Count -ne 0}\\n    }\\n    else\\n    {\\n        return $names\\n    }\\n}\\n\\n\\u003c#\\n.Description\\nGet the kubectl arguments for a given action\\n#\\u003e\\nfunction Get-KubectlVerb() \\n{\\n    switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\\n    {\\n        \\\"get json\\\" {return ,@(\\\"-o\\\", \\\"json\\\", \\\"get\\\")}\\n        \\\"get yaml\\\" {return ,@(\\\"-o\\\", \\\"yaml\\\", \\\"get\\\")}\\n        \\\"describe\\\" {return ,@(\\\"describe\\\")}\\n        \\\"logs\\\" {return ,@(\\\"logs\\\")}\\n        \\\"logs tail\\\" {return ,@(\\\"logs\\\", \\\"--tail\\\", \\\"100\\\")}\\n        \\\"previous logs\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\")}\\n        \\\"previous logs tail\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\", \\\"--tail\\\", \\\"100\\\")}\\n        default {return ,@(\\\"get\\\")}\\n    }\\n}\\n\\n\\u003c#\\n.Description\\nGet an appropiate file extension based on the selected action\\n#\\u003e\\nfunction Get-ArtifactExtension() \\n{\\n   switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\\n    {\\n        \\\"get json\\\" {\\\"json\\\"}\\n        \\\"get yaml\\\" {\\\"yaml\\\"}\\n        default {\\\"txt\\\"}\\n    }\\n}\\n\\nif ($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"] -like \\\"*logs*\\\") \\n{\\n    if ( -not @($OctopusParameters[\\\"K8SInspectResource\\\"]) -like \\\"pod*\\\")\\n    {\\n        Write-Error \\\"Logs can only be returned for pods, not $($OctopusParameters[\\\"K8SInspectResource\\\"])\\\"\\n    }\\n    else\\n    {\\n        Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", \\\"pods\\\") + (Get-Resources)) |\\n            # Select the stdout property from the execution\\n            Select-Object -ExpandProperty stdout |\\n            # Convert the output from JSON\\n            ConvertFrom-JSON | \\n            # Get the items object from the kubectl response\\n            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\\n            # Get the pod logs for each container\\n            % {\\n                $podDetails = $_\\n                @{\\n                    logs=$podDetails.spec.containers | % {$logs=\\\"\\\"} {$logs += (Select-Object -InputObject (Execute-Command kubectl ((Get-KubectlVerb) + @($podDetails.metadata.name, \\\"-c\\\", $_.name))) -ExpandProperty stdout)} {$logs}; \\n                    name=$podDetails.metadata.name\\n                }                \\n            } |\\n            # Write the output\\n            % {Write-Host $_.logs; $_} |\\n            # Optionally capture the artifact\\n            % {\\n                if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \\n                {\\n                    Set-Content -Path \\\"$($_.name).$(Get-ArtifactExtension)\\\" -Value $_.logs\\n                    New-OctopusArtifact \\\"$($_.name).$(Get-ArtifactExtension)\\\"\\n                }\\n            }\\n    }      \\n}\\nelse\\n{\\n    Execute-Command kubectl ((Get-KubectlVerb) + @($OctopusParameters[\\\"K8SInspectResource\\\"]) + (Get-Resources)) |\\n        % {Select-Object -InputObject $_ -ExpandProperty stdout} |\\n        % {Write-Host $_; $_} |\\n        % {\\n            if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \\n            {\\n                Set-Content -Path \\\"output.$(Get-ArtifactExtension)\\\" -Value $_\\n                New-OctopusArtifact \\\"output.$(Get-ArtifactExtension)\\\"\\n            }\\n        }\\n}\\n\"\n        \"Octopus.Action.Script.ScriptSource\"            = \"Inline\"\n        \"K8SInspectResource\"                            = \"service\"\n        \"Octopus.Action.Script.Syntax\"                  = \"PowerShell\"\n        \"Octopus.Action.KubernetesContainers.Namespace\" = \"#{if K8SInspectNamespace}#{K8SInspectNamespace}#{/if}#{unless K8SInspectNamespace}#{Octopus.Action.Kubernetes.Namespace}#{/unless}\"\n        \"K8SInspectNames\"                               = \"#{Kubernetes.Service.Name}*\"\n        \"K8SInspectKubectlVerb\"                         = \"get\"\n      }\n      container {\n        feed_id = local.docker_hub_feed_id\n        image   = \"octopuslabs/k8s-workertools\"\n      }\n      environments = [\n        length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n        length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n        length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n      ]\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = [\"EKS_Reference_Cluster\"]\n  }\n\n  step {\n    condition           = \"Always\"\n    name                = \"Feedback\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.Script\"\n      name                               = \"Feedback\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      properties                         = {\n        \"Octopus.Action.RunOnServer\"         = \"true\"\n        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"\n        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"\n        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"\n      }\n      environments          = []\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = []\n  }\n}\n\nresource \"octopusdeploy_runbook\" \"runbook_octopub_audits_get_deployment\" {\n  count             = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0\n  name              = \"\uD83D\uDEE0\uFE0F Get Deployment\"\n  project_id        = octopusdeploy_project.project_octopub_audits[0].id\n  environment_scope = \"Specified\"\n  environments      = [\n    length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n    length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n    length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n  ]\n  force_package_download      = false\n  default_guided_failure_mode = \"Off\"\n  description                 = <<EOT\n**Action**: Returns the deployments.\n\n**Affects**: Nothing - this runbook makes no changes.\nEOT\n  multi_tenancy_mode          = \"Untenanted\"\n\n  retention_policy {\n    quantity_to_keep    = 100\n    should_keep_forever = false\n  }\n\n  connectivity_policy {\n    allow_deployments_to_no_targets = true\n    exclude_unhealthy_targets       = false\n    skip_machine_behavior           = \"None\"\n  }\n}\n\nresource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_audits_get_deployment\" {\n  count      = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0\n  runbook_id = octopusdeploy_runbook.runbook_octopub_audits_get_deployment[0].id\n\n  step {\n    condition           = \"Success\"\n    name                = \"Get Deployment\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.KubernetesRunScript\"\n      name                               = \"Get Deployment\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      worker_pool_variable               = \"\"\n      properties                         = {\n        \"K8SInspectCreateArtifact\"                      = \"False\"\n        \"Octopus.Action.Script.ScriptBody\"              = \"\\u003c#\\n    This script provides a general purpose method for querying Kubernetes resources. It supports common operations\\n    like get, describe, logs and output formats like yaml and json. Output can be captured as artifacts.\\n#\\u003e\\n\\n\\u003c#\\n.Description\\nExecute an application, capturing the output. Based on https://stackoverflow.com/a/33652732/157605\\n#\\u003e\\nFunction Execute-Command ($commandPath, $commandArguments)\\n{\\n  Write-Host \\\"Executing: $commandPath $($commandArguments -join \\\" \\\")\\\"\\n  \\n  Try {\\n    $pinfo = New-Object System.Diagnostics.ProcessStartInfo\\n    $pinfo.FileName = $commandPath\\n    $pinfo.RedirectStandardError = $true\\n    $pinfo.RedirectStandardOutput = $true\\n    $pinfo.UseShellExecute = $false\\n    $pinfo.Arguments = $commandArguments\\n    $p = New-Object System.Diagnostics.Process\\n    $p.StartInfo = $pinfo\\n    $p.Start() | Out-Null\\n    [pscustomobject]@{\\n        stdout = $p.StandardOutput.ReadToEnd()\\n        stderr = $p.StandardError.ReadToEnd()\\n        ExitCode = $p.ExitCode\\n    }\\n    $p.WaitForExit()\\n  }\\n  Catch {\\n     exit\\n  }\\n}\\n\\n\\u003c#\\n.Description\\nFind any resource names that match a wildcard input if one was specified\\n#\\u003e\\nfunction Get-Resources() \\n{\\n    $names = $OctopusParameters[\\\"K8SInspectNames\\\"] -Split \\\"`n\\\" | % {$_.Trim()}\\n    \\n    if ($OctopusParameters[\\\"K8SInspectNames\\\"] -match '\\\\*' )\\n    {\\n        return Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", $OctopusParameters[\\\"K8SInspectResource\\\"])) |\\n            # Select the stdout property from the execution\\n            Select-Object -ExpandProperty stdout |\\n            # Convert the output from JSON\\n            ConvertFrom-JSON | \\n            # Get the items object from the kubectl response\\n            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\\n            # Extract the name\\n            % {$_.metadata.name} |\\n            # Find any matching resources\\n            ? {$k8sName = $_; ($names | ? {$k8sName -like $_}).Count -ne 0}\\n    }\\n    else\\n    {\\n        return $names\\n    }\\n}\\n\\n\\u003c#\\n.Description\\nGet the kubectl arguments for a given action\\n#\\u003e\\nfunction Get-KubectlVerb() \\n{\\n    switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\\n    {\\n        \\\"get json\\\" {return ,@(\\\"-o\\\", \\\"json\\\", \\\"get\\\")}\\n        \\\"get yaml\\\" {return ,@(\\\"-o\\\", \\\"yaml\\\", \\\"get\\\")}\\n        \\\"describe\\\" {return ,@(\\\"describe\\\")}\\n        \\\"logs\\\" {return ,@(\\\"logs\\\")}\\n        \\\"logs tail\\\" {return ,@(\\\"logs\\\", \\\"--tail\\\", \\\"100\\\")}\\n        \\\"previous logs\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\")}\\n        \\\"previous logs tail\\\" {return ,@(\\\"logs\\\", \\\"--previous\\\", \\\"--tail\\\", \\\"100\\\")}\\n        default {return ,@(\\\"get\\\")}\\n    }\\n}\\n\\n\\u003c#\\n.Description\\nGet an appropiate file extension based on the selected action\\n#\\u003e\\nfunction Get-ArtifactExtension() \\n{\\n   switch($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"])\\n    {\\n        \\\"get json\\\" {\\\"json\\\"}\\n        \\\"get yaml\\\" {\\\"yaml\\\"}\\n        default {\\\"txt\\\"}\\n    }\\n}\\n\\nif ($OctopusParameters[\\\"K8SInspectKubectlVerb\\\"] -like \\\"*logs*\\\") \\n{\\n    if ( -not @($OctopusParameters[\\\"K8SInspectResource\\\"]) -like \\\"pod*\\\")\\n    {\\n        Write-Error \\\"Logs can only be returned for pods, not $($OctopusParameters[\\\"K8SInspectResource\\\"])\\\"\\n    }\\n    else\\n    {\\n        Execute-Command kubectl (@(\\\"-o\\\", \\\"json\\\", \\\"get\\\", \\\"pods\\\") + (Get-Resources)) |\\n            # Select the stdout property from the execution\\n            Select-Object -ExpandProperty stdout |\\n            # Convert the output from JSON\\n            ConvertFrom-JSON | \\n            # Get the items object from the kubectl response\\n            % {if ((Get-Member -InputObject $_ -Name items).Count -ne 0) {Select-Object -InputObject $_ -ExpandProperty items} else {$_}} |\\n            # Get the pod logs for each container\\n            % {\\n                $podDetails = $_\\n                @{\\n                    logs=$podDetails.spec.containers | % {$logs=\\\"\\\"} {$logs += (Select-Object -InputObject (Execute-Command kubectl ((Get-KubectlVerb) + @($podDetails.metadata.name, \\\"-c\\\", $_.name))) -ExpandProperty stdout)} {$logs}; \\n                    name=$podDetails.metadata.name\\n                }                \\n            } |\\n            # Write the output\\n            % {Write-Host $_.logs; $_} |\\n            # Optionally capture the artifact\\n            % {\\n                if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \\n                {\\n                    Set-Content -Path \\\"$($_.name).$(Get-ArtifactExtension)\\\" -Value $_.logs\\n                    New-OctopusArtifact \\\"$($_.name).$(Get-ArtifactExtension)\\\"\\n                }\\n            }\\n    }      \\n}\\nelse\\n{\\n    Execute-Command kubectl ((Get-KubectlVerb) + @($OctopusParameters[\\\"K8SInspectResource\\\"]) + (Get-Resources)) |\\n        % {Select-Object -InputObject $_ -ExpandProperty stdout} |\\n        % {Write-Host $_; $_} |\\n        % {\\n            if ($OctopusParameters[\\\"K8SInspectCreateArtifact\\\"] -ieq \\\"true\\\") \\n            {\\n                Set-Content -Path \\\"output.$(Get-ArtifactExtension)\\\" -Value $_\\n                New-OctopusArtifact \\\"output.$(Get-ArtifactExtension)\\\"\\n            }\\n        }\\n}\\n\"\n        \"Octopus.Action.Script.ScriptSource\"            = \"Inline\"\n        \"K8SInspectResource\"                            = \"deployment\"\n        \"Octopus.Action.Script.Syntax\"                  = \"PowerShell\"\n        \"Octopus.Action.KubernetesContainers.Namespace\" = \"#{if K8SInspectNamespace}#{K8SInspectNamespace}#{/if}#{unless K8SInspectNamespace}#{Octopus.Action.Kubernetes.Namespace}#{/unless}\"\n        \"K8SInspectNames\"                               = \"#{Kubernetes.Deployment.Name}*\"\n        \"K8SInspectKubectlVerb\"                         = \"get\"\n      }\n      container {\n        feed_id = local.docker_hub_feed_id\n        image   = \"octopuslabs/k8s-workertools\"\n      }\n      environments = [\n        length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n        length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n        length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n      ]\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = [\"EKS_Reference_Cluster\"]\n  }\n\n  step {\n    condition           = \"Always\"\n    name                = \"Feedback\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.Script\"\n      name                               = \"Feedback\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      properties                         = {\n        \"Octopus.Action.RunOnServer\"         = \"true\"\n        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"\n        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"\n        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"\n      }\n      environments          = []\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = []\n  }\n}\n\nresource \"octopusdeploy_runbook\" \"runbook_octopub_audits_scale_to_zero\" {\n  count             = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0\n  name              = \"\uD83C\uDF03 Scale Pods to Zero\"\n  project_id        = octopusdeploy_project.project_octopub_audits[0].id\n  environment_scope = \"Specified\"\n  environments      = [\n    length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n    length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n    length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n  ]\n  force_package_download      = false\n  default_guided_failure_mode = \"Off\"\n  description                 = <<EOT\n**WARNING**: This is a destructive operation. The service will no longer be available when scaled down.\n\n**Action**: Scales the deployment down to zero pods.\n\n**Affects**: The audits service is effectively shut down.\n\nThis runbook is designed to be be run in non-production environments after hours to remove the Fargate nodes hosting\nthe service. This removes the cost of hosting the service out of hours.\nEOT\n  multi_tenancy_mode          = \"Untenanted\"\n\n  retention_policy {\n    quantity_to_keep    = 100\n    should_keep_forever = false\n  }\n\n  connectivity_policy {\n    allow_deployments_to_no_targets = true\n    exclude_unhealthy_targets       = false\n    skip_machine_behavior           = \"None\"\n  }\n}\n\nresource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_audits_scale_pods_to_zero\" {\n  count      = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0\n  runbook_id = octopusdeploy_runbook.runbook_octopub_audits_scale_to_zero[0].id\n\n  step {\n    condition           = \"Success\"\n    name                = \"Scale Pods to Zero\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.KubernetesRunScript\"\n      name                               = \"Scale Pods to Zero\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = true\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      worker_pool_variable               = \"\"\n      properties                         = {\n        \"OctopusUseBundledTooling\"           = \"False\"\n        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"\n        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"\n        \"Octopus.Action.Script.ScriptBody\"   = \"kubectl scale --replicas=0 deployment/#{Kubernetes.Deployment.Name}\"\n        \"Octopus.Action.RunOnServer\"         = \"true\"\n      }\n\n      container {\n        feed_id = local.docker_hub_feed_id\n        image   = \"octopuslabs/k8s-workertools\"\n      }\n\n      environments          = []\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = [\"EKS_Reference_Cluster\"]\n  }\n\n  step {\n    condition           = \"Always\"\n    name                = \"Feedback\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.Script\"\n      name                               = \"Feedback\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      properties                         = {\n        \"Octopus.Action.RunOnServer\"         = \"true\"\n        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"\n        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"\n        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"\n      }\n      environments          = []\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = []\n  }\n}\n\nresource \"octopusdeploy_runbook\" \"runbook_octopub_audits_scale_to_one\" {\n  count             = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0\n  name              = \"\uD83C\uDF07 Scale Pods to One\"\n  project_id        = octopusdeploy_project.project_octopub_audits[0].id\n  environment_scope = \"Specified\"\n  environments      = [\n    length(data.octopusdeploy_environments.environment_development.environments) == 0 ? octopusdeploy_environment.environment_development[0].id : data.octopusdeploy_environments.environment_development.environments[0].id,\n    length(data.octopusdeploy_environments.environment_test.environments) == 0 ? octopusdeploy_environment.environment_test[0].id : data.octopusdeploy_environments.environment_test.environments[0].id,\n    length(data.octopusdeploy_environments.environment_production.environments) == 0 ? octopusdeploy_environment.environment_production[0].id : data.octopusdeploy_environments.environment_production.environments[0].id,\n  ]\n  force_package_download      = false\n  default_guided_failure_mode = \"Off\"\n  description                 = <<EOT\n**Action**: Scales the deployment to one pod.\n\n**Affects**: Audits service - this will create new pods if the deployment has been scaled to zero.\n\nThis runbook is designed to be be run in non-production environments during office hours to recreate the pods after they\nwere shutdown after hours.\nEOT\n  multi_tenancy_mode          = \"Untenanted\"\n\n  retention_policy {\n    quantity_to_keep    = 100\n    should_keep_forever = false\n  }\n\n  connectivity_policy {\n    allow_deployments_to_no_targets = true\n    exclude_unhealthy_targets       = false\n    skip_machine_behavior           = \"None\"\n  }\n}\n\nresource \"octopusdeploy_runbook_process\" \"runbook_process_octopub_audits_scale_pods_to_one\" {\n  count      = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? 1 : 0\n  runbook_id = octopusdeploy_runbook.runbook_octopub_audits_scale_to_one[0].id\n\n  step {\n    condition           = \"Success\"\n    name                = \"Scale Pods to One\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.KubernetesRunScript\"\n      name                               = \"Scale Pods to One\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = true\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      worker_pool_variable               = \"\"\n      properties                         = {\n        \"OctopusUseBundledTooling\"           = \"False\"\n        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"\n        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"\n        \"Octopus.Action.Script.ScriptBody\"   = \"kubectl scale --replicas=1 deployment/#{Kubernetes.Deployment.Name}\"\n        \"Octopus.Action.RunOnServer\"         = \"true\"\n      }\n\n      container {\n        feed_id = local.docker_hub_feed_id\n        image   = \"octopuslabs/k8s-workertools\"\n      }\n\n      environments          = []\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = [\"EKS_Reference_Cluster\"]\n  }\n\n  step {\n    condition           = \"Always\"\n    name                = \"Feedback\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.Script\"\n      name                               = \"Feedback\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      properties                         = {\n        \"Octopus.Action.RunOnServer\"         = \"true\"\n        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"\n        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"\n        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"\n      }\n      environments          = []\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = []\n  }\n}\n\ndata \"octopusdeploy_projects\" \"octopub_stack\" {\n  partial_name = \"_ Deploy EKS Octopub Stack\"\n  skip         = 0\n  take         = 1\n}\n\nresource \"octopusdeploy_project\" \"project___deploy_eks_octopub_stack\" {\n  count                                = length(data.octopusdeploy_projects.octopub_stack.projects) == 0 ? 1 : 0\n  name                                 = \"_ Deploy EKS Octopub Stack\"\n  auto_create_release                  = false\n  default_guided_failure_mode          = \"EnvironmentDefault\"\n  default_to_skip_if_already_installed = false\n  discrete_channel_release             = false\n  is_disabled                          = false\n  is_version_controlled                = false\n  lifecycle_id                         = length(data.octopusdeploy_lifecycles.application.lifecycles) == 0 ? octopusdeploy_lifecycle.lifecycle_application[0].id : data.octopusdeploy_lifecycles.application.lifecycles[0].id\n  project_group_id                     = length(data.octopusdeploy_project_groups.eks.project_groups) == 0 ? octopusdeploy_project_group.project_group_eks[0].id : data.octopusdeploy_project_groups.eks.project_groups[0].id\n  included_library_variable_sets       = []\n  tenanted_deployment_participation    = \"Untenanted\"\n\n  connectivity_policy {\n    allow_deployments_to_no_targets = true\n    exclude_unhealthy_targets       = false\n    skip_machine_behavior           = \"None\"\n  }\n\n  versioning_strategy {\n    template = \"#{Octopus.Version.LastMajor}.#{Octopus.Version.LastMinor}.#{Octopus.Version.NextPatch}\"\n  }\n\n  lifecycle {\n    ignore_changes = []\n  }\n  description = \"Deploys the full Octopus application stack\"\n}\n\nresource \"octopusdeploy_deployment_process\" \"deployment_process___deploy_eks_octopub_stack\" {\n  count      = length(data.octopusdeploy_projects.octopub_stack.projects) == 0 ? 1 : 0\n  project_id = octopusdeploy_project.project___deploy_eks_octopub_stack[0].id\n\n  step {\n    condition           = \"Success\"\n    name                = \"Deploy Frontend\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.DeployRelease\"\n      name                               = \"Deploy Frontend\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = true\n      is_required                        = false\n      worker_pool_id                     = \"\"\n      worker_pool_variable               = \"\"\n      properties                         = {\n        \"Octopus.Action.DeployRelease.ProjectId\"           = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? octopusdeploy_project.project_octopub_frontend[0].id : data.octopusdeploy_projects.octopub_frontend.projects[0].id\n        \"Octopus.Action.DeployRelease.DeploymentCondition\" = \"Always\"\n      }\n      environments          = []\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n\n      primary_package {\n        package_id           = length(data.octopusdeploy_projects.octopub_frontend.projects) == 0 ? octopusdeploy_project.project_octopub_frontend[0].id : data.octopusdeploy_projects.octopub_frontend.projects[0].id\n        acquisition_location = \"NotAcquired\"\n        feed_id              = data.octopusdeploy_feeds.project.feeds[0].id\n        properties           = {}\n      }\n    }\n\n    properties   = {}\n    target_roles = []\n  }\n  step {\n    condition           = \"Success\"\n    name                = \"Deploy Products\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.DeployRelease\"\n      name                               = \"Deploy Products\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = true\n      is_required                        = false\n      worker_pool_id                     = \"\"\n      worker_pool_variable               = \"\"\n      properties                         = {\n        \"Octopus.Action.DeployRelease.ProjectId\"           = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? octopusdeploy_project.project_octopub_products[0].id : data.octopusdeploy_projects.octopub_products.projects[0].id\n        \"Octopus.Action.DeployRelease.DeploymentCondition\" = \"Always\"\n      }\n      environments          = []\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n\n      primary_package {\n        package_id           = length(data.octopusdeploy_projects.octopub_products.projects) == 0 ? octopusdeploy_project.project_octopub_products[0].id : data.octopusdeploy_projects.octopub_products.projects[0].id\n        acquisition_location = \"NotAcquired\"\n        feed_id              = data.octopusdeploy_feeds.project.feeds[0].id\n        properties           = {}\n      }\n    }\n\n    properties   = {}\n    target_roles = []\n  }\n  step {\n    condition           = \"Success\"\n    name                = \"Deploy Audits\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.DeployRelease\"\n      name                               = \"Deploy Audits\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = true\n      is_required                        = false\n      worker_pool_id                     = \"\"\n      worker_pool_variable               = \"\"\n      properties                         = {\n        \"Octopus.Action.DeployRelease.ProjectId\"           = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? octopusdeploy_project.project_octopub_audits[0].id : data.octopusdeploy_projects.octopub_audits.projects[0].id\n        \"Octopus.Action.DeployRelease.DeploymentCondition\" = \"Always\"\n      }\n      environments          = []\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n\n      primary_package {\n        package_id           = length(data.octopusdeploy_projects.octopub_audits.projects) == 0 ? octopusdeploy_project.project_octopub_audits[0].id : data.octopusdeploy_projects.octopub_audits.projects[0].id\n        acquisition_location = \"NotAcquired\"\n        feed_id              = data.octopusdeploy_feeds.project.feeds[0].id\n        properties           = {}\n      }\n    }\n\n    properties   = {}\n    target_roles = []\n  }\n\n  step {\n    condition           = \"Always\"\n    name                = \"Feedback\"\n    package_requirement = \"LetOctopusDecide\"\n    start_trigger       = \"StartAfterPrevious\"\n\n    action {\n      action_type                        = \"Octopus.Script\"\n      name                               = \"Feedback\"\n      condition                          = \"Success\"\n      run_on_server                      = true\n      is_disabled                        = false\n      can_be_used_for_project_versioning = false\n      is_required                        = false\n      worker_pool_id                     = local.worker_pool_id\n      properties                         = {\n        \"Octopus.Action.RunOnServer\"         = \"true\"\n        \"Octopus.Action.Script.ScriptSource\" = \"Inline\"\n        \"Octopus.Action.Script.Syntax\"       = \"PowerShell\"\n        \"Octopus.Action.Script.ScriptBody\"   = \"Write-Highlight \\\"Please share your feedback on this step in our GitHub discussion at [https://oc.to/CfiezA](https://oc.to/CfiezA).\\\"\"\n      }\n      environments          = []\n      excluded_environments = []\n      channels              = []\n      tenant_tags           = []\n      features              = []\n    }\n\n    properties   = {}\n    target_roles = []\n  }\n}\n#endregion\n\n#endregion",
    "Octopus.Action.Terraform.TemplateParameters": "{\"octopus_server\":\"#{ReferenceArchitecture.Eks.Octopus.ServerUrl}\",\"octopus_apikey\":\"#{ReferenceArchitecture.Eks.Octopus.ApiKey}\",\"octopus_space_id\":\"#{ReferenceArchitecture.Eks.Octopus.SpaceId}\",\"feed_docker_hub_username\":\"#{ReferenceArchitecture.Eks.Docker.Username}\",\"feed_docker_hub_password\":\"#{ReferenceArchitecture.Eks.Docker.Password}\",\"account_aws_access_key\":\"#{ReferenceArchitecture.Eks.Aws.AccessKey}\",\"account_aws_secret_key\":\"#{ReferenceArchitecture.Eks.Aws.SecretKey}\"}",
    "Octopus.Action.RunOnServer": "true",
    "OctopusUseBundledTooling": "False"
  },
  "Parameters": [
    {
      "Id": "4b7395e1-97a2-4a5b-91a9-c82ac6e5c495",
      "Name": "ReferenceArchitecture.Eks.Aws.AccessKey",
      "Label": "AWS Access Key",
      "HelpText": "This is the AWS Access Key. See the [AWS docs](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_access-keys.html) for more information on creating access keys.",
      "DefaultValue": "",
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      }
    },
    {
      "Id": "bab9514f-4096-48ec-90b5-f55e42044e77",
      "Name": "ReferenceArchitecture.Eks.Aws.SecretKey",
      "Label": "AWS Secret Key",
      "HelpText": "This is the AWS Secret Key. See the [AWS docs](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_access-keys.html) for more information on creating access keys.",
      "DefaultValue": "",
      "DisplaySettings": {
        "Octopus.ControlType": "Sensitive"
      }
    },
    {
      "Id": "0c3fd236-398d-4dd9-a39a-442f877c59e8",
      "Name": "ReferenceArchitecture.Eks.Docker.Username",
      "Label": "Docker Hub Username",
      "HelpText": "The Docker Hub username. See the [Docker docs](https://docs.docker.com/docker-id/) for more information on creating a Docker Hub account.",
      "DefaultValue": "",
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      }
    },
    {
      "Id": "e865ed5a-c17d-40cd-86d1-8cfb102d5b26",
      "Name": "ReferenceArchitecture.Eks.Docker.Password",
      "Label": "Docker Hub Password",
      "HelpText": "The Docker Hub password. See the [Docker docs](https://docs.docker.com/docker-id/) for more information on creating a Docker Hub account.",
      "DefaultValue": "",
      "DisplaySettings": {
        "Octopus.ControlType": "Sensitive"
      }
    },
    {
      "Id": "03759c5c-fce1-4770-8bcc-0ed3004a0d81",
      "Name": "ReferenceArchitecture.Eks.Octopus.ApiKey",
      "Label": "Octopus API Key",
      "HelpText": "The Octopus API key. See the [Octopus docs](https://octopus.com/docs/octopus-rest-api/how-to-create-an-api-key) for more details on creating an API Key.",
      "DefaultValue": "",
      "DisplaySettings": {
        "Octopus.ControlType": "Sensitive"
      }
    },
    {
      "Id": "003255fd-8bdb-4e5c-9646-5588eef5c524",
      "Name": "ReferenceArchitecture.Eks.Octopus.SpaceId",
      "Label": "Octopus Space ID",
      "HelpText": "The Octopus space ID.",
      "DefaultValue": "#{Octopus.Space.Id}",
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      }
    },
    {
      "Id": "cf35bbb0-eb2f-4dec-84bd-1cef24361d0d",
      "Name": "ReferenceArchitecture.Eks.Octopus.ServerUrl",
      "Label": "Octopus Server URL",
      "HelpText": "The Octopus server URL.",
      "DefaultValue": "#{Octopus.Web.ServerUri}",
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      }
    }
  ],
  "StepPackageId": "Octopus.TerraformApply",
  "$Meta": {
    "ExportedAt": "2023-09-28T03:13:22.999Z",
    "OctopusVersion": "2023.4.4254",
    "Type": "ActionTemplate"
  },
  "LastModifiedBy": "mcasperson",
  "Category": "octopus"
}
