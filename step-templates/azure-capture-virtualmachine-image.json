{
  "Id": "dd2b147c-3f20-42e1-a94c-17b157a0f0a4",
  "Name": "Azure - Capture AzureRM Virtual Machine Image",
  "Description": "Prepares an AzureRM Virtual Machine (Managed Disk or Storage Account based) and captures a [Managed Image](https://docs.microsoft.com/en-us/azure/virtual-machines/windows/capture-image-resource) or [Image VHD](https://docs.microsoft.com/en-us/azure/virtual-machines/windows/capture-image):\n1. Runs Sysprep\n2. Deallocates & Generalizes VM\n3. Creates Managed Image or Image VHD\n4. Removes virtual machine resource group",
  "ActionType": "Octopus.AzurePowerShell",
  "Version": 1,
  "Properties": {
    "Octopus.Action.Azure.AccountId": "#{StepTemplate_Account}",
    "Octopus.Action.Script.ScriptSource": "Inline",
    "Octopus.Action.Script.ScriptBody": "<#\n ----- Capture AzureRM Virtual Machine Image ----- \n    Paul Marston @paulmarsy (paul@marston.me)\nLinks\n    https://github.com/OctopusDeploy/Library/commits/master/step-templates/azure-capture-virtualmachine-image.json\n    \nThe sequence of steps performed by the step template:\n    1) Virtual Machine prep\n        a) PowerState/running - Custom script extension is used to sysprep & shutdown\n        b) PowerState/stopped - only when the VM is shutdown by the OS, if Azure stops the VM it is automatically deallocated\n        c) PowerState/deallocated\n        d) OSState/generalized\n    2) Image capture\n        - Managed VM & Managed Image - New image with VM as source\n        - Managed VM & Unmanaged VHD - Access to the underlying blob is granted, and the VHD copied into the specified storage account\n        - Unmanaged VM & Managed Image - New image with VM as source\n        - Unmanaged VM & Unmanaged VHD - VM image is saved, a SAS token is generated and it is copied from the VM's storage account into the specified storage account\n    3) Virtual machine cleanup.\n        Once a VM has been marked as 'generalized' Azure will no longer allow it to be started up, making the VM unusable\n        If the delete option is selected, and the image just created has been moved outside the VM's resource group \n        \n----- Advanced Configuration Settings -----\nVariable names can use either of the following two formats: \n    Octopus.Action.<Setting Name> - will apply to all steps in the deployment, e.g.\n        Octopus.Action.DebugLogging\n    Octopus.Action[Step Name].<Setting Name> - will apply to 'step name' alone, e.g.\n        Octopus.Action[Capture Web VM Image].StorageAccountKey\n\nAvailable Settings:\n    VhdDestContainer - overrides the default container that an unmanaged VHD image is copied to, default is 'images'\n    StorageAccountKey - allows copying to a storage account in a different subscription by using the providing the key, default is null\n#>\n#Requires -Modules AzureRM.Resources\n#Requires -Modules AzureRM.Compute\n#Requires -Modules AzureRM.Storage\n#Requires -Modules Azure.Storage\n\n$ErrorActionPreference = 'Stop'\n\n<#---------- SysPrep Script - Begin  ----------#>\n<#\n    Sysprep marker file: C:\\WindowsAzure\\sysprep\n    1) If marker file exists, sysprep has already been run so exit script\n    2) Start a new powershell process and exit with code 0, this allows the custom script extension to report back as having run successfully to Azure\n        a) In the child script wait until the successful exit code has been logged\n        b) Create the marker file\n        c) Run sysprep\n#>\n$SysPrepScript = @'\nif (Test-Path \"${env:SystemDrive}\\WindowsAzure\\sysprep\") { return }\n\nStart-Process -FilePath 'powershell.exe' -ArgumentList @('-NonInteractive','-NoProfile',('-EncodedCommand {0}' -f ([System.Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes({\n    do {\n        Start-Sleep -Seconds 1\n        $status = Get-ChildItem \"${env:SystemDrive}\\Packages\\Plugins\\Microsoft.Compute.CustomScriptExtension\\*\\Status\\\" -File | Sort-Object LastWriteTime -Descending | Select-Object -First 1 | Get-Content | ConvertFrom-Json\n    } while ($status[0].status.code -ne 0)\n    New-Item -ItemType File -Path \"${env:SystemDrive}\\WindowsAzure\\sysprep\" -Force | Out-Null\n    & (Join-Path -Resolve ([System.Environment]::SystemDirectory) 'sysprep\\sysprep.exe') /oobe /generalize /quiet /shutdown\n}.ToString())))))\n\nexit 0\n'@\n<#---------- SysPrep Script - End ----------#>\n\nfunction Get-OctopusSetting {\n    param([Parameter(Position = 0, Mandatory)][string]$Name, [Parameter(Position = 1)]$DefaultValue)\n    $formattedName = 'Octopus.Action.{0}' -f $Name\n    if ($OctopusParameters.ContainsKey($formattedName)) {\n        $value = $OctopusParameters[$formattedName]\n        if ($DefaultValue -is [int]) { return ([int]::Parse($value)) }\n        if ($DefaultValue -is [bool]) { return ([System.Convert]::ToBoolean($value)) }\n        if ($DefaultValue -is [array] -or $DefaultValue -is [hashtable] -or $DefaultValue -is [pscustomobject]) { return (ConvertFrom-Json -InputObject $value) }\n        return $value\n    }\n    else { return $DefaultValue }\n}\nfunction Test-String {\n    param([Parameter(Position=0)]$InputObject,[switch]$ForAbsence)\n\n    $hasNoValue = [System.String]::IsNullOrWhiteSpace($InputObject)\n    if ($ForAbsence) { $hasNoValue }\n    else { -not $hasNoValue }\n}\nfilter Out-Verbose {\n    Write-Verbose ($_ | Out-String)\n}\nfunction Split-BlobUri {\n    param($Uri)\n    $uriRegex = [regex]::Match($Uri, '(?>https:\\/\\/)(?<Account>[a-z0-9]{3,24})\\.blob\\.core\\.windows\\.net\\/(?<Container>[-a-z0-9]{3,63})\\/(?<Blob>.+)')\n    if (!$uriRegex.Success) {\n        throw \"Unable to parse blob uri: $Uri\"\n    }\n    [pscustomobject]@{\n        Account = $uriRegex.Groups['Account'].Value\n        Container = $uriRegex.Groups['Container'].Value\n        Blob = $uriRegex.Groups['Blob'].Value\n    }\n}\nfunction Get-AzureRmAccessToken {\n    # https://github.com/paulmarsy/AzureRest/blob/master/Internals/Get-AzureRmAccessToken.ps1\n    $accessToken = Invoke-RestMethod -UseBasicParsing -Uri ('https://login.microsoftonline.com/{0}/oauth2/token?api-version=1.0' -f $OctopusAzureADTenantId) -Method Post -Body @{\"grant_type\" = \"client_credentials\"; \"resource\" = \"https://management.core.windows.net/\"; \"client_id\" = $OctopusAzureADClientId; \"client_secret\" = $OctopusAzureADPassword }\n    [System.Net.Http.Headers.AuthenticationHeaderValue]::new('Bearer', $accessToken.access_token).ToString()\n}\nfunction Get-TemporarySasBlob {\n    param($BlobName)\n    # https://github.com/paulmarsy/AzureRest/blob/master/Exported/New-AzureBlob.ps1\n    $sasToken = Invoke-RestMethod -UseBasicParsing -Uri 'https://mscompute2.iaas.ext.azure.com/api/Compute/VmExtensions/GetTemporarySas/' -Headers @{\n        [Microsoft.WindowsAzure.Commands.Common.ApiConstants]::AuthorizationHeaderName = (Get-AzureRmAccessToken)\n    }\n    $containerSas = [uri]::new($sasToken)\n    $container = [Microsoft.WindowsAzure.Storage.Blob.CloudBlobContainer]::new($containerSas)\n    $blobRef = $container.GetBlockBlobReference($BlobName)\n    \n    [psobject]@{\n        Blob = $blobRef\n        Uri = [uri]::new($blobRef.Uri.AbsoluteUri + $containerSas.Query)\n    }\n}\n\n'Checking AzureRM Modules...' | Out-Verbose\nGet-Module | ? Name -like 'AzureRM.*' | Format-Table -AutoSize -Property Name,Version | Out-String | Out-Verbose\nif ((Get-Module AzureRM.Compute | % Version) -lt '2.6.0') {\n    $bundledErrorMessage = if ([System.Convert]::ToBoolean($OctopusUseBundledAzureModules)) {\n        'The Azure PowerShell Modules bundled with Octopus have been loaded. To use the version installed on the server create a variable named \"Octopus.Action.Azure.UseBundledAzurePowerShellModules\" and set its value to \"False\".'\n    }\n    throw \"${bundledErrorMessage}Please ensure version 2.6.0 or newer of the AzureRM.Compute module has been installed. The module can be installed with the PowerShell command: Install-Module AzureRM.Compute -MinimumVersion 2.6.0\"\n}\n\n$vm = Get-AzureRmVM -ResourceGroupName $StepTemplate_ResourceGroupName -Name $StepTemplate_VMName -WarningAction SilentlyContinue\nif ($null -eq $vm) {\n    throw \"Unable to find virtual machine '$StepTemplate_VMName' in resource group '$StepTemplate_ResourceGroupName'\"\n}\nWrite-Host \"Image will be captured from Virtual Machine '$($vm.Name)' in resource group '$($vm.ResourceGroupName)'\"\nif (Test-String $StepTemplate_ImageDest -ForAbsence) {\n    throw \"The Image Destination parameter is required\"\n}\n$StepTemplate_ImageStorageContext = if ($StepTemplate_ImageType -eq 'unmanaged') {\n    $storageAccountKey = Get-OctopusSetting StorageAccountKey $null\n    if (Test-String $storageAccountKey) {\n        Write-Host \"Image will be copied to storage account context '$StepTemplate_ImageDest' using provided key\"\n        New-AzureStorageContext -StorageAccountName $StepTemplate_ImageDest -StorageAccountKey $storageAccountKey\n    } else {\n        $storageAccountResource = Find-AzureRmResource -ResourceNameEquals $StepTemplate_ImageDest -ResourceType Microsoft.Storage/storageAccounts\n        if ($storageAccountResource) {\n            Write-Host \"Image will be copied to storage account '$($storageAccountResource.Name)' found in resource group '$($storageAccountResource.ResourceGroupName)'\"\n        } else {\n            throw \"Unable to find storage account '$StepTemplate_ImageDest'\"\n        }\n        Get-AzureRmStorageAccount -ResourceGroupName $storageAccountResource.ResourceGroupName -Name $storageAccountResource.Name | % Context\n    }\n}\n$StepTemplate_ImageResourceGroupName = switch ($StepTemplate_ImageType) {\n    'managed' {\n        $resourceGroup = Get-AzureRmResourceGroup -Name $StepTemplate_ImageDest | % ResourceGroupName \n        Write-Host \"Managed Image will be created in resource group '$resourceGroup'\"\n        $resourceGroup\n    }\n    'unmanaged' { Find-AzureRmResource -ResourceNameEquals $StepTemplate_ImageDest -ResourceType Microsoft.Storage/storageAccounts | % ResourceGroupName }\n}\nif ($StepTemplate_ImageResourceGroupName -ieq $StepTemplate_ResourceGroupName -and $StepTemplate_DeleteVMResourceGroup -ieq 'True') {\n    throw \"You have chosen to delete the virtual machine and it's resource group ($StepTemplate_ResourceGroupName), however this resource group is also where the captured image will be created!\"\n}\n\nWrite-Host ('-'*80)\nWrite-Host \"Preparing virtual machine $($vm.Name) for image capture...\"\n\n$sysprepRun = $false\nwhile ($true) {\n    $statusCode = Get-AzureRmVM -ResourceGroupName $StepTemplate_ResourceGroupName -Name $StepTemplate_VMName -Status -WarningAction SilentlyContinue | % Statuses | % Code\n    if ($statusCode -contains 'OSState/generalized') {\n        Write-Host 'VM is deallocated & generalized, proceeding to image capture...'\n        break\n    }\n    if ($statusCode -contains 'PowerState/deallocated') {\n        Write-Host 'VM has been deallocated, setting state to generalized... '\n        Set-AzureRmVM -ResourceGroupName $StepTemplate_ResourceGroupName -Name $StepTemplate_VMName -Generalized | Out-Verbose\n        continue\n    }\n    if ($statusCode -contains 'PowerState/deallocating') {\n        Write-Host 'VM is deallocating, waiting...'\n        Start-Sleep 30\n        continue\n    }\n    if ($statusCode -contains 'PowerState/stopped') {\n        Write-Host 'VM has been shutdown, starting deallocation...'\n        Stop-AzureRmVm -ResourceGroupName $StepTemplate_ResourceGroupName -Name $StepTemplate_VMName -Force | Out-Verbose\n        continue\n    }\n    if ($statusCode -contains 'PowerState/stopping') {\n        Write-Host 'VM is stopping, waiting...'\n        Start-Sleep 30\n        continue\n    }\n    if ($statusCode -contains 'PowerState/running' -and $sysprepRun) {\n        Write-Host 'VM is running, but sysprep already deployed, waiting...'\n        Start-Sleep 30\n        continue\n    }\n    if ($statusCode -contains 'PowerState/running') {\n        Write-Host 'VM is running, performing sysprep...'\n        $existingCustomScriptExtensionName = $vm.Extensions | ? VirtualMachineExtensionType -eq 'CustomScriptExtension' | % Name\n        if ($existingCustomScriptExtensionName) {\n            Write-Warning \"Removing existing CustomScriptExtension ($existingCustomScriptExtensionName)...\"\n            Remove-AzureRmVMCustomScriptExtension -ResourceGroupName $StepTemplate_ResourceGroupName -VMName $StepTemplate_VMName -Name $existingCustomScriptExtensionName -Force | Out-Verbose\n        }\n        \n        Write-Host 'Uploading sysprep script to blob storage...'\n        $sysprepScriptFileName = 'Sysprep.ps1'\n        $sysprepScriptBlob = Get-TemporarySasBlob $sysprepScriptFileName\n        $sysprepScriptBlob.Blob.UploadText($SysPrepScript)\n    \n        Write-Host 'Deploying sysprep custom script extension...'\n        Set-AzureRmVMCustomScriptExtension -ResourceGroupName $StepTemplate_ResourceGroupName -VMName $StepTemplate_VMName -Name 'Sysprep' -Location $vm.Location -FileUri $sysprepScriptBlob.Uri -Run $sysprepScriptFileName -ForceRerun (Get-Date).Ticks | Out-Verbose\n        $sysprepRun = $true\n        continue\n    }\n    Write-Warning \"VM is in an unknown state. Current status codes: $($statusCode -join ', '). Waiting...\"\n    Start-Sleep -Seconds 30\n}\n\nWrite-Host ('-'*80)\n\nWrite-Host 'Retrieving virtual machine disk configuration...'\n$vm = Get-AzureRmVM -ResourceGroupName $StepTemplate_ResourceGroupName -Name $StepTemplate_VMName -WarningAction SilentlyContinue \n$isManagedVm = $null -ne $vm.StorageProfile.OsDisk.ManagedDisk\nif ($isManagedVm) { Write-Host \"Virtual machine $($vm.Name) is using Managed Disks\" }\n$isUnmanagedVm = $null -ne $vm.StorageProfile.OsDisk.Vhd\nif ($isUnmanagedVm) { Write-Host \"Virtual machine $($vm.Name) is using unmanaged storage account VHDs\" }\n\nif ($StepTemplate_ImageType -eq 'managed') {\n    Write-Host \"Creating Managed Image of $($vm.Name)...\"\n    $image = New-AzureRmImageConfig -Location $vm.Location -SourceVirtualMachineId $vm.Id\n    New-AzureRmImage -Image $image -ImageName $StepTemplate_ImageName -ResourceGroupName $StepTemplate_ImageResourceGroupName | Out-Verbose\n    Write-Host 'Image created:'\n    Get-AzureRmImage -ImageName $StepTemplate_ImageName -ResourceGroupName $StepTemplate_ImageResourceGroupName | Out-Host\n}\n\nif ($StepTemplate_ImageType -eq 'unmanaged') {\n    if ($isManagedVm) {\n        Write-Host \"Granting access to os disk ($($vm.StorageProfile.OsDisk.Name)) blob...\"\n        $manageDisk = Grant-AzureRmDiskAccess -ResourceGroupName $StepTemplate_ResourceGroupName -DiskName $vm.StorageProfile.OsDisk.Name -DurationInSecond 3600 -Access Read \n        $vhdSasUri = $manageDisk.AccessSAS\n    }\n    if ($isUnmanagedVm) {\n        Write-Host \"Saving Unmanaged Image of $($vm.Name)...\"\n        $armTemplatePath = [System.IO.Path]::GetTempFileName()\n        $vhdDestContainer = Get-OctopusSetting VhdDestContainer 'images'\n        Save-AzureRmVMImage -ResourceGroupName $StepTemplate_ResourceGroupName -Name $StepTemplate_VMName -DestinationContainerName $vhdDestContainer -VHDNamePrefix $StepTemplate_ImageName -Overwrite -Path $armTemplatePath | Out-Verbose\n        $armTemplate = Get-Content -Path $armTemplatePath\n        \"VM Image ARM Template:`n$armTemplate\" | Out-Verbose\n        Remove-Item $armTemplatePath -Force\n        $osDiskUri = ($armTemplate | ConvertFrom-Json).resources.properties.storageprofile.osdisk.image.uri\n        \"OS Disk Image URI: $osDiskUri\" | Out-Verbose\n        $unmanagedVhd = Split-BlobUri $osDiskUri\n        \n        Write-Host \"Granting access to vhd image ($($unmanagedVhd.Blob))...\"\n        $unmanagedVhdStorageResource = Find-AzureRmResource -ResourceNameEquals $unmanagedVhd.Account -ResourceType Microsoft.Storage/storageAccounts\n        $unmanagedVhdStorageResource | Out-Verbose\n        $unmanagedVhdStorageContext = Get-AzureRmStorageAccount -ResourceGroupName $unmanagedVhdStorageResource.ResourceGroupName -Name $unmanagedVhdStorageResource.Name | % Context\n        $vhdSasUri = New-AzureStorageBlobSASToken -Container $unmanagedVhd.Container -Blob $unmanagedVhd.Blob -Permission r -ExpiryTime (Get-Date).AddHours(1) -FullUri -Context $unmanagedVhdStorageContext\n    }\n    Write-Host \"Source image SAS token created: $vhdSasUri\"\n\n    Write-Host 'Copying image to storage account...'\n    $destContainerName = Get-OctopusSetting VhdDestContainer 'images'\n    $destContainer = Get-AzureStorageContainer -Name $destContainerName -Context $StepTemplate_ImageStorageContext -ErrorAction SilentlyContinue\n    if ($destContainer) {\n        Write-Host \"Using container '$destContainerName' in storage account $StepTemplate_ImageDest...\"\n    } else {\n        Write-Host \"Creating container '$destContainerName' in storage account $StepTemplate_ImageDest...\"\n        $destContainer = New-AzureStorageContainer -Name $destContainerName -Context $StepTemplate_ImageStorageContext -Permission Off\n    }\n\n    $copyBlob = Start-AzureStorageBlobCopy -AbsoluteUri $vhdSasUri -DestContainer $destContainerName -DestContext $StepTemplate_ImageStorageContext -DestBlob $StepTemplate_ImageName -Force\n    $copyBlob | Out-Verbose\n    do {   \n        if ($copyState.Status -eq 'Pending') {\n            Start-Sleep -Seconds 60\n        }\n        $copyState = $copyBlob | Get-AzureStorageBlobCopyState\n        $copyState | Out-Verbose\n        $percent = ($copyState.BytesCopied / $copyState.TotalBytes) * 100\n        Write-Host \"Blob transfer $($copyState.Status.ToString().ToLower())... $('{0:N2}' -f $percent)% @ $([System.Math]::Round($copyState.BytesCopied/1GB, 2))GB / $([System.Math]::Round($copyState.TotalBytes/1GB, 2))GB\"\n    } while ($copyState.Status -eq 'Pending')\n    Write-Host \"Final image transfer status: $($copyState.Status)\"\n    \n    if ($isManagedVm) {\n        Write-Host 'Revoking access to os disk blob...'\n        Revoke-AzureRmDiskAccess -ResourceGroupName $StepTemplate_ResourceGroupName -DiskName $vm.StorageProfile.OsDisk.Name | Out-Verbose\n    }\n}\n\nWrite-Host \"Image of $($vm.Name) captured successfully!\"\n\nif ($StepTemplate_DeleteVMResourceGroup -ieq 'True') {\n    Write-Host ('-'*80)\n    Write-Host \"Removing $($vm.Name) VM's resource group $StepTemplate_ResourceGroupName, the following resources will be deleted...\"\n    Find-AzureRmResource -ResourceGroupNameEquals $StepTemplate_ResourceGroupName | Sort-Object -Property ResourceId -Descending | Select-Object -Property ResourceGroupName,ResourceType,ResourceName | Format-Table -AutoSize | Out-Host\n    Remove-AzureRmResourceGroup -Name $StepTemplate_ResourceGroupName -Force | Out-Verbose\n}",
    "Octopus.Action.Package.FeedId": null,
    "Octopus.Action.Script.ScriptFileName": null,
    "Octopus.Action.Package.PackageId": null
  },
  "Parameters": [
    {
      "Id": "911668fe-9653-4f08-892c-0e103e72cad0",
      "Name": "StepTemplate_Account",
      "Label": "Octopus Azure Account",
      "HelpText": "Select the [account id](#/accounts) to use for the connection.",
      "DefaultValue": "",
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      },
      "Links": {}
    },
    {
      "Id": "b838a80e-3e49-4788-8302-6b64bf0159ea",
      "Name": "StepTemplate_ResourceGroupName",
      "Label": "Resource Group Name",
      "HelpText": "Name of the Azure Resource Group containing the Virtual Machine.",
      "DefaultValue": "",
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      },
      "Links": {}
    },
    {
      "Id": "8be775a8-53e4-4740-ae0f-10d72f9fdc67",
      "Name": "StepTemplate_VMName",
      "Label": "Virtual Machine Name",
      "HelpText": "The name of the AzureRM Virtual Machine to capture. This VM will be shut down & generalized.",
      "DefaultValue": "",
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      },
      "Links": {}
    },
    {
      "Id": "73dae502-7a82-461c-a82b-8c40f519611f",
      "Name": "StepTemplate_ImageType",
      "Label": "Image Type",
      "HelpText": "Desired type of image to capture from the Virtual Machine.",
      "DefaultValue": "managed",
      "DisplaySettings": {
        "Octopus.ControlType": "Select",
        "Octopus.SelectOptions": "managed|Managed Image\nunmanaged|Storage Account VHD"
      },
      "Links": {}
    },
    {
      "Id": "111b827b-a2c2-4d57-895e-b18daf9c6344",
      "Name": "StepTemplate_ImageDest",
      "Label": "Image Destination",
      "HelpText": "Where the image should be created.\n\n**Managed Images** should enter a _Resource Group_ name\n\n**Storage Account VHDs** should enter a _Storage Account_ name",
      "DefaultValue": "",
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      },
      "Links": {}
    },
    {
      "Id": "f461eac4-565c-47e6-8bf0-923f9647e3b2",
      "Name": "StepTemplate_ImageName",
      "Label": "Image Name",
      "HelpText": "Name to use when creating the image.",
      "DefaultValue": "",
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      },
      "Links": {}
    },
    {
      "Id": "ba0ea0f4-710c-4732-8fb4-9f9b4faf325b",
      "Name": "StepTemplate_DeleteVMResourceGroup",
      "Label": "Delete VM Resource Group?",
      "HelpText": "Delete the virtual machine resource group after an image has been captured.\n\n**Once a Virtual Machine is marked as generalized Azure will prevent it from being started or modified.**",
      "DefaultValue": "True",
      "DisplaySettings": {
        "Octopus.ControlType": "Checkbox"
      },
      "Links": {}
    }
  ],
  "LastModifiedBy": "paulmarsy",
  "$Meta": {
    "ExportedAt": "2017-05-29T18:58:54.733Z",
    "OctopusVersion": "3.13.7",
    "Type": "ActionTemplate"
  },
  "Category": "azure"
}
